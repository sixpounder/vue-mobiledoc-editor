{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap a4892843bc00eeb7c2d9","webpack:///./~/core-js/library/modules/_descriptors.js","webpack:///./~/core-js/library/modules/_fails.js","webpack:///./~/core-js/library/modules/_global.js","webpack:///./~/core-js/library/modules/_is-object.js","webpack:///./src/MobiledocButton.js","webpack:///./~/core-js/library/modules/_core.js","webpack:///./~/core-js/library/modules/_defined.js","webpack:///./~/core-js/library/modules/_iobject.js","webpack:///./~/core-js/library/modules/_to-integer.js","webpack:///./~/core-js/library/modules/_to-iobject.js","webpack:///./src/addons/MobiledocToolbar.js","webpack:///./src/addons/compToCard.js","webpack:///./src/helpers/mobiledocFormats.js","webpack:///./src/MobiledocEditor.vue?8f07","webpack:///./src/helpers/titlelize.js","webpack:///MobiledocEditor.vue","webpack:///./~/babel-runtime/core-js/object/assign.js","webpack:///./~/babel-runtime/helpers/extends.js","webpack:///./~/core-js/library/fn/object/assign.js","webpack:///./~/core-js/library/modules/_a-function.js","webpack:///./~/core-js/library/modules/_an-object.js","webpack:///./~/core-js/library/modules/_array-includes.js","webpack:///./~/core-js/library/modules/_cof.js","webpack:///./~/core-js/library/modules/_ctx.js","webpack:///./~/core-js/library/modules/_dom-create.js","webpack:///./~/core-js/library/modules/_enum-bug-keys.js","webpack:///./~/core-js/library/modules/_export.js","webpack:///./~/core-js/library/modules/_has.js","webpack:///./~/core-js/library/modules/_hide.js","webpack:///./~/core-js/library/modules/_ie8-dom-define.js","webpack:///./~/core-js/library/modules/_object-assign.js","webpack:///./~/core-js/library/modules/_object-dp.js","webpack:///./~/core-js/library/modules/_object-gops.js","webpack:///./~/core-js/library/modules/_object-keys-internal.js","webpack:///./~/core-js/library/modules/_object-keys.js","webpack:///./~/core-js/library/modules/_object-pie.js","webpack:///./~/core-js/library/modules/_property-desc.js","webpack:///./~/core-js/library/modules/_shared-key.js","webpack:///./~/core-js/library/modules/_shared.js","webpack:///./~/core-js/library/modules/_to-index.js","webpack:///./~/core-js/library/modules/_to-length.js","webpack:///./~/core-js/library/modules/_to-object.js","webpack:///./~/core-js/library/modules/_to-primitive.js","webpack:///./~/core-js/library/modules/_uid.js","webpack:///./~/core-js/library/modules/es6.object.assign.js","webpack:///./~/mobiledoc-kit/dist/mobiledoc.js","webpack:///./~/vue-loader/lib/component-normalizer.js","webpack:///./src/MobiledocEditor.vue","webpack:///external \"vue\"","webpack:///./src/index.js"],"names":["button","h","ctx","clickAction","type","label","$slots","default","props","String","required","tag","prompt","Object","name","text","payload","editMode","Boolean","inject","render","editorVm","titlelize","Error","toggleMarkup","toggleSection","toggleLink","addAtom","addCard","functional","renderCard","comp","isEditing","CompCard","Vue","extend","createCard","env","options","targetNode","document","createElement","cardVm","didRender","propsData","$mount","appendChild","$el","onTeardown","$destroy","compToCard","component","edit","EMPTY_MOBILEDOC","version","markups","atoms","cards","sections","capitalize","str","charAt","toUpperCase","slice","camelize","replace","match","chr","Editor","Button","MobiledocButton"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;AACA;AACA,iCAAiC,QAAQ,gBAAgB,UAAU,GAAG;AACtE,CAAC,E;;;;;;ACHD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,E;;;;;;ACNA;AACA;AACA;AACA,uCAAuC,gC;;;;;;ACHvC;AACA;AACA,E;;;;;;;;ACFA;;AAEA,IAAMA,SAAS,SAATA,MAAS,CAACC,CAAD,EAAIC,GAAJ,EAASC,WAAT,EAAyB;AACtC,SACE;AAAA;AAAA;AACE,eAAM,kBADR;AAAA,eAEE,mBAAkBD,IAAIE,IAAtB;AAFF;AAAA;AAAA,iBAGYD;AAHZ;AAAA;AAAA,KAIID,IAAIG,KAJR,EAKIH,IAAII,MAAJ,CAAWC,OALf;AAAA,GADF;AASD,CAVD;;AAYA,4CAAe;AACbC,SAAO;AAELJ,UAAM,EAAEA,MAAMK,MAAR,EAAgBC,UAAU,IAA1B,EAFD;AAGLL,WAAO,EAAED,MAAMK,MAAR,EAHF;;AAKLE,SAAK,EAAEP,MAAMK,MAAR,EALA;;AAOLG,YAAQ,EAAER,MAAMS,MAAR,EAPH;;AASLC,UAAM,EAAEV,MAAMK,MAAR,EATD;AAULM,UAAM,EAAEX,MAAMK,MAAR,EAAgBF,SAAS;AAAA,eAAM,EAAN;AAAA,OAAzB,EAVD;AAWLS,aAAS,EAAEZ,MAAMS,MAAR,EAAgBN,SAAS,oBAAM,CAAE,CAAjC,EAXJ;;AAaLU,cAAU,EAAEb,MAAMc,OAAR,EAAiBX,SAAS;AAAA,eAAM,IAAN;AAAA,OAA1B;AAbL,GADM;;AAiBbY,UAAQ,CAAC,UAAD,CAjBK;;AAmBbC,QAnBa,kBAmBLnB,CAnBK,EAmBF;AAAA;;AACT,QAAMoB,WAAW,KAAKA,QAAtB;AACA,QAAMjB,OAAO,0FAAAkB,CAAU,KAAKlB,IAAf,CAAb;AACA,QAAIA,SAAS,QAAb,EAAuB;AACrB,UAAI,CAAC,KAAKO,GAAV,EAAe,MAAM,IAAIY,KAAJ,yCAAN;AACf,aAAOvB,OAAOC,CAAP,EAAU,IAAV,EAAgB;AAAA,eAAMoB,SAASG,YAAT,CAAsB,MAAKb,GAA3B,CAAN;AAAA,OAAhB,CAAP;AACD,KAHD,MAGO,IAAIP,SAAS,SAAb,EAAwB;AAC7B,UAAI,CAAC,KAAKO,GAAV,EAAe,MAAM,IAAIY,KAAJ,0CAAN;AACf,aAAOvB,OAAOC,CAAP,EAAU,IAAV,EAAgB;AAAA,eAAMoB,SAASI,aAAT,CAAuB,MAAKd,GAA5B,CAAN;AAAA,OAAhB,CAAP;AACD,KAHM,MAGA,IAAIP,SAAS,MAAb,EAAqB;AAC1B,aAAOJ,OAAOC,CAAP,EAAU,IAAV,EAAgB;AAAA,eAAMoB,SAASK,UAAT,EAAN;AAAA,OAAhB,CAAP;AACD,KAFM,MAEA,IAAItB,SAAS,MAAb,EAAqB;AAC1B,UAAI,CAAC,KAAKU,IAAV,EAAgB,MAAM,IAAIS,KAAJ,wCAAN;AADU,UAElBT,IAFkB,GAEM,IAFN,CAElBA,IAFkB;AAAA,UAEZC,IAFY,GAEM,IAFN,CAEZA,IAFY;AAAA,UAENC,OAFM,GAEM,IAFN,CAENA,OAFM;;AAG1B,aAAOhB,OAAOC,CAAP,EAAU,IAAV,EAAgB;AAAA,eAAMoB,SAASM,OAAT,CAAiBb,IAAjB,EAAuBC,IAAvB,EAA6BC,OAA7B,CAAN;AAAA,OAAhB,CAAP;AACD,KAJM,MAIA,IAAIZ,SAAS,MAAb,EAAqB;AAC1B,UAAI,CAAC,KAAKU,IAAV,EAAgB,MAAM,IAAIS,KAAJ,wCAAN;AADU,UAElBT,KAFkB,GAEU,IAFV,CAElBA,IAFkB;AAAA,UAEZE,QAFY,GAEU,IAFV,CAEZA,OAFY;AAAA,UAEHC,QAFG,GAEU,IAFV,CAEHA,QAFG;;AAG1B,aAAOjB,OAAOC,CAAP,EAAU,IAAV,EAAgB;AAAA,eAAMoB,SAASO,OAAT,CAAiBd,KAAjB,EAAuBE,QAAvB,EAAgCC,QAAhC,CAAN;AAAA,OAAhB,CAAP;AACD,KAJM,MAIA,MAAM,IAAIM,KAAJ,iBAAwBnB,IAAxB,qBAAN;AACR;AAvCY,CAAf,C;;;;;;ACdA,6BAA6B;AAC7B,qCAAqC,gC;;;;;;ACDrC;AACA;AACA;AACA;AACA,E;;;;;;ACJA;AACA;AACA;AACA;AACA,E;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;ACLA;;AAEA,4CAAe;AACbyB,cAAY,IADC;;AAGbT,QAHa,kBAGLnB,CAHK,EAGF;AACT,WACE;AAAA;AAAA;AAAA,iBAAK,IAAG,mBAAR;AAAA;AAAA,OACE;AAAC,yEAAD;AAAA;AAAA,mBAAiB,MAAK,QAAtB,EAA+B,KAAI,QAAnC;AAAA;AAAA;AAAA,OADF,EAEE;AAAC,yEAAD;AAAA;AAAA,mBAAiB,MAAK,QAAtB,EAA+B,KAAI,IAAnC;AAAA;AAAA;AAAA,OAFF,EAGE;AAAC,yEAAD;AAAA;AAAA,mBAAiB,MAAK,MAAtB;AAAA;AAAA;AAAA,OAHF,EAIE;AAAC,yEAAD;AAAA;AAAA,mBAAiB,MAAK,SAAtB,EAAgC,KAAI,IAApC;AAAA;AAAA;AAAA,OAJF,EAKE;AAAC,yEAAD;AAAA;AAAA,mBAAiB,MAAK,SAAtB,EAAgC,KAAI,IAApC;AAAA;AAAA;AAAA,OALF,EAME;AAAC,yEAAD;AAAA;AAAA,mBAAiB,MAAK,SAAtB,EAAgC,KAAI,IAApC;AAAA;AAAA;AAAA,OANF,EAOE;AAAC,yEAAD;AAAA;AAAA,mBAAiB,MAAK,SAAtB,EAAgC,KAAI,IAApC;AAAA;AAAA;AAAA,OAPF,EAQE;AAAC,yEAAD;AAAA;AAAA,mBAAiB,MAAK,SAAtB,EAAgC,KAAI,YAApC;AAAA;AAAA;AAAA,OARF,EASE;AAAC,yEAAD;AAAA;AAAA,mBAAiB,MAAK,SAAtB,EAAgC,KAAI,YAApC;AAAA;AAAA;AAAA,OATF,EAUE;AAAA;AAAA;AAAA;AAAA,OAVF;AAAA,KADF;AAcD;AAlBY,CAAf,C;;;;;;;;;;;;;ACFA;;AAEA,SAAS6B,UAAT,CAAqBC,IAArB,EAA8C;AAAA,MAAnBC,SAAmB,uEAAP,KAAO;;AAC5C,MAAMC,WAAW,2CAAAC,CAAIC,MAAJ,CAAWJ,IAAX,CAAjB;;AAEA,SAAO,SAASK,UAAT,OAAgD;AAAA,QAAzBC,GAAyB,QAAzBA,GAAyB;AAAA,QAApBC,OAAoB,QAApBA,OAAoB;AAAA,QAAXtB,OAAW,QAAXA,OAAW;;AACrD,QAAMuB,aAAaC,SAASC,aAAT,CAAuB,KAAvB,CAAnB;;AAEA,QAAIC,eAAJ;AACAL,QAAIM,SAAJ,CAAc,YAAM;AAClB3B,gBAAA,qEAAAA,KAAeA,OAAf;;AAEA,UAAM4B,YAAY,EAAEP,QAAF,EAAOrB,gBAAP,EAAgBsB,gBAAhB,EAAyBN,oBAAzB,EAAlB;;AAEAU,eAAS,IAAIT,QAAJ,CAAa,EAAEW,oBAAF,EAAb,EAA4BC,MAA5B,EAAT;AACAN,iBAAWO,WAAX,CAAuBJ,OAAOK,GAA9B;AACD,KAPD;;AASAV,QAAIW,UAAJ,CAAe,YAAM;AAEnBN,aAAOO,QAAP;AACD,KAHD;;AAKA,WAAOV,UAAP;AACD,GAnBD;AAoBD;;AAEc,SAASW,UAAT,CAAqBC,SAArB,EAAgCrC,IAAhC,EAAsC;AACnD,MAAI,CAACA,IAAD,IAAS,OAAOqC,UAAUrC,IAAjB,KAA0B,WAAvC,EAAoD;AAClD,UAAM,IAAIS,KAAJ,CAAU,yCAAyC4B,SAAnD,CAAN;AACD;;AAED,SAAO;AACLrC,UAAMA,QAAQqC,UAAUrC,IADnB;AAELV,UAAM,KAFD;AAGL+C,wBAHK;AAIL/B,YAAQU,WAAWqB,SAAX,CAJH;AAKLC,UAAMtB,WAAWqB,SAAX,EAAsB,IAAtB;AALD,GAAP;AAOD,C;;;;;;;;ACvCM,IAAME,kBAAkB;AAC7BC,WAAS,OADoB;AAE7BC,WAAS,EAFoB;AAG7BC,SAAO,EAHsB;AAI7BC,SAAO,EAJsB;AAK7BC,YAAU;AALmB,CAAxB,C;;;;;;ACAP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACXO,SAASC,UAAT,CAAqBC,GAArB,EAA0B;AAC/B,SAAOA,IAAIC,MAAJ,CAAW,CAAX,EAAcC,WAAd,KAA8BF,IAAIG,KAAJ,CAAU,CAAV,CAArC;AACD;;AAEM,SAASC,QAAT,CAAmBJ,GAAnB,EAAwB;AAC7B,SAAOA,IAAIK,OAAJ,CAAY,SAAZ,EAAuB,UAAUC,KAAV,EAAiBC,GAAjB,EAAsB;AAClD,WAAOA,IAAIL,WAAJ,EAAP;AACD,GAFM,CAAP;AAGD;;AAED,4CAAe,UAAUF,GAAV,EAAe;AAC5B,SAAOD,WAAWK,SAASJ,GAAT,CAAX,CAAP;AACD,C;;;;;;;;;;;ACFD;;AAEA;8BAEA;;qBAGA;AAFA;AAIA;;;;6DAEA;;eACA;;;eACA;;;eACA;;;eACA;;;eACA;;;eACA;;+DACA;;eAGA;;AAXA;;wBAYA;;cAEA;wBACA;yBACA;oBAEA;AALA;AAOA;;;;4CAEA;;wBAEA;yBACA;0BACA;+BACA;wBACA;oBACA;oBACA;0BAEA;AATA;AAWA;;AACA;;;;uBAEA;;;uBACA;;+BACA;gCACA;2BACA;4BACA;yBACA;6BACA;sBACA;sBAEA;AAXA;AAaA;;AACA,mBACA;;+CACA;AAGA;AAlCA;;;sCAoCA;0BACA;AAGA;AALA;;sCAMA;SACA;AAEA;;AAEA;;;oBACA;;eACA;AAEA;;;;6CAEA;+BACA;AAEA;+CACA;gCACA;AAEA;;AACA;;oCAEA,2EAEA,oFACA;AAEA;;AACA;;;yCACA;AAEA;;AACA;;;4CACA;AAEA;8CACA;mEACA;AAEA;;AACA;;iBAEA;;2FAEA;;6CAEA;;yCAEA;;iDACA;eACA;eACA;AAEA;;4CAGA;uDACA;uCACA;AACA;AAEA;oDACA;oCACA;AAEA;gEACA;;iBACA;;AAEA;kEAIA;2EACA;iDACA;AACA;AAGA;AApEA;;0CAqEA;gBACA;AACA;AAtJA,E;;;;;;ACbA,kBAAkB,wD;;;;;;;ACAlB;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;ACtBA;AACA,sD;;;;;;ACDA;AACA;AACA;AACA,E;;;;;;ACHA;AACA;AACA;AACA;AACA,E;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,WAAW,eAAe;AAC/B;AACA,KAAK;AACL;AACA,E;;;;;;ACpBA,iBAAiB;;AAEjB;AACA;AACA,E;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACNA;AACA;AACA;AACA,a;;;;;;ACHA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd,cAAc;AACd,cAAc;AACd,eAAe;AACf,eAAe;AACf,eAAe;AACf,gBAAgB;AAChB,yB;;;;;;AC5DA,uBAAuB;AACvB;AACA;AACA,E;;;;;;ACHA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,E;;;;;;ACPA;AACA,qEAAsE,gBAAgB,UAAU,GAAG;AACnG,CAAC,E;;;;;;;ACFD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU,EAAE;AAC9C,mBAAmB,sCAAsC;AACzD,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC,W;;;;;;AChCD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,UAAU;AACb;AACA;AACA;AACA,E;;;;;;ACfA,yC;;;;;;ACAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;AChBA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;ACNA,cAAc,sB;;;;;;ACAd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACPA;AACA;AACA;AACA;AACA,E;;;;;;ACJA;AACA;AACA,mDAAmD;AACnD;AACA,uCAAuC;AACvC,E;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACNA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,E;;;;;;ACLA;AACA;AACA;AACA;AACA,E;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACXA;AACA;AACA;AACA;AACA,E;;;;;;ACJA;AACA;;AAEA,0CAA0C,gCAAoC,E;;;;;;;;;;;;;;ACH9E;AAAA;AACA;AACA;AACA,GAAG;AACH,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iCAAiC;;AAExD,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C,GAAG;AACH;AACA;;AAEA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,YAAY,OAAO,EAAE;AACrB;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,cAAc;;AAEhC,eAAe,QAAQ;AACvB,8BAA8B,cAAc;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW;AAC7C;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA,SAAS,iBAAiB;;AAE1B;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,YAAY;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA,KAAK;AACL,qCAAqC,WAAW;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iEAAiE;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,KAAK;AACL;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;;AAEA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO,EAAE;AACrB;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,GAAG;AACH;AACA,YAAY;AACZ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ,GAAG;AACH,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH,UAAU;AACV;;AAEA;AACA,OAAO,mDAAmD;AAC1D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,0BAA0B;AAC1B,8BAA8B;AAC9B;AACA,GAAG;AACH,yBAAyB;AACzB,6BAA6B;AAC7B;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA,yBAAyB,WAAW;AACpC,uDAAuD,mBAAmB;AAC1E;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,UAAU;AAC7B;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA,sBAAsB,aAAa;;AAEnC,SAAS,0CAA0C;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA,2CAA2C,kBAAkB,2BAA2B,mBAAmB;AAC3G;;AAEA,SAAS,+BAA+B;;AAExC;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,SAAS,qBAAqB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,oBAAoB;;AAE3B;AACA,qBAAqB,WAAW;AAChC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,SAAS,oCAAoC;AAC7C;AACA;AACA;AACA;;AAEA,SAAS,eAAe,uCAAuC,gBAAgB;AAC/E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc;AACd;AACA;AACA,6BAA6B,QAAQ;;AAErC,SAAS,yBAAyB;AAClC,kBAAkB,QAAQ;;AAE1B;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oEAAoE,qBAAqB;AACzF;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uEAAuE,qBAAqB;AAC5F;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,2BAA2B;AACxC,0BAA0B,sDAAsD;;AAEhF,sBAAsB,cAAc;AACpC,gBAAgB,cAAc;AAC9B,kBAAkB,cAAc;AAChC,kBAAkB,cAAc;AAChC,YAAY,cAAc;AAC1B,YAAY,cAAc;AAC1B,UAAU,aAAa;AACvB,cAAc,aAAa;;AAE3B,wBAAwB,WAAW;AACnC;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,yBAAyB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,2BAA2B;;AAEvE,OAAO,MAAM;AACb;;AAEA;AACA;AACA,GAAG;AACH;AACA,iBAAiB,QAAQ;;AAEzB,gCAAgC,UAAU;AAC1C,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;;AAEvB;AACA;;AAEA;AACA,qDAAqD,UAAU;;AAE/D;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,6BAA6B;AACxC,WAAW,gBAAgB;;AAE3B;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,uCAAuC;AAClD;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA,iCAAiC,+BAA+B;AAChE;AACA,KAAK;AACL;AACA;;AAEA;AACA,iCAAiC,WAAW;AAC5C,WAAW,OAAO;AAClB,sCAAsC,KAAK,oBAAoB,KAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS,mBAAmB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA,+CAA+C,UAAU;AACzD;;AAEA,OAAO,2CAA2C;;AAElD;AACA;AACA;;AAEA;AACA,SAAS,aAAa;;AAEtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,aAAa,eAAe;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,UAAU;AACV;AACA,aAAa,MAAM;AACnB,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB;AACnB,KAAK;;AAEL,SAAS,UAAU,OAAO,EAAE;;AAE5B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS,uBAAuB,gBAAgB;AAC7D,aAAa,OAAO;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,0GAA0G,KAAK,EAAE,aAAa;AAC9H,uDAAuD,aAAa;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA,4DAA4D,KAAK,EAAE,aAAa;AAChF;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;;AAExB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,MAAM;AACpB;AACA;AACA;AACA,WAAW,UAAU;;AAErB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,cAAc,UAAU;AACxB;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,cAAc,SAAS;AACvB;AACA;AACA;AACA,SAAS,kBAAkB;AAC3B;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc,SAAS;AACvB;AACA;AACA,SAAS,UAAU;AACnB,gCAAgC,QAAQ;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,cAAc,SAAS;AACvB;AACA;AACA,SAAS,UAAU;AACnB,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA,4BAA4B,QAAQ;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;;AAEpC;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,0BAA0B;AAC1F;AACA,MAAM;AACN;AACA,aAAa,cAAc;AAC3B;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,OAAO;;AAEhB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,gEAAgE,OAAO;AACvE;AACA,OAAO;AACP,gEAAgE,OAAO;AACvE;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,SAAS,OAAO;AAChB,+BAA+B,IAAI;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,cAAc,MAAM;AACpB;AACA;AACA;AACA,SAAS,kBAAkB;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,eAAe;AACf;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,UAAU;AACV;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kEAAkE,iBAAiB;AACnF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,mCAAmC,iBAAiB,mBAAmB;AACvE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4CAA4C;;AAE5C;AACA;AACA;;AAEA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;;AAEA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,iCAAiC,4BAA4B;AAC7D,mBAAmB,QAAQ,GAAG,0BAA0B;;AAExD;AACA;AACA;AACA,mCAAmC,kCAAkC;AACrE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,cAAc;AACd;AACA,SAAS,sBAAsB;AAC/B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL,2CAA2C,UAAU;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iCAAiC,4BAA4B;AAC7D,mBAAmB,QAAQ,GAAG,0BAA0B;;AAExD;AACA;AACA;AACA,mCAAmC,kCAAkC;AACrE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,cAAc;AACd;AACA,SAAS,qEAAqE;AAC9E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,2CAA2C,UAAU;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;;AAEA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;;AAEA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iCAAiC,4BAA4B;AAC7D,mBAAmB,QAAQ,GAAG,0BAA0B;;AAExD;AACA;AACA;AACA,mCAAmC,kCAAkC;AACrE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,cAAc;AACd;AACA,SAAS,qEAAqE;AAC9E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,2CAA2C,UAAU;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;;AAEA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;;AAEA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iCAAiC,4BAA4B;AAC7D,mBAAmB,QAAQ,GAAG,0BAA0B;;AAExD;AACA;AACA;AACA,mCAAmC,kCAAkC;AACrE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,cAAc;AACd;AACA,SAAS,qEAAqE;AAC9E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,2CAA2C,UAAU;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;;AAEA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;;AAEA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,QAAQ;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,QAAQ;;AAErC;;AAEA;;AAEA;AACA;;AAEA,+BAA+B,OAAO,4BAA4B,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS,QAAQ,OAAO,EAAE;AAC1B;AACA,eAAe,KAAK,wCAAwC,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,mCAAmC,iBAAiB,EAAE;AACjE;AACA,yCAAyC,6BAA6B;AACtE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS,QAAQ,OAAO,EAAE;AAC1B;AACA,eAAe,KAAK,iDAAiD,SAAS;AAC9E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,WAAW,8BAA8B,oBAAoB;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,OAAO;AACjF;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,uBAAuB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,uBAAuB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,KAAK;;AAEL,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA,mBAAmB,OAAO,gCAAgC;AAC1D,0BAA0B;;AAE1B;AACA,0CAA0C,oCAAoC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,uCAAuC,oCAAoC;AAC3E;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA,WAAW,kBAAkB,UAAU,kBAAkB;;AAEzD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,oCAAoC;AACrE;;AAEA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAiE;AACjE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,8BAA8B,MAAM,EAAE,MAAM;AAC5C,8BAA8B,MAAM,EAAE,eAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;;AAEA,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU,kCAAkC,UAAU;AACrE;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU,kCAAkC,UAAU;AACrE;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,SAAS,yBAAyB;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;;AAE3B;;AAEA,SAAS,uBAAuB;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,gBAAgB;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,oCAAoC;AACpC;;AAEA;AACA;;AAEA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,QAAQ;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,QAAQ;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS,QAAQ;AACjB;AACA;AACA;AACA;;AAEA;AACA,SAAS,kBAAkB;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,UAAU;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,yDAAyD;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,UAAU;AACnB;AACA,SAAS,wBAAwB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,QAAQ;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA,SAAS,UAAU;AACnB;AACA,SAAS,sCAAsC;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,aAAa;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,QAAQ;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,SAAS,aAAa;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc,MAAM;AACpB;AACA;AACA,4BAA4B,2BAA2B;;AAEvD,SAAS,wBAAwB;AACjC;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,UAAU;AACnB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA,WAAW,wBAAwB;AACnC,WAAW,mCAAmC;AAC9C,WAAW,mCAAmC;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,kBAAkB;AAC7B,wDAAwD,cAAc;;AAEtE;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,2BAA2B,cAAc;;AAEzC;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,qCAAqC,aAAa;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS,UAAU;AACnB;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,6DAA6D,OAAO;AACpE;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc,SAAS,mDAAmD;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,cAAc,SAAS,iDAAiD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB,cAAc,MAAM;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,YAAY,MAAM,mBAAmB,iBAAiB,EAAE;AACrE;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;;AAExB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,mBAAmB,aAAa;;AAEhC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB,cAAc,KAAK,6BAA6B;AAChD;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,aAAa;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,0BAA0B,GAAG,4CAA4C;AACrF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,WAAW;AACzD;AACA,IAAI,aAAa;AACjB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK;AAChE;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,cAAc;AACd;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO,YAAY;AAChC,cAAc;AACd;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO,YAAY;AAChC,aAAa,SAAS;AACtB,cAAc;AACd;AACA,uCAAuC;AACvC;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA,OAAO,SAAS,cAAc,UAAU,EAAE,EAAE;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,UAAU;AACnB;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA,OAAO,SAAS,cAAc,UAAU,EAAE,EAAE;AAC5C;AACA;AACA;AACA;;AAEA;AACA,SAAS,UAAU;AACnB;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,OAAO,OAAO;AACd;AACA;;AAEA;AACA,OAAO,MAAM;AACb,OAAO,OAAO,SAAS;AACvB;AACA;AACA,GAAG;AACH;;AAEA;AACA,OAAO,MAAM;AACb,OAAO,OAAO,SAAS;AACvB;AACA;AACA,GAAG;AACH;;AAEA;AACA,OAAO,QAAQ;AACf;AACA,SAAS,cAAc,UAAU,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;;AAEH,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA,CAAC;AACD;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,sEAAsE,UAAU;AAChF;AACA;AACA;AACA;;AAEA;AACA,OAAO,MAAM;;AAEb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,mBAAmB;AAClD;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,iBAAiB;AACvD;AACA,KAAK;AACL,iCAAiC,gBAAgB,aAAa,iBAAiB;AAC/E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,gBAAgB;AACzB;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,YAAY;AACrB,SAAS,SAAS;AAClB,SAAS,gBAAgB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,oCAAoC,QAAQ;AAC5C;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,OAAO,gBAAgB;;AAEvB;AACA;AACA;AACA,GAAG,iEAAiE;AACpE;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA,WAAW;AACX,WAAW;AACX,WAAW;AACX;AACA;AACA,kCAAkC,sBAAsB;AACxD;AACA,mCAAmC,0BAA0B,IAAI,KAAK;AACtE;;AAEA,OAAO,gBAAgB;AACvB,OAAO,0CAA0C;;AAEjD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX,YAAY,yCAAyC;AACrD,YAAY;AACZ;AACA;AACA,yCAAyC,iCAAiC,GAAG,aAAa,EAAE,oBAAoB;AAChH,OAAO,aAAa;;AAEpB;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,WAAW;AACX,WAAW,OAAO;AAClB,WAAW,OAAO,YAAY;AAC9B,YAAY;AACZ;AACA;AACA,+CAA+C,OAAO,GAAG;AACzD,OAAO,mCAAmC;AAC1C,OAAO,aAAa;;AAEpB;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,SAAS;;AAElB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,SAAS;;AAElB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,UAAU,SAAS,cAAc,UAAU,EAAE,EAAE,EAAE;AAC1D;;AAEA,iBAAiB,2BAA2B;AAC5C;AACA,WAAW,YAAY;;AAEvB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,QAAQ;AAC/B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,mDAAmD;AAC5D,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,QAAQ;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS,UAAU,UAAU,EAAE;AAC/B;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,KAAK;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,gBAAgB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS,4BAA4B;AACrC,8BAA8B,QAAQ;;AAEtC;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,SAAS;AAClB,8BAA8B,QAAQ;AACtC,6BAA6B,QAAQ;;AAErC;AACA,uCAAuC,YAAY;;AAEnD,yCAAyC,QAAQ;;AAEjD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,SAAS;AAClB,8BAA8B,QAAQ;AACtC;AACA,uCAAuC,aAAa;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS,kBAAkB,cAAc,EAAE;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,SAAS,SAAS;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,aAAa;;AAErE;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA,SAAS,yBAAyB;AAClC,SAAS,SAAS;;AAElB;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,SAAS,SAAS,QAAQ,eAAe,iBAAiB,EAAE;;AAE5D;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,SAAS,mBAAmB;AAC5B;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;;AAGA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,SAAS,aAAa;AACtB,SAAS,UAAU,OAAO,EAAE;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,SAAS,UAAU,OAAO,EAAE;AAC5B;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK,IAAI;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,eAAe,KAAK;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,YAAY;AACvF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,aAAa;AAC1D;;AAEA;AACA;;AAEA,kEAAkE;AAClE;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,aAAa,MAAM,MAAM;AACzB,+BAA+B,KAAK;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,kCAAkC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA,iBAAiB,oCAAoC;AACrD;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,KAAK;AACxC;AACA;;AAEA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,SAAS,gBAAgB,YAAY,oBAAoB,SAAS;AACjG;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,aAAa,MAAM,MAAM;AACzB,+BAA+B,KAAK;AACpC;AACA;;AAEA;AACA,aAAa,MAAM,MAAM;AACzB,+BAA+B,KAAK;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA,iBAAiB,oCAAoC;AACrD;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,KAAK;AACxC;AACA;;AAEA,uCAAuC,KAAK;AAC5C;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;;AAEA,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,gBAAgB;;AAEzB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,SAAS,gBAAgB,YAAY,oBAAoB,SAAS;AACjG;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,SAAS,gBAAgB,YAAY,oBAAoB,SAAS;AACjG;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,uBAAuB;;AAEhC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA,gCAAgC,UAAU,qBAAqB,YAAY,UAAU,UAAU;AAC/F;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA,gCAAgC,UAAU,kBAAkB,YAAY,UAAU,UAAU;AAC5F;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,6BAA6B;AAC7B,8BAA8B;AAC9B;AACA;AACA,IAAI,GAAG;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,UAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;;AAEA;AACA;AACA,SAAS,gDAAgD;AACzD,SAAS,iCAAiC;AAC1C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,YAAY;AACZ;;AAEA;AACA,iBAAiB,oCAAoC;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,SAAS,gBAAgB,cAAc,mBAAmB,gBAAgB;AACzG;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;;AAEA;AACA;;AAEA,SAAS,oEAAoE;AAC7E,SAAS,wDAAwD;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,YAAY;AACZ;;AAEA;AACA,iBAAiB,oCAAoC;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,gBAAgB;;AAEzB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,SAAS,gBAAgB,cAAc,mBAAmB,gBAAgB;AACzG;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,SAAS,gBAAgB,cAAc,mBAAmB,gBAAgB;AACzG;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,uBAAuB;;AAEhC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA,+BAA+B,UAAU,kBAAkB,cAAc,UAAU,UAAU;AAC7F;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA,+BAA+B,UAAU,kBAAkB,cAAc,UAAU,UAAU;AAC7F;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;;AAEA;AACA,eAAe,kEAAkE,GAAG;AACpF;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;;AAEA;AACA,SAAS,UAAU;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,wBAAwB,IAAI;AAC5B,0DAA0D,SAAS;AACnE,GAAG;AACH,wBAAwB,IAAI;AAC5B,0DAA0D,SAAS;AACnE,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA,qBAAqB,WAAW;AAChC,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA,QAAQ,6BAA6B;AACrC,QAAQ,2BAA2B;AACnC,yDAAyD;AACzD;AACA,QAAQ,gCAAgC;AACxC;AACA,QAAQ,2BAA2B,MAAM,4BAA4B;AACrE;AACA,QAAQ,yBAAyB;AACjC;AACA,QAAQ,gCAAgC;AACxC,8BAA8B;AAC9B;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,WAAW;AACxB;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA,cAAc;AACd;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS,kEAAkE;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,yBAAyB,uCAAuC;AAChE;AACA;;AAEA;AACA,SAAS,gBAAgB;AACzB;AACA;AACA,KAAK;AACL;AACA,uBAAuB;AACvB;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,6BAA6B,wBAAwB;AACrD;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA,2EAA2E,KAAK;AAChF;AACA,KAAK;AACL;;AAEA;AACA,sBAAsB,6BAA6B;AACnD;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB,EAAE,4CAA4C;AAC/E,SAAS,QAAQ;;AAEjB;AACA;AACA,oDAAoD,KAAK;AACzD,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,QAAQ;;AAEpC;;AAEA,SAAS,QAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,mBAAmB,yBAAyB,EAAE;AACnE;AACA,6BAA6B,QAAQ;;AAErC;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,WAAW,iBAAiB;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,cAAc;AAC3B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,UAAU;AACxB;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,cAAc,mCAAmC;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,aAAa,OAAO,iBAAiB;AACrC,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,wCAAwC;AACxC;AACA,gDAAgD,OAAO;AACvD;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA,6BAA6B,+BAA+B;AAC5D,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,iBAAiB;AAC9B,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,sDAAsD,uBAAuB;AAC7E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS,qDAAqD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;;AAEA;AACA,kDAAkD,0BAA0B;AAC5E;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO,eAAe,QAAQ;AAC3C;AACA;AACA;AACA,oCAAoC;AACpC;AACA,SAAS,QAAQ;AACjB;AACA,6DAA6D,uBAAuB;AACpF,uBAAuB,QAAQ;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS,SAAS;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA,SAAS,+BAA+B,iBAAiB,EAAE;;AAE3D;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO,gBAAgB;AACpC,cAAc,KAAK;AACnB;AACA;AACA,kDAAkD;AAClD,4BAA4B,QAAQ;AACpC;AACA;AACA;;AAEA;AACA,SAAS,QAAQ;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO,gBAAgB;AACpC,aAAa,QAAQ;AACrB,cAAc,KAAK;AACnB;AACA;AACA,qCAAqC;AACrC,4BAA4B,QAAQ;AACpC;AACA;AACA;;AAEA;AACA,SAAS,QAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,0BAA0B;;AAEvD;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEQ;AACR;;;;;;;ACl+XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,mCAAmC;AACnC,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9CA,gBAAgB,mBAAmB,aAAa,0BAA0B;AAC1E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC,qB;;;;;;ACXD,gD;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;;AAEA;;AAQA,kDAAe;AACbQ,UAAQ,uDADK;AAEbC,UAAQ,gEAAAC;AAFK,CAAf,C","file":"build.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vue\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vue\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vueMobiledocEditor\"] = factory(require(\"vue\"));\n\telse\n\t\troot[\"vueMobiledocEditor\"] = factory(root[\"vue\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_48__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 49);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a4892843bc00eeb7c2d9","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_descriptors.js\n// module id = 0\n// module chunks = 0","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_fails.js\n// module id = 1\n// module chunks = 0","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_global.js\n// module id = 2\n// module chunks = 0","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-object.js\n// module id = 3\n// module chunks = 0","import titlelize from './helpers/titlelize'\n\nconst button = (h, ctx, clickAction) => {\n  return (\n    <button\n      class='mobiledoc-button'\n      id={ `mobiledoc-${ctx.type}-button` }\n      onClick={ clickAction }>\n      { ctx.label }\n      { ctx.$slots.default }\n    </button>\n  )\n}\n\nexport default {\n  props: {\n    // all buttons\n    type: { type: String, required: true },\n    label: { type: String },\n    // markup or section buttons\n    tag: { type: String },\n    // link buttons\n    prompt: { type: Object },\n    // atom or card buttons\n    name: { type: String },\n    text: { type: String, default: () => '' },\n    payload: { type: Object, default: () => {} },\n    // card buttons\n    editMode: { type: Boolean, default: () => true }\n  },\n\n  inject: ['editorVm'],\n\n  render (h) {\n    const editorVm = this.editorVm\n    const type = titlelize(this.type)\n    if (type === 'Markup') {\n      if (!this.tag) throw new Error(`Markup buttons require a 'tag' prop`)\n      return button(h, this, () => editorVm.toggleMarkup(this.tag))\n    } else if (type === 'Section') {\n      if (!this.tag) throw new Error(`Section buttons require a 'tag' prop`)\n      return button(h, this, () => editorVm.toggleSection(this.tag))\n    } else if (type === 'Link') {\n      return button(h, this, () => editorVm.toggleLink())\n    } else if (type === 'Atom') {\n      if (!this.name) throw new Error(`Atom buttons require a 'name' prop`)\n      const { name, text, payload } = this\n      return button(h, this, () => editorVm.addAtom(name, text, payload))\n    } else if (type === 'Card') {\n      if (!this.name) throw new Error(`Card buttons require a 'name' prop`)\n      const { name, payload, editMode } = this\n      return button(h, this, () => editorVm.addCard(name, payload, editMode))\n    } else throw new Error(`The button ${type} does not exist`)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/MobiledocButton.js","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_core.js\n// module id = 5\n// module chunks = 0","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_defined.js\n// module id = 6\n// module chunks = 0","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iobject.js\n// module id = 7\n// module chunks = 0","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-integer.js\n// module id = 8\n// module chunks = 0","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-iobject.js\n// module id = 9\n// module chunks = 0","import MobiledocButton from '../MobiledocButton'\n\nexport default {\n  functional: true,\n\n  render (h) {\n    return (\n      <div id='mobiledoc-toolbar'>\n        <MobiledocButton type='markup' tag='strong'> B </MobiledocButton>\n        <MobiledocButton type='markup' tag='em'> I </MobiledocButton>\n        <MobiledocButton type='link'> Link </MobiledocButton>\n        <MobiledocButton type='section' tag='h1'> H1 </MobiledocButton>\n        <MobiledocButton type='section' tag='h2'> H2 </MobiledocButton>\n        <MobiledocButton type='section' tag='ul'> UL </MobiledocButton>\n        <MobiledocButton type='section' tag='ol'> OL </MobiledocButton>\n        <MobiledocButton type='section' tag='blockquote'> Blockquote </MobiledocButton>\n        <MobiledocButton type='section' tag='pull-quote'> Pullquote </MobiledocButton>\n        <slot />\n      </div>\n    )\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/addons/MobiledocToolbar.js","import Vue from 'vue'\n\nfunction renderCard (comp, isEditing = false) {\n  const CompCard = Vue.extend(comp)\n\n  return function createCard ({ env, options, payload }) {\n    const targetNode = document.createElement('div')\n\n    let cardVm\n    env.didRender(() => {\n      payload = { ...payload } // copy payload\n\n      const propsData = { env, payload, options, isEditing }\n\n      cardVm = new CompCard({ propsData }).$mount()\n      targetNode.appendChild(cardVm.$el)\n    })\n\n    env.onTeardown(() => {\n      // target node is auto destroyed; we only need to clean up comp instance\n      cardVm.$destroy()\n    })\n\n    return targetNode\n  }\n}\n\nexport default function compToCard (component, name) {\n  if (!name && typeof component.name === 'undefined') {\n    throw new Error(\"Can't create card, no name defined: \" + component)\n  }\n\n  return {\n    name: name || component.name,\n    type: 'dom',\n    component,\n    render: renderCard(component),\n    edit: renderCard(component, true)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/addons/compToCard.js","export const EMPTY_MOBILEDOC = {\n  version: '0.3.0',\n  markups: [],\n  atoms: [],\n  cards: [],\n  sections: []\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/mobiledocFormats.js","var Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./MobiledocEditor.vue\"),\n  /* template */\n  require(\"!!../node_modules/vue-loader/lib/template-compiler?id=data-v-44c34a7c!../node_modules/vue-loader/lib/selector?type=template&index=0!./MobiledocEditor.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/MobiledocEditor.vue\n// module id = 13\n// module chunks = 0","export function capitalize (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nexport function camelize (str) {\n  return str.replace(/\\W+(.)/g, function (match, chr) {\n    return chr.toUpperCase()\n  })\n}\n\nexport default function (str) {\n  return capitalize(camelize(str))\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/titlelize.js","<template>\n  <div id=\"mobiledoc-editor_container\">\n    <slot name=\"header\" />\n    <slot></slot>\n    <div id=\"mobiledoc-editor_editor\" ref=\"editorPost\" />\n    <slot name=\"footer\" />\n  </div>\n</template>\n\n<script>\nimport { Editor, UI } from 'mobiledoc-kit'\n\nexport default {\n  provide () {\n    return {\n      editorVm: this.editorVm\n    }\n  },\n\n  props: {\n    mobiledoc: { type: Object, default: () => {} },\n    atoms: { type: Array, default: () => [] },\n    cards: { type: Array, default: () => [] },\n    placeholder: { type: String, default: () => '' },\n    autofocus: { type: Boolean, default: () => true },\n    spellCheck: { type: Boolean, default: () => true },\n    serializeVersion: { type: String, default: () => '0.3.0' },\n    cardOptions: { type: Object, default: () => {} },\n    enableEditing: { type: Boolean, default: () => true }\n  },\n\n  data () {\n    return {\n      editor: {},\n      activeMarkupTags: [],\n      activeSectionTags: [],\n      canEdit: this.enableEditing\n    }\n  },\n\n  computed: {\n    editorOptions () {\n      return {\n        autofocus: this.autofocus,\n        spellcheck: this.spellcheck,\n        placeholder: this.placeholder,\n        serializeVersion: this.serializeVersion,\n        mobiledoc: this.mobiledoc,\n        atoms: this.atoms,\n        cards: this.cards,\n        cardOptions: this.cardOptions\n      }\n    },\n\n    editorVm () {\n      return {\n        editor: () => this.editor,\n        canEdit: () => this.canEdit,\n        activeMarkupTags: this.activeMarkupTags,\n        activeSectionTags: this.activeSectionTags,\n        toggleMarkup: this.toggleMarkup,\n        toggleSection: this.toggleSection,\n        toggleLink: this.toggleLink,\n        toggleEditMode: this.toggleEditMode,\n        addAtom: this.addAtom,\n        addCard: this.addCard\n      }\n    },\n\n    isEditable () {\n      const { editor } = this\n      return editor ? editor.isEditable : this.enableEditing\n    }\n  },\n\n  watch: {\n    isEditable () {\n      this.canEdit = this.isEditable\n    }\n  },\n\n  beforeMount () {\n    this._initEditorWithEventEmitters()\n  },\n\n  mounted () {\n    // make sure the editor's post is only rendered once\n    this.$once('mounted', () => this._renderEditorPost())\n    this.$emit('mounted')\n  },\n\n  methods: {\n    toggleMarkup (tag) {\n      this.editor.toggleMarkup(tag)\n    },\n\n    toggleSection (tag) {\n      this.editor.toggleSection(tag)\n    },\n\n    toggleLink (tag = 'a') {\n      if (!this.editor.hasCursor()) return\n      // no cursor selected\n      else if (this.editor.hasActiveMarkup(tag)) this.editor.toggleMarkup(tag)\n      // deselect\n      else UI.toggleLink(this.editor)\n    },\n\n    addAtom (name, text = '', payload = {}) {\n      this.editor.insertAtom(name, text, payload)\n    },\n\n    addCard (name, payload = {}, editMode = false) {\n      this.editor.insertCard(name, payload, editMode)\n    },\n\n    toggleEditMode () {\n      this.isEditable ? this.editor.disableEditing() : this.editor.enableEditing()\n    },\n\n    _initEditorWithEventEmitters () {\n      this.$emit('willCreateEditor')\n\n      this.editor = new Editor(this.editorOptions)\n\n      if (this.enableEditing === false) this.toggleEditMode()\n\n      this.$emit('didCreateEditor', this.editor)\n\n      this.editor.inputModeDidChange(() => {\n        this._updateActiveMarkupTags()\n        this._updateActiveSectionTags()\n      })\n\n      this.editor.postDidChange(() => {\n        // serialize the editor's post to the mobiledoc version format\n        // any cards or atoms present in doc, will be ommited\n        const mobiledoc = this.editor.serialize(this.serializeVersion)\n        this.$emit('postWasUpdated', mobiledoc)\n      })\n    },\n\n    _renderEditorPost () {\n      this.editor.render(this.$refs.editorPost)\n    },\n\n    _updateActiveMarkupTags () {\n      this.activeMarkupTags = this.editor.activeMarkups.map((m) => m.tagName)\n    },\n\n    _updateActiveSectionTags () {\n      // editor.activeSections are leaf sections.\n      // map parent section tag names (e.g. 'p', 'ul') so that\n      // list buttons are updated\n      this.activeSectionTags = this.editor.activeSections.map((s) => {\n        return s.isNested ? s.parent.tagName : s.tagName\n      })\n    }\n  },\n\n  beforeDestroy () {\n    this.editor.destroy()\n  }\n}\n</script>\n\n<!-- <style src=\"mobiledoc-kit/dist/css/mobiledoc-kit.css\"></style> -->\n\n\n\n// WEBPACK FOOTER //\n// MobiledocEditor.vue?1aa4354f","module.exports = { \"default\": require(\"core-js/library/fn/object/assign\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/assign.js\n// module id = 16\n// module chunks = 0","\"use strict\";\n\nexports.__esModule = true;\n\nvar _assign = require(\"../core-js/object/assign\");\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _assign2.default || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/extends.js\n// module id = 17\n// module chunks = 0","require('../../modules/es6.object.assign');\nmodule.exports = require('../../modules/_core').Object.assign;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/assign.js\n// module id = 18\n// module chunks = 0","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_a-function.js\n// module id = 19\n// module chunks = 0","var isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_an-object.js\n// module id = 20\n// module chunks = 0","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_array-includes.js\n// module id = 21\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_cof.js\n// module id = 22\n// module chunks = 0","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ctx.js\n// module id = 23\n// module chunks = 0","var isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_dom-create.js\n// module id = 24\n// module chunks = 0","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_enum-bug-keys.js\n// module id = 25\n// module chunks = 0","var global    = require('./_global')\n  , core      = require('./_core')\n  , ctx       = require('./_ctx')\n  , hide      = require('./_hide')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_export.js\n// module id = 26\n// module chunks = 0","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_has.js\n// module id = 27\n// module chunks = 0","var dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_hide.js\n// module id = 28\n// module chunks = 0","module.exports = !require('./_descriptors') && !require('./_fails')(function(){\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ie8-dom-define.js\n// module id = 29\n// module chunks = 0","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys  = require('./_object-keys')\n  , gOPS     = require('./_object-gops')\n  , pIE      = require('./_object-pie')\n  , toObject = require('./_to-object')\n  , IObject  = require('./_iobject')\n  , $assign  = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function(){\n  var A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = toObject(target)\n    , aLen  = arguments.length\n    , index = 1\n    , getSymbols = gOPS.f\n    , isEnum     = pIE.f;\n  while(aLen > index){\n    var S      = IObject(arguments[index++])\n      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  } return T;\n} : $assign;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-assign.js\n// module id = 30\n// module chunks = 0","var anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-dp.js\n// module id = 31\n// module chunks = 0","exports.f = Object.getOwnPropertySymbols;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gops.js\n// module id = 32\n// module chunks = 0","var has          = require('./_has')\n  , toIObject    = require('./_to-iobject')\n  , arrayIndexOf = require('./_array-includes')(false)\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys-internal.js\n// module id = 33\n// module chunks = 0","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = require('./_object-keys-internal')\n  , enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys.js\n// module id = 34\n// module chunks = 0","exports.f = {}.propertyIsEnumerable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-pie.js\n// module id = 35\n// module chunks = 0","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_property-desc.js\n// module id = 36\n// module chunks = 0","var shared = require('./_shared')('keys')\n  , uid    = require('./_uid');\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared-key.js\n// module id = 37\n// module chunks = 0","var global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared.js\n// module id = 38\n// module chunks = 0","var toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-index.js\n// module id = 39\n// module chunks = 0","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-length.js\n// module id = 40\n// module chunks = 0","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-object.js\n// module id = 41\n// module chunks = 0","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-primitive.js\n// module id = 42\n// module chunks = 0","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_uid.js\n// module id = 43\n// module chunks = 0","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.assign.js\n// module id = 44\n// module chunks = 0","function detect(enumerable, callback) {\n  if (enumerable.detect) {\n    return enumerable.detect(callback);\n  } else {\n    for (let i=0; i<enumerable.length; i++) {\n      if (callback(enumerable[i])) {\n        return enumerable[i];\n      }\n    }\n  }\n}\n\nfunction any(enumerable, callback) {\n  if (enumerable.any) { return enumerable.any(callback); }\n\n  for (let i=0; i<enumerable.length; i++) {\n    if (callback(enumerable[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Useful for array-like things that aren't\n * actually arrays, like NodeList\n * @private\n */\nfunction forEach(enumerable, callback) {\n  if (enumerable.forEach) {\n    enumerable.forEach(callback);\n  } else {\n    for (let i=0; i<enumerable.length; i++) {\n      callback(enumerable[i], i);\n    }\n  }\n}\n\nfunction filter(enumerable, conditionFn) {\n  const filtered = [];\n  forEach(enumerable, i => {\n    if (conditionFn(i)) { filtered.push(i); }\n  });\n  return filtered;\n}\n\n/**\n * @return {Integer} the number of items that are the same, starting from the 0th index, in a and b\n * @private\n */\nfunction commonItemLength(listA, listB) {\n  let offset = 0;\n  while (offset < listA.length && offset < listB.length) {\n    if (listA[offset] !== listB[offset]) {\n      break;\n    }\n    offset++;\n  }\n  return offset;\n}\n\n/**\n * @return {Array} the items that are the same, starting from the 0th index, in a and b\n * @private\n */\nfunction commonItems(listA, listB) {\n  let offset = 0;\n  while (offset < listA.length && offset < listB.length) {\n    if (listA[offset] !== listB[offset]) {\n      break;\n    }\n    offset++;\n  }\n  return listA.slice(0, offset);\n}\n\nfunction reduce(enumerable, callback, initialValue) {\n  let previousValue = initialValue;\n  forEach(enumerable, (val, index) => {\n    previousValue = callback(previousValue, val, index);\n  });\n  return previousValue;\n}\n\n/**\n * @param {Array} array of key1,value1,key2,value2,...\n * @return {Object} {key1:value1, key2:value2, ...}\n * @private\n */\nfunction kvArrayToObject(array) {\n  const obj = {};\n  for (let i = 0; i < array.length; i+=2) {\n    let [key, value] = [array[i], array[i+1]];\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction objectToSortedKVArray(obj) {\n  const keys = Object.keys(obj).sort();\n  const result = [];\n  keys.forEach(k => {\n    result.push(k);\n    result.push(obj[k]);\n  });\n  return result;\n}\n\n// check shallow equality of two non-nested arrays\nfunction isArrayEqual(arr1, arr2) {\n  let l1 = arr1.length, l2 = arr2.length;\n  if (l1 !== l2) { return false; }\n\n  for (let i=0; i < l1; i++) {\n    if (arr1[i] !== arr2[i]) { return false; }\n  }\n  return true;\n}\n\n// return an object with only the valid keys\nfunction filterObject(object, validKeys=[]) {\n  let result = {};\n  forEach(\n    filter(Object.keys(object), key => validKeys.indexOf(key) !== -1),\n      key => result[key] = object[key]\n  );\n  return result;\n}\n\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1;\n}\n\nfunction values(object) {\n  return Object.keys(object).map(key => object[key]);\n}\n\nconst NODE_TYPES = {\n  ELEMENT: 1,\n  TEXT: 3,\n  COMMENT: 8\n};\n\nfunction isTextNode(node) {\n  return node.nodeType === NODE_TYPES.TEXT;\n}\n\nfunction isCommentNode(node) {\n  return node.nodeType === NODE_TYPES.COMMENT;\n}\n\nfunction isElementNode(node) {\n  return node.nodeType === NODE_TYPES.ELEMENT;\n}\n\n\nfunction clearChildNodes(element) {\n  while (element.childNodes.length) {\n    element.removeChild(element.childNodes[0]);\n  }\n}\n\n/**\n * @return {Boolean} true when the child node is contained or the same as\n * (e.g., inclusive containment)  the parent node\n *  see https://github.com/webmodules/node-contains/blob/master/index.js\n *  Mimics the behavior of `Node.contains`, which is broken in IE 10\n *  @private\n */\nfunction containsNode(parentNode, childNode) {\n  if (parentNode === childNode) {\n    return true;\n  }\n  const position = parentNode.compareDocumentPosition(childNode);\n  return !!(position & Node.DOCUMENT_POSITION_CONTAINED_BY);\n}\n\n/**\n * converts the element's NamedNodeMap of attrs into\n * an object with key-value pairs\n * @param {DOMNode} element\n * @return {Object} key-value pairs\n * @private\n */\nfunction getAttributes(element) {\n  const result = {};\n  if (element.hasAttributes()) {\n    forEach(element.attributes, ({name,value}) => {\n      result[name] = value;\n    });\n  }\n  return result;\n}\n\nfunction addClassName(element, className) {\n  element.classList.add(className);\n}\n\nfunction removeClassName(element, className) {\n  element.classList.remove(className);\n}\n\nfunction normalizeTagName(tagName) {\n  return tagName.toLowerCase();\n}\n\nfunction parseHTML(html) {\n  const div = document.createElement('div');\n  div.innerHTML = html;\n  return div;\n}\n\nfunction serializeHTML(node) {\n  const div = document.createElement('div');\n  div.appendChild(node);\n  return div.innerHTML;\n}\n\nclass View {\n  constructor(options={}) {\n    options.tagName   = options.tagName   || 'div';\n    options.container = options.container || document.body;\n\n    this.element = document.createElement(options.tagName);\n    this.container = options.container;\n    this.isShowing = false;\n\n    let classNames = options.classNames || [];\n    classNames.forEach(name => addClassName(this.element, name));\n    this._eventListeners = [];\n  }\n\n  addEventListener(element, type, listener) {\n    element.addEventListener(type, listener);\n    this._eventListeners.push([element, type, listener]);\n  }\n\n  removeAllEventListeners() {\n    this._eventListeners.forEach(([element, type, listener]) => {\n      element.removeEventListener(type, listener);\n    });\n  }\n\n  show() {\n    if(!this.isShowing) {\n      this.container.appendChild(this.element);\n      this.isShowing = true;\n      return true;\n    }\n  }\n\n  hide() {\n    if (this.isShowing) {\n      this.container.removeChild(this.element);\n      this.isShowing = false;\n      return true;\n    }\n  }\n\n  destroy() {\n    this.removeAllEventListeners();\n    this.hide();\n    this.isDestroyed = true;\n  }\n}\n\n/*\n * @param {String} string\n * @return {String} a dasherized string. 'modelIndex' -> 'model-index', etc\n */\nfunction dasherize(string) {\n  return string.replace(/[A-Z]/g, (match, offset) => {\n    const lower = match.toLowerCase();\n\n    return (offset === 0 ? lower : '-' + lower);\n  });\n}\n\nfunction startsWith(string, character) {\n  return string.charAt(0) === character;\n}\n\nfunction endsWith(string, endString) {\n  let index = string.lastIndexOf(endString);\n  return index !== -1 && index === string.length - endString.length;\n}\n\nfunction getEventTargetMatchingTag(tagName, target, container) {\n  tagName = normalizeTagName(tagName);\n  // Traverses up DOM from an event target to find the node matching specifed tag\n  while (target && target !== container) {\n    if (normalizeTagName(target.tagName) === tagName) {\n      return target;\n    }\n    target = target.parentNode;\n  }\n}\n\nfunction getElementRelativeOffset(element) {\n  var offset = { left: 0, top: -window.pageYOffset };\n  var offsetParent = element.offsetParent;\n  var offsetParentPosition = window.getComputedStyle(offsetParent).position;\n  var offsetParentRect;\n\n  if (offsetParentPosition === 'relative') {\n    offsetParentRect = offsetParent.getBoundingClientRect();\n    offset.left = offsetParentRect.left;\n    offset.top  = offsetParentRect.top;\n  }\n  return offset;\n}\n\nfunction getElementComputedStyleNumericProp(element, prop) {\n  return parseFloat(window.getComputedStyle(element)[prop]);\n}\n\nfunction positionElementToRect(element, rect, topOffset, leftOffset) {\n  var relativeOffset = getElementRelativeOffset(element);\n  var style = element.style;\n  var round = Math.round;\n  var left, top;\n\n  topOffset = topOffset || 0;\n  leftOffset = leftOffset || 0;\n  left = round(rect.left - relativeOffset.left - leftOffset);\n  top  = round(rect.top  + rect.height - relativeOffset.top  - topOffset);\n  style.left = left + 'px';\n  style.top  = top + 'px';\n  return { left: left, top: top };\n}\n\nfunction positionElementHorizontallyCenteredToRect(element, rect, topOffset) {\n  var horizontalCenter = (element.offsetWidth / 2) - (rect.width / 2);\n  return positionElementToRect(element, rect, topOffset, horizontalCenter);\n}\n\nfunction positionElementCenteredBelow(element, belowElement) {\n  var elementMargin = getElementComputedStyleNumericProp(element, 'marginTop');\n  return positionElementHorizontallyCenteredToRect(element, belowElement.getBoundingClientRect(), -elementMargin);\n}\n\nfunction setData(element, name, value) {\n  if (element.dataset) {\n    element.dataset[name] = value;\n  } else {\n    const dataName = dasherize(name);\n    return element.setAttribute(dataName, value);\n  }\n}\n\nfunction whenElementIsNotInDOM(element, callback) {\n  let isCanceled = false;\n  const observerFn = () => {\n    if (isCanceled) { return; }\n    if (!element.parentNode) {\n      callback();\n    } else {\n      window.requestAnimationFrame(observerFn);\n    }\n  };\n  observerFn();\n  return { cancel: () => isCanceled = true };\n}\n\nvar errorProps = [\n  'description',\n  'fileName',\n  'lineNumber',\n  'message',\n  'name',\n  'number',\n  'stack'\n];\n\nfunction MobiledocError() {\n  let tmp = Error.apply(this, arguments);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  }\n  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.\n  for (let idx = 0; idx < errorProps.length; idx++) {\n    this[errorProps[idx]] = tmp[errorProps[idx]];\n  }\n}\n\nMobiledocError.prototype = Object.create(Error.prototype);\n\nfunction assert(message, conditional) {\n  if (!conditional) {\n    throw new MobiledocError(message);\n  }\n}\n\nconst MARKUP_SECTION_TYPE = 'markup-section';\nconst LIST_SECTION_TYPE = 'list-section';\nconst MARKUP_TYPE = 'markup';\nconst MARKER_TYPE = 'marker';\nconst POST_TYPE = 'post';\nconst LIST_ITEM_TYPE = 'list-item';\nconst CARD_TYPE = 'card-section';\nconst IMAGE_SECTION_TYPE = 'image-section';\nconst ATOM_TYPE = 'atom';\n\nconst CONSTRUCTOR_FN_NAME = 'constructor';\n\nfunction mixin(target, source) {\n  target = target.prototype;\n  // Fallback to just `source` to allow mixing in a plain object (pojo)\n  source = source.prototype || source;\n\n  Object.getOwnPropertyNames(source).forEach((name) => {\n    if (name !== CONSTRUCTOR_FN_NAME) {\n      const descriptor = Object.getOwnPropertyDescriptor(source, name);\n\n      Object.defineProperty(target, name, descriptor);\n    }\n  });\n}\n\nclass Markerupable {\n\n  clearMarkups() {\n    this.markups = [];\n  }\n\n  addMarkup(markup) {\n    this.markups.push(markup);\n  }\n\n  addMarkupAtIndex(markup, index) {\n    this.markups.splice(index, 0, markup);\n  }\n\n  removeMarkup(markupOrMarkupCallback) {\n    let callback;\n    if (typeof markupOrMarkupCallback === 'function') {\n      callback = markupOrMarkupCallback;\n    } else {\n      let markup = markupOrMarkupCallback;\n      callback = (_markup) => _markup === markup;\n    }\n\n    forEach(\n      filter(this.markups, callback),\n      m => this._removeMarkup(m)\n    );\n  }\n\n  _removeMarkup(markup) {\n    const index = this.markups.indexOf(markup);\n    if (index !== -1) {\n      this.markups.splice(index, 1);\n    }\n  }\n\n  hasMarkup(tagNameOrMarkup) {\n    return !!this.getMarkup(tagNameOrMarkup);\n  }\n\n  getMarkup(tagNameOrMarkup) {\n    if (typeof tagNameOrMarkup === 'string') {\n      let tagName = normalizeTagName(tagNameOrMarkup);\n      return detect(this.markups, markup => markup.tagName === tagName);\n    } else {\n      let targetMarkup = tagNameOrMarkup;\n      return detect(this.markups, markup => markup === targetMarkup);\n    }\n  }\n\n  get openedMarkups() {\n    let count = 0;\n    if (this.prev) {\n      count = commonItemLength(this.markups, this.prev.markups);\n    }\n\n    return this.markups.slice(count);\n  }\n\n  get closedMarkups() {\n    let count = 0;\n    if (this.next) {\n      count = commonItemLength(this.markups, this.next.markups);\n    }\n\n    return this.markups.slice(count);\n  }\n}\n\nclass LinkedItem {\n  constructor() {\n    this.next = null;\n    this.prev = null;\n  }\n}\n\n// Unicode uses a pair of \"surrogate\" characters\" (a high- and low-surrogate)\n// to encode characters outside the basic multilingual plane (like emoji and\n// some languages).\n// These values are the unicode code points for the start and end of the\n// high- and low-surrogate characters.\n// See \"high surrogate\" and \"low surrogate\" on\n// https://en.wikipedia.org/wiki/Unicode_block\nconst HIGH_SURROGATE_RANGE = [0xD800, 0xDBFF];\nconst LOW_SURROGATE_RANGE  = [0xDC00, 0xDFFF];\n\nconst Marker = class Marker extends LinkedItem {\n  constructor(value='', markups=[]) {\n    super();\n    this.value = value;\n    assert('Marker must have value', value !== undefined && value !== null);\n    this.markups = [];\n    this.type = MARKER_TYPE;\n    this.isMarker = true;\n    this.isAtom = false;\n    markups.forEach(m => this.addMarkup(m));\n  }\n\n  clone() {\n    const clonedMarkups = this.markups.slice();\n    return this.builder.createMarker(this.value, clonedMarkups);\n  }\n\n  get isEmpty() {\n    return this.isBlank;\n  }\n\n  get isBlank() {\n    return this.length === 0;\n  }\n\n  charAt(offset) {\n    return this.value.slice(offset, offset+1);\n  }\n\n  /**\n   * A marker's text is equal to its value.\n   * Compare with an Atom which distinguishes between text and value\n   */\n  get text() {\n    return this.value;\n  }\n\n  get length() {\n    return this.value.length;\n  }\n\n  // delete the character at this offset,\n  // update the value with the new value\n  deleteValueAtOffset(offset) {\n    assert('Cannot delete value at offset outside bounds',\n           offset >= 0 && offset <= this.length);\n\n    let width = 1;\n    let code = this.value.charCodeAt(offset);\n    if (code >= HIGH_SURROGATE_RANGE[0] && code <= HIGH_SURROGATE_RANGE[1]) {\n      width = 2;\n    } else if (code >= LOW_SURROGATE_RANGE[0] && code <= LOW_SURROGATE_RANGE[1]) {\n      width = 2;\n      offset = offset - 1;\n    }\n\n    const [ left, right ] = [\n      this.value.slice(0, offset),\n      this.value.slice(offset+width)\n    ];\n    this.value = left + right;\n\n    return width;\n  }\n\n  canJoin(other) {\n    return other && other.isMarker && isArrayEqual(this.markups, other.markups);\n  }\n\n  textUntil(offset) {\n    return this.value.slice(0, offset);\n  }\n\n  split(offset=0, endOffset=this.length) {\n    let markers = [\n      this.builder.createMarker(this.value.substring(0, offset)),\n      this.builder.createMarker(this.value.substring(offset, endOffset)),\n      this.builder.createMarker(this.value.substring(endOffset))\n    ];\n\n    this.markups.forEach(mu => markers.forEach(m => m.addMarkup(mu)));\n    return markers;\n  }\n\n  /**\n   * @return {Array} 2 markers either or both of which could be blank\n   */\n  splitAtOffset(offset) {\n    assert('Cannot split a marker at an offset > its length',\n           offset <= this.length);\n    let { value, builder } = this;\n\n    let pre  = builder.createMarker(value.substring(0, offset));\n    let post = builder.createMarker(value.substring(offset));\n\n    this.markups.forEach(markup => {\n      pre.addMarkup(markup);\n      post.addMarkup(markup);\n    });\n\n    return [pre, post];\n  }\n\n};\n\nmixin(Marker, Markerupable);\n\nvar Keycodes = {\n  BACKSPACE:    8,\n  SPACE:       32,\n  ENTER:       13,\n  SHIFT:       16,\n  ESC:         27,\n  DELETE:      46,\n  '0':         48,\n  '9':         57,\n  A:           65,\n  Z:           90,\n  a:           97,\n  z:          122,\n  'NUMPAD_0': 186,\n  'NUMPAD_9': 111,\n  ';':        186,\n  '.':        190,\n  '`':        192,\n  '[':        219,\n  '\"':        222,\n\n  // Input Method Editor uses multiple keystrokes to display characters.\n  // Example on mac: press option-i then i. This fires 2 key events in Chrome\n  // with keyCode 229 and displays ˆ and then î.\n  // See http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html#fixed-virtual-key-codes\n  IME:        229,\n\n  TAB:          9,\n  CLEAR:       12,\n  PAUSE:       19,\n  PAGEUP:      33,\n  PAGEDOWN:    34,\n  END:         35,\n  HOME:        36,\n  LEFT:        37,\n  UP:          38,\n  RIGHT:       39,\n  DOWN:        40,\n  INS:         45,\n  META:        91,\n  ALT:         18,\n  CTRL:        17\n};\n\nvar Keys = {\n  BACKSPACE:  'Backspace',\n  SPACE:      ' ',\n  ENTER:      'Enter',\n  SHIFT:      'Shift',\n  ESC:        'Escape',\n  DELETE:     'Delete',\n  INS:        'Insert',\n  HOME:       'Home',\n  END:        'End',\n  PAGEUP:     'PageUp',\n  PAGEDOWN:   'PageDown',\n  CLEAR:      'Clear',\n  PAUSE:      'Pause',\n  TAB:        'Tab',\n  ALT:        'Alt',\n  CTRL:       'Control',\n\n  LEFT:       'ArrowLeft',\n  RIGHT:      'ArrowRight',\n  UP:         'ArrowUp',\n  DOWN:       'ArrowDown'\n};\n\nconst TAB = '\\t';\nconst ENTER = '\\n';\n\n/**\n * @typedef Direction\n * @enum {number}\n * @property {number} FORWARD\n * @property {number} BACKWARD\n */\nconst DIRECTION = {\n  FORWARD: 1,\n  BACKWARD: -1\n};\n\nconst MODIFIERS = {\n  META: 1, // also called \"command\" on OS X\n  CTRL: 2,\n  SHIFT: 4,\n  ALT: 8   // also called \"option\" on OS X\n};\n\nfunction modifierMask(event) {\n  let {\n    metaKey, shiftKey, ctrlKey, altKey\n  } = event;\n  let modVal = (val, modifier) => {\n    return (val && modifier) || 0;\n  };\n  return modVal(metaKey,  MODIFIERS.META) +\n         modVal(shiftKey, MODIFIERS.SHIFT) +\n         modVal(ctrlKey,  MODIFIERS.CTRL) +\n         modVal(altKey,   MODIFIERS.ALT);\n}\n\nconst SPECIAL_KEYS = {\n  BACKSPACE: Keycodes.BACKSPACE,\n  TAB:       Keycodes.TAB,\n  ENTER:     Keycodes.ENTER,\n  ESC:       Keycodes.ESC,\n  SPACE:     Keycodes.SPACE,\n  PAGEUP:    Keycodes.PAGEUP,\n  PAGEDOWN:  Keycodes.PAGEDOWN,\n  END:       Keycodes.END,\n  HOME:      Keycodes.HOME,\n  LEFT:      Keycodes.LEFT,\n  UP:        Keycodes.UP,\n  RIGHT:     Keycodes.RIGHT,\n  DOWN:      Keycodes.DOWN,\n  INS:       Keycodes.INS,\n  DEL:       Keycodes.DELETE\n};\n\nfunction specialCharacterToCode(specialCharacter) {\n  return SPECIAL_KEYS[specialCharacter];\n}\n\n// heuristic for determining if `event` is a key event\nfunction isKeyEvent(event) {\n  return /^key/.test(event.type);\n}\n\n/**\n * An abstraction around a KeyEvent\n * that key listeners in the editor can use\n * to determine what sort of key was pressed\n */\nconst Key = class Key {\n  constructor(event) {\n    this.key = event.key;\n    this.keyCode = event.keyCode;\n    this.charCode = event.charCode;\n    this.event = event;\n    this.modifierMask = modifierMask(event);\n  }\n\n  static fromEvent(event) {\n    assert('Must pass a Key event to Key.fromEvent',\n           event && isKeyEvent(event));\n    return new Key(event);\n  }\n\n  toString() {\n    if (this.isTab()) { return TAB; }\n    return String.fromCharCode(this.charCode);\n  }\n\n  // See https://caniuse.com/#feat=keyboardevent-key for browser support.\n  isKeySupported() {\n    return this.key;\n  }\n\n  isKey(identifier) {\n    if (this.isKeySupported()) {\n      assert(`Must define Keys.${identifier}.`, Keys[identifier]);\n      return this.key === Keys[identifier];\n    } else {\n      assert(`Must define Keycodes.${identifier}.`, Keycodes[identifier]);\n      return this.keyCode === Keycodes[identifier];\n    }\n  }\n\n  isEscape() {\n    return this.isKey('ESC');\n  }\n\n  isDelete() {\n    return this.isKey('BACKSPACE') || this.isForwardDelete();\n  }\n\n  isForwardDelete() {\n    return this.isKey('DELETE');\n  }\n\n  isArrow() {\n    return this.isHorizontalArrow() || this.isVerticalArrow();\n  }\n\n  isHorizontalArrow() {\n    return this.isLeftArrow() || this.isRightArrow();\n  }\n\n  isHorizontalArrowWithoutModifiersOtherThanShift() {\n    return this.isHorizontalArrow() &&\n      !(this.ctrlKey || this.metaKey || this.altKey);\n  }\n\n  isVerticalArrow() {\n    return this.isKey('UP') || this.isKey('DOWN');\n  }\n\n  isLeftArrow() {\n    return this.isKey('LEFT');\n  }\n\n  isRightArrow() {\n    return this.isKey('RIGHT');\n  }\n\n  isHome() {\n    return this.isKey('HOME');\n  }\n\n  isEnd() {\n    return this.isKey('END');\n  }\n\n  isPageUp() {\n    return this.isKey('PAGEUP');\n  }\n\n  isPageDown() {\n    return this.isKey('PAGEDOWN');\n  }\n\n  isInsert() {\n    return this.isKey('INS');\n  }\n\n  isClear() {\n    return this.isKey('CLEAR');\n  }\n\n  isPause() {\n    return this.isKey('PAUSE');\n  }\n\n  isSpace() {\n    return this.isKey('SPACE');\n  }\n\n  // In Firefox, pressing ctrl-TAB will switch to another open browser tab, but\n  // it will also fire a keydown event for the tab+modifier (ctrl). This causes\n  // Mobiledoc to erroneously insert a tab character before FF switches to the\n  // new browser tab.  Chrome doesn't fire this event so the issue doesn't\n  // arise there. Fix this by returning false when the TAB key event includes a\n  // modifier.\n  // See: https://github.com/bustle/mobiledoc-kit/issues/565\n  isTab() {\n    return !this.hasAnyModifier() && this.isKey('TAB');\n  }\n\n  isEnter() {\n    return this.isKey('ENTER');\n  }\n\n  /*\n   * If the key is the actual shift key. This is false when the shift key\n   * is held down and the source `event` is not the shift key.\n   * @see {isShift}\n   * @return {bool}\n   */\n  isShiftKey() {\n    return this.isKey('SHIFT');\n  }\n\n  /*\n   * If the key is the actual alt key (aka \"option\" on mac). This is false when the alt key\n   * is held down and the source `event` is not the alt key.\n   * @return {bool}\n   */\n  isAltKey() {\n    return this.isKey('ALT');\n  }\n\n  /*\n   * If the key is the actual ctrl key. This is false when the ctrl key\n   * is held down and the source `event` is not the ctrl key.\n   * @return {bool}\n   */\n  isCtrlKey() {\n    return this.isKey('CTRL');\n  }\n\n  isIME() {\n    // FIXME the IME action seems to get lost when we issue an\n    // `editor.deleteSelection` before it (in Chrome)\n    return this.keyCode === Keycodes.IME;\n  }\n\n  get direction() {\n    switch (true) {\n      case this.isDelete():\n        return this.isForwardDelete() ? DIRECTION.FORWARD : DIRECTION.BACKWARD;\n      case this.isHorizontalArrow():\n        return this.isRightArrow() ? DIRECTION.FORWARD : DIRECTION.BACKWARD;\n    }\n  }\n\n  /**\n   * If the shift key is depressed.\n   * For example, while holding down meta+shift, pressing the \"v\"\n   * key would result in an event whose `Key` had `isShift()` with a truthy value,\n   * because the shift key is down when pressing the \"v\".\n   * @see {isShiftKey} which checks if the key is actually the shift key itself.\n   * @return {bool}\n   */\n  isShift() {\n    return this.shiftKey;\n  }\n\n  hasModifier(modifier) {\n    return modifier & this.modifierMask;\n  }\n\n  hasAnyModifier() {\n    return !!this.modifierMask;\n  }\n\n  get ctrlKey() {\n    return MODIFIERS.CTRL & this.modifierMask;\n  }\n\n  get metaKey() {\n    return MODIFIERS.META & this.modifierMask;\n  }\n\n  get shiftKey() {\n    return MODIFIERS.SHIFT & this.modifierMask;\n  }\n\n  get altKey() {\n    return MODIFIERS.ALT & this.modifierMask;\n  }\n\n  isPrintableKey() {\n    return !(\n      this.isArrow() ||\n      this.isHome() || this.isEnd() ||\n      this.isPageUp() || this.isPageDown() ||\n      this.isInsert() || this.isClear() || this.isPause() ||\n      this.isEscape()\n    );\n  }\n\n  isNumberKey() {\n    if (this.isKeySupported()) {\n      return this.key >= '0' && this.key <= '9';\n    } else {\n      const code = this.keyCode;\n      return (code >= Keycodes['0'] && code <= Keycodes['9']) ||\n        (code >= Keycodes.NUMPAD_0 && code <= Keycodes.NUMPAD_9); // numpad keys\n    }\n  }\n\n  isLetterKey() {\n    if (this.isKeySupported()) {\n      const key = this.key;\n      return (key >= 'a' && key <= 'z') ||\n        (key >= 'A' && key <= 'Z');\n    } else {\n      const code = this.keyCode;\n      return (code >= Keycodes.A && code <= Keycodes.Z) ||\n        (code >= Keycodes.a && code <= Keycodes.z);\n    }\n  }\n\n  isPunctuation() {\n    if (this.isKeySupported()) {\n      const key = this.key;\n      return (key >= ';' && key <= '`') ||\n        (key >= '[' && key <= '\"');\n    } else {\n      const code = this.keyCode;\n      return (code >= Keycodes[';'] && code <= Keycodes['`']) ||\n      (code >= Keycodes['['] && code <= Keycodes['\"']);\n    }\n  }\n\n  /**\n   * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#Printable_keys_in_standard_position\n   *   and http://stackoverflow.com/a/12467610/137784\n   */\n  isPrintable() {\n    if (this.ctrlKey || this.metaKey) {\n      return false;\n    }\n\n    // Firefox calls keypress events for some keys that should not be printable\n    if (!this.isPrintableKey()) {\n      return false;\n    }\n\n    return (\n      this.keyCode !== 0 ||\n      this.toString().length > 0 ||\n      this.isNumberKey() ||\n      this.isSpace() ||\n      this.isTab()   ||\n      this.isEnter() ||\n      this.isLetterKey() ||\n      this.isPunctuation() ||\n      this.isIME()\n    );\n  }\n};\n\nfunction clearSelection() {\n  window.getSelection().removeAllRanges();\n}\n\nfunction textNodeRects(node) {\n  let range = document.createRange();\n  range.setEnd(node, node.nodeValue.length);\n  range.setStart(node, 0);\n  return range.getClientRects();\n}\n\nfunction findOffsetInTextNode(node, coords) {\n  let len = node.nodeValue.length;\n  let range = document.createRange();\n  for (let i = 0; i < len; i++) {\n    range.setEnd(node, i + 1);\n    range.setStart(node, i);\n    let rect = range.getBoundingClientRect();\n    if (rect.top === rect.bottom) {\n      continue;\n    }\n    if (rect.left <= coords.left && rect.right >= coords.left &&\n        rect.top <= coords.top && rect.bottom >= coords.top) {\n      return {node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)};\n    }\n  }\n  return {node, offset: 0};\n}\n\n/*\n * @param {Object} coords with `top` and `left`\n * @see https://github.com/ProseMirror/prosemirror/blob/4c22e3fe97d87a355a0534e25d65aaf0c0d83e57/src/edit/dompos.js\n * @return {Object} {node, offset}\n */\n/* eslint-disable complexity */\nfunction findOffsetInNode(node, coords) {\n  let closest, dyClosest = 1e8, coordsClosest, offset = 0;\n  for (let child = node.firstChild; child; child = child.nextSibling) {\n    let rects;\n    if (isElementNode(child)) {\n      rects = child.getClientRects();\n    } else if (isTextNode(child)) {\n      rects = textNodeRects(child);\n    } else {\n      continue;\n    }\n\n    for (let i = 0; i < rects.length; i++) {\n      let rect = rects[i];\n      if (rect.left <= coords.left && rect.right >= coords.left) {\n        let dy = rect.top > coords.top ? rect.top - coords.top\n            : rect.bottom < coords.top ? coords.top - rect.bottom : 0;\n        if (dy < dyClosest) {\n          closest = child;\n          dyClosest = dy;\n          coordsClosest = dy ? {left: coords.left, top: rect.top} : coords;\n          if (isElementNode(child) && !child.firstChild) {\n            offset = i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n          }\n          continue;\n        }\n      }\n      if (!closest &&\n          (coords.top >= rect.bottom || coords.top >= rect.top && coords.left >= rect.right)) {\n        offset = i + 1;\n      }\n    }\n  }\n  if (!closest) {\n    return {node, offset};\n  }\n  if (isTextNode(closest)) {\n    return findOffsetInTextNode(closest, coordsClosest);\n  }\n  if (closest.firstChild) {\n    return findOffsetInNode(closest, coordsClosest);\n  }\n  return {node, offset};\n}\n/* eslint-enable complexity */\n\nfunction constrainNodeTo(node, parentNode, existingOffset) {\n  let compare = parentNode.compareDocumentPosition(node);\n  if (compare & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    // the node is inside parentNode, do nothing\n    return { node, offset: existingOffset};\n  } else if (compare & Node.DOCUMENT_POSITION_CONTAINS) {\n    // the node contains parentNode. This shouldn't happen.\n    return { node, offset: existingOffset};\n  } else if (compare & Node.DOCUMENT_POSITION_PRECEDING) {\n    // node is before parentNode. return start of deepest first child\n    let child = parentNode.firstChild;\n    while (child.firstChild) {\n      child = child.firstChild;\n    }\n    return { node: child, offset: 0};\n  } else if (compare & Node.DOCUMENT_POSITION_FOLLOWING) {\n    // node is after parentNode. return end of deepest last child\n    let child = parentNode.lastChild;\n    while (child.lastChild) {\n      child = child.lastChild;\n    }\n\n    let offset = isTextNode(child) ? child.textContent.length : 1;\n    return {node: child, offset};\n  } else {\n    return { node, offset: existingOffset};\n  }\n}\n\n/*\n * Returns a new selection that is constrained within parentNode.\n * If the anchorNode or focusNode are outside the parentNode, they are replaced with the beginning\n * or end of the parentNode's children\n */\nfunction constrainSelectionTo(selection, parentNode) {\n  let {\n    node: anchorNode,\n    offset: anchorOffset\n  } = constrainNodeTo(selection.anchorNode, parentNode, selection.anchorOffset);\n  let {\n    node: focusNode,\n    offset: focusOffset\n  } = constrainNodeTo(selection.focusNode, parentNode, selection.focusOffset);\n\n  return { anchorNode, anchorOffset, focusNode, focusOffset };\n}\n\nfunction comparePosition(selection) {\n  let { anchorNode, focusNode, anchorOffset, focusOffset } = selection;\n  let headNode, tailNode, headOffset, tailOffset, direction;\n\n  const position = anchorNode.compareDocumentPosition(focusNode);\n\n  // IE may select return focus and anchor nodes far up the DOM tree instead of\n  // picking the deepest, most specific possible node. For example in\n  //\n  //     <div><span>abc</span><span>def</span></div>\n  //\n  // with a cursor between c and d, IE might say the focusNode is <div> with\n  // an offset of 1. However the anchorNode for a selection might still be\n  // <span> 2 if there was a selection.\n  //\n  // This code walks down the DOM tree until a good comparison of position can be\n  // made.\n  //\n  if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n    if (focusOffset < focusNode.childNodes.length) {\n      focusNode = focusNode.childNodes[focusOffset];\n      focusOffset = 0;\n    } else {\n      // This situation happens on IE when triple-clicking to select.\n      // Set the focus to the very last character inside the node.\n      while (focusNode.lastChild) {\n        focusNode = focusNode.lastChild;\n      }\n      focusOffset = focusNode.textContent.length;\n    }\n\n    return comparePosition({\n      focusNode,\n      focusOffset,\n      anchorNode, anchorOffset\n    });\n  } else if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    let offset = anchorOffset - 1;\n    if (offset < 0) {\n      offset = 0;\n    }\n    return comparePosition({\n      anchorNode: anchorNode.childNodes[offset],\n      anchorOffset: 0,\n      focusNode, focusOffset\n    });\n  // The meat of translating anchor and focus nodes to head and tail nodes\n  } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n    headNode = anchorNode; tailNode = focusNode;\n    headOffset = anchorOffset; tailOffset = focusOffset;\n    direction = DIRECTION.FORWARD;\n  } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n    headNode = focusNode; tailNode = anchorNode;\n    headOffset = focusOffset; tailOffset = anchorOffset;\n    direction = DIRECTION.BACKWARD;\n  } else { // same node\n    headNode = tailNode = anchorNode;\n    headOffset = anchorOffset;\n    tailOffset = focusOffset;\n    if (tailOffset < headOffset) {\n      // Swap the offset order\n      headOffset = focusOffset;\n      tailOffset = anchorOffset;\n      direction = DIRECTION.BACKWARD;\n    } else if (headOffset < tailOffset) {\n      direction = DIRECTION.FORWARD;\n    } else {\n      direction = null;\n    }\n  }\n\n  return {headNode, headOffset, tailNode, tailOffset, direction};\n}\n\n/**\n * A logical range of a {@link Post}.\n * Usually an instance of Range will be read from the {@link Editor#range} property,\n * but it may be useful to instantiate a range directly when programmatically modifying a Post.\n */\nclass Range {\n  /**\n   * @param {Position} head\n   * @param {Position} [tail=head]\n   * @param {Direction} [direction=null]\n   * @return {Range}\n   * @private\n   */\n  constructor(head, tail=head, direction=null) {\n    /** @property {Position} head */\n    this.head = head;\n\n    /** @property {Position} tail */\n    this.tail = tail;\n\n    /** @property {Direction} direction */\n    this.direction = direction;\n  }\n\n  /**\n   * Shorthand to create a new range from a section(s) and offset(s).\n   * When given only a head section and offset, creates a collapsed range.\n   * @param {Section} headSection\n   * @param {number} headOffset\n   * @param {Section} [tailSection=headSection]\n   * @param {number} [tailOffset=headOffset]\n   * @param {Direction} [direction=null]\n   * @return {Range}\n   */\n  static create(headSection, headOffset, tailSection=headSection, tailOffset=headOffset, direction=null) {\n    return new Range(\n      new Position$1(headSection, headOffset),\n      new Position$1(tailSection, tailOffset),\n      direction\n    );\n  }\n\n  static blankRange() {\n    return new Range(Position$1.blankPosition(), Position$1.blankPosition());\n  }\n\n  /**\n   * @param {Markerable} section\n   * @return {Range} A range that is constrained to only the part that\n   * includes the section.\n   * FIXME -- if the section isn't the head or tail, it's assumed to be\n   * wholly contained. It's possible to call `trimTo` with a selection that is\n   * outside of the range, though, which would invalidate that assumption.\n   * There's no efficient way to determine if a section is within a range, yet.\n   * @private\n   */\n  trimTo(section) {\n    const length = section.length;\n\n    let headOffset = section === this.head.section ?\n      Math.min(this.head.offset, length) : 0;\n    let tailOffset = section === this.tail.section ?\n      Math.min(this.tail.offset, length) : length;\n\n    return Range.create(section, headOffset, section, tailOffset);\n  }\n\n  /**\n   * Expands the range 1 unit in the given direction\n   * If the range is expandable in the given direction, always returns a\n   * non-collapsed range.\n   * @param {Number} units If units is > 0, the range is extended to the right,\n   *                 otherwise range is extended to the left.\n   * @return {Range}\n   * @public\n   */\n  extend(units) {\n    assert(`Must pass integer to Range#extend`, typeof units === 'number');\n\n    if (units === 0) { return this; }\n\n    let { head, tail, direction: currentDirection } = this;\n    switch (currentDirection) {\n      case DIRECTION.FORWARD:\n        return new Range(head, tail.move(units), currentDirection);\n      case DIRECTION.BACKWARD:\n        return new Range(head.move(units), tail, currentDirection);\n      default: {\n        let newDirection = units > 0 ? DIRECTION.FORWARD : DIRECTION.BACKWARD;\n        return new Range(head, tail, newDirection).extend(units);\n      }\n    }\n  }\n\n  /**\n   * Moves this range 1 unit in the given direction.\n   * If the range is collapsed, returns a collapsed range shifted by 1 unit,\n   * otherwise collapses this range to the position at the `direction` end of the range.\n   * Always returns a collapsed range.\n   * @param {Direction} direction\n   * @return {Range}\n   * @public\n   */\n  move(direction) {\n    assert(`Must pass DIRECTION.FORWARD (${DIRECTION.FORWARD}) or DIRECTION.BACKWARD (${DIRECTION.BACKWARD}) to Range#move`,\n           direction === DIRECTION.FORWARD || direction === DIRECTION.BACKWARD);\n\n    let { focusedPosition, isCollapsed } = this;\n\n    if (isCollapsed) {\n      return new Range(focusedPosition.move(direction));\n    } else {\n      return this._collapse(direction);\n    }\n  }\n\n  /**\n   * expand a range to all markers matching a given check\n   *\n   * @param {Function} detectMarker\n   * @return {Range} The expanded range\n   *\n   * @public\n   */\n  expandByMarker(detectMarker) {\n    let {\n      head,\n      tail,\n      direction\n    } = this;\n    let {section: headSection} = head;\n    if (headSection !== tail.section) {\n      throw new Error('#expandByMarker does not work across sections. Perhaps you should confirm the range is collapsed');\n    }\n\n    let firstNotMatchingDetect = i => {\n      return !detectMarker(i);\n    };\n\n    let headMarker = headSection.markers.detect(firstNotMatchingDetect, head.marker, true);\n    if (!headMarker && detectMarker(headSection.markers.head)) {\n      headMarker = headSection.markers.head;\n    } else {\n      headMarker = headMarker.next || head.marker;\n    }\n    let headPosition = new Position$1(headSection, headSection.offsetOfMarker(headMarker));\n\n    let tailMarker = tail.section.markers.detect(firstNotMatchingDetect, tail.marker);\n    if (!tailMarker && detectMarker(headSection.markers.tail)) {\n      tailMarker = headSection.markers.tail;\n    } else {\n      tailMarker = tailMarker.prev || tail.marker;\n    }\n    let tailPosition = new Position$1(tail.section, tail.section.offsetOfMarker(tailMarker) + tailMarker.length);\n\n    return headPosition.toRange(tailPosition, direction);\n  }\n\n  _collapse(direction) {\n    return new Range(direction === DIRECTION.BACKWARD ? this.head : this.tail);\n  }\n\n  get focusedPosition() {\n    return this.direction === DIRECTION.BACKWARD ? this.head : this.tail;\n  }\n\n  isEqual(other) {\n    return other &&\n      this.head.isEqual(other.head) &&\n      this.tail.isEqual(other.tail);\n  }\n\n  get isBlank() {\n    return this.head.isBlank && this.tail.isBlank;\n  }\n\n  // \"legacy\" APIs\n  get headSection() {\n    return this.head.section;\n  }\n  get tailSection() {\n    return this.tail.section;\n  }\n  get headSectionOffset() {\n    return this.head.offset;\n  }\n  get tailSectionOffset() {\n    return this.tail.offset;\n  }\n  get isCollapsed() {\n    return this.head.isEqual(this.tail);\n  }\n  get headMarker() {\n    return this.head.marker;\n  }\n  get tailMarker() {\n    return this.tail.marker;\n  }\n  get headMarkerOffset() {\n    return this.head.offsetInMarker;\n  }\n  get tailMarkerOffset() {\n    return this.tail.offsetInMarker;\n  }\n}\n\nconst { FORWARD, BACKWARD } = DIRECTION;\n\n// generated via http://xregexp.com/ to cover chars that \\w misses\n// (new XRegExp('\\\\p{Alphabetic}|[0-9]|_|:')).toString()\nconst WORD_CHAR_REGEX = /[A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͅͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևְ-ׇֽֿׁׂׅׄא-תװ-ײؐ-ؚؠ-ٗٙ-ٟٮ-ۓە-ۜۡ-ۭۨ-ۯۺ-ۼۿܐ-ܿݍ-ޱߊ-ߪߴߵߺࠀ-ࠗࠚ-ࠬࡀ-ࡘࢠ-ࢴࣣ-ࣰࣩ-ऻऽ-ौॎ-ॐॕ-ॣॱ-ঃঅ-ঌএঐও-নপ-রলশ-হঽ-ৄেৈোৌৎৗড়ঢ়য়-ৣৰৱਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਾ-ੂੇੈੋੌੑਖ਼-ੜਫ਼ੰ-ੵઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽ-ૅે-ૉોૌૐૠ-ૣૹଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽ-ୄେୈୋୌୖୗଡ଼ଢ଼ୟ-ୣୱஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-ௌௐௗఀ-ఃఅ-ఌఎ-ఐఒ-నప-హఽ-ౄె-ైొ-ౌౕౖౘ-ౚౠ-ౣಁ-ಃಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽ-ೄೆ-ೈೊ-ೌೕೖೞೠ-ೣೱೲഁ-ഃഅ-ഌഎ-ഐഒ-ഺഽ-ൄെ-ൈൊ-ൌൎൗൟ-ൣൺ-ൿංඃඅ-ඖක-නඳ-රලව-ෆා-ුූෘ-ෟෲෳก-ฺเ-ๆํກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ູົ-ຽເ-ໄໆໍໜ-ໟༀཀ-ཇཉ-ཬཱ-ཱྀྈ-ྗྙ-ྼက-ံးျ-ဿၐ-ၢၥ-ၨၮ-ႆႎႜႝႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፟ᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜓᜠ-ᜳᝀ-ᝓᝠ-ᝬᝮ-ᝰᝲᝳក-ឳា-ៈៗៜᠠ-ᡷᢀ-ᢪᢰ-ᣵᤀ-ᤞᤠ-ᤫᤰ-ᤸᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨛᨠ-ᩞᩡ-ᩴᪧᬀ-ᬳᬵ-ᭃᭅ-ᭋᮀ-ᮩᮬ-ᮯᮺ-ᯥᯧ-ᯱᰀ-ᰵᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳳᳵᳶᴀ-ᶿᷧ-ᷴḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⒶ-ⓩⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⷠ-ⷿⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿕ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙴ-ꙻꙿ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞭꞰ-ꞷꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠧꡀ-ꡳꢀ-ꣃꣲ-ꣷꣻꣽꤊ-ꤪꤰ-ꥒꥠ-ꥼꦀ-ꦲꦴ-ꦿꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨶꩀ-ꩍꩠ-ꩶꩺꩾ-ꪾꫀꫂꫛ-ꫝꫠ-ꫯꫲ-ꫵꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯪ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ]|[0-9]|_|:/;\n\nfunction findParentSectionFromNode(renderTree, node) {\n  let renderNode =  renderTree.findRenderNodeFromElement(\n    node,\n    (renderNode) => renderNode.postNode.isSection\n  );\n\n  return renderNode && renderNode.postNode;\n}\n\nfunction findOffsetInMarkerable(markerable, node, offset) {\n  let offsetInSection = 0;\n  let marker = markerable.markers.head;\n  while (marker) {\n    let markerNode = marker.renderNode.element;\n    if (markerNode === node) {\n      return offsetInSection + offset;\n    } else if (marker.isAtom) {\n      if (marker.renderNode.headTextNode === node) {\n        return offsetInSection;\n      } else if (marker.renderNode.tailTextNode === node) {\n        return offsetInSection + 1;\n      }\n    }\n\n    offsetInSection += marker.length;\n    marker = marker.next;\n  }\n\n  return offsetInSection;\n}\n\nfunction findOffsetInSection(section, node, offset) {\n  if (section.isMarkerable) {\n    return findOffsetInMarkerable(section, node, offset);\n  } else {\n    assert('findOffsetInSection must be called with markerable or card section',\n           section.isCardSection);\n\n    let wrapperNode = section.renderNode.element;\n    let endTextNode = wrapperNode.lastChild;\n    if (node === endTextNode) {\n      return 1;\n    }\n    return 0;\n  }\n}\n\nlet Position, BlankPosition;\n\nPosition = class Position {\n  /**\n   * A position is a logical location (zero-width, or \"collapsed\") in a post,\n   * typically between two characters in a section.\n   * Two positions (a head and a tail) make up a {@link Range}.\n   * @constructor\n   */\n  constructor(section, offset=0, isBlank=false) {\n    if (!isBlank) {\n      assert('Position must have a section that is addressable by the cursor',\n             (section && section.isLeafSection));\n      assert('Position must have numeric offset',\n             (typeof offset === 'number'));\n    }\n\n    this.section = section;\n    this.offset = offset;\n    this.isBlank = isBlank;\n  }\n\n  /**\n   * @param {integer} x x-position in current viewport\n   * @param {integer} y y-position in current viewport\n   * @param {Editor} editor\n   * @return {Position|null}\n   */\n  static atPoint(x, y, editor) {\n    let { _renderTree, element: rootElement } = editor;\n    let elementFromPoint = document.elementFromPoint(x, y);\n    if (!containsNode(rootElement, elementFromPoint)) {\n      return;\n    }\n\n    let { node, offset } = findOffsetInNode(elementFromPoint, {left: x, top: y});\n    return Position.fromNode(_renderTree, node, offset);\n  }\n\n  static blankPosition() {\n    return new BlankPosition();\n  }\n\n  /**\n   * Returns a range from this position to the given tail. If no explicit\n   * tail is given this returns a collapsed range focused on this position.\n   * @param {Position} [tail=this] The ending position\n   * @return {Range}\n   * @public\n   */\n  toRange(tail=this, direction=null) {\n    return new Range(this, tail, direction);\n  }\n\n  get leafSectionIndex() {\n    let post = this.section.post;\n    let leafSectionIndex;\n    post.walkAllLeafSections((section, index) => {\n      if (section === this.section) {\n        leafSectionIndex = index;\n      }\n    });\n    return leafSectionIndex;\n  }\n\n  get isMarkerable() {\n    return this.section && this.section.isMarkerable;\n  }\n\n  /**\n   * Returns the marker at this position, in the backward direction\n   * (i.e., the marker to the left of the cursor if the cursor is on a marker boundary and text is left-to-right)\n   * @return {Marker|undefined}\n   */\n  get marker() {\n    return this.isMarkerable && this.markerPosition.marker;\n  }\n\n  /**\n   * Returns the marker in `direction` from this position.\n   * If the position is in the middle of a marker, the direction is irrelevant.\n   * Otherwise, if the position is at a boundary between two markers, returns the\n   * marker to the left if `direction` === BACKWARD and the marker to the right\n   * if `direction` === FORWARD (assuming left-to-right text direction).\n   * @param {Direction}\n   * @return {Marker|undefined}\n   */\n  markerIn(direction) {\n    if (!this.isMarkerable) { return; }\n\n    let { marker, offsetInMarker } = this;\n    if (!marker) { return; }\n\n    if (offsetInMarker > 0 && offsetInMarker < marker.length) {\n      return marker;\n    } else if (offsetInMarker === 0) {\n      return direction === BACKWARD ? marker : marker.prev;\n    } else if (offsetInMarker === marker.length) {\n      return direction === FORWARD ? marker.next : marker;\n    }\n  }\n\n  get offsetInMarker() {\n    return this.markerPosition.offset;\n  }\n\n  isEqual(position) {\n    return this.section === position.section &&\n           this.offset  === position.offset;\n  }\n\n  /**\n   * @return {Boolean} If this position is at the head of the post\n   */\n  isHeadOfPost() {\n    return this.move(BACKWARD).isEqual(this);\n  }\n\n  /**\n   * @return {Boolean} If this position is at the tail of the post\n   */\n  isTailOfPost() {\n    return this.move(FORWARD).isEqual(this);\n  }\n\n  /**\n   * @return {Boolean} If this position is at the head of its section\n   */\n  isHead() {\n    return this.isEqual(this.section.headPosition());\n  }\n\n  /**\n   * @return {Boolean} If this position is at the tail of its section\n   */\n  isTail() {\n    return this.isEqual(this.section.tailPosition());\n  }\n\n  /**\n   * Move the position 1 unit in `direction`.\n   *\n   * @param {Number} units to move. > 0 moves right, < 0 moves left\n   * @return {Position} Return a new position one unit in the given\n   * direction. If the position is moving left and at the beginning of the post,\n   * the same position will be returned. Same if the position is moving right and\n   * at the end of the post.\n   */\n  move(units) {\n    assert('Must pass integer to Position#move', typeof units === 'number');\n\n    if (units < 0) {\n      return this.moveLeft().move(++units);\n    } else if (units > 0) {\n      return this.moveRight().move(--units);\n    } else {\n      return this;\n    }\n  }\n\n  /**\n   * @param {Number} direction (FORWARD or BACKWARD)\n   * @return {Position} The result of moving 1 \"word\" unit in `direction`\n   */\n  moveWord(direction) {\n    let isPostBoundary = direction === BACKWARD ? this.isHeadOfPost() : this.isTailOfPost();\n    if (isPostBoundary) {\n      return this;\n    }\n\n    if (!this.isMarkerable) {\n      return this.move(direction);\n    }\n\n    let pos = this;\n\n    // Helper fn to check if the pos is at the `dir` boundary of its section\n    let isBoundary = (pos, dir) => {\n      return dir === BACKWARD ? pos.isHead() : pos.isTail();\n    };\n    // Get the char at this position (looking forward/right)\n    let getChar = (pos) => {\n      let { marker, offsetInMarker } = pos;\n      return marker.charAt(offsetInMarker);\n    };\n    // Get the char in `dir` at this position\n    let peekChar = (pos, dir) => {\n      return dir === BACKWARD ? getChar(pos.move(BACKWARD)) : getChar(pos);\n    };\n    // Whether there is an atom in `dir` from this position\n    let isAtom = (pos, dir) => {\n      // Special case when position is at end, the marker associated with it is\n      // the marker to its left. Normally `pos#marker` is the marker to the right of the pos's offset.\n      if (dir === BACKWARD && pos.isTail() && pos.marker.isAtom) {\n        return true;\n      }\n      return dir === BACKWARD ? pos.move(BACKWARD).marker.isAtom : pos.marker.isAtom;\n    };\n\n    if (isBoundary(pos, direction)) {\n      // extend movement into prev/next section\n      return pos.move(direction).moveWord(direction);\n    }\n\n    let seekWord = (pos) => {\n      return !isBoundary(pos, direction) &&\n        !isAtom(pos, direction) &&\n        !WORD_CHAR_REGEX.test(peekChar(pos, direction));\n    };\n\n    // move(dir) while we are seeking the first word char\n    while (seekWord(pos)) {\n      pos = pos.move(direction);\n    }\n\n    if (isAtom(pos, direction)) {\n      return pos.move(direction);\n    }\n\n    let seekBoundary = (pos) => {\n      return !isBoundary(pos, direction) &&\n        !isAtom(pos, direction) &&\n        WORD_CHAR_REGEX.test(peekChar(pos, direction));\n    };\n\n    // move(dir) while we are seeking the first boundary position\n    while (seekBoundary(pos)) {\n      pos = pos.move(direction);\n    }\n\n    return pos;\n  }\n\n  /**\n   * The position to the left of this position.\n   * If this position is the post's headPosition it returns itself.\n   * @return {Position}\n   * @private\n   */\n  moveLeft() {\n    if (this.isHead()) {\n      let prev = this.section.previousLeafSection();\n      return prev ? prev.tailPosition() : this;\n    } else {\n      let offset = this.offset - 1;\n      if (this.isMarkerable && this.marker) {\n        let code = this.marker.value.charCodeAt(offset);\n        if (code >= LOW_SURROGATE_RANGE[0] && code <= LOW_SURROGATE_RANGE[1]) {\n          offset = offset - 1;\n        }\n      }\n      return new Position(this.section, offset);\n    }\n  }\n\n  /**\n   * The position to the right of this position.\n   * If this position is the post's tailPosition it returns itself.\n   * @return {Position}\n   * @private\n   */\n  moveRight() {\n    if (this.isTail()) {\n      let next = this.section.nextLeafSection();\n      return next ? next.headPosition() : this;\n    } else {\n      let offset = this.offset + 1;\n      if (this.isMarkerable && this.marker) {\n        let code = this.marker.value.charCodeAt(offset - 1);\n        if (code >= HIGH_SURROGATE_RANGE[0] && code <= HIGH_SURROGATE_RANGE[1]) {\n          offset = offset + 1;\n        }\n      }\n      return new Position(this.section, offset);\n    }\n  }\n\n  static fromNode(renderTree, node, offset) {\n    if (isTextNode(node)) {\n      return Position.fromTextNode(renderTree, node, offset);\n    } else {\n      return Position.fromElementNode(renderTree, node, offset);\n    }\n  }\n\n  static fromTextNode(renderTree, textNode, offsetInNode) {\n    const renderNode = renderTree.getElementRenderNode(textNode);\n    let section, offsetInSection;\n\n    if (renderNode) {\n      const marker = renderNode.postNode;\n      section = marker.section;\n\n      assert(`Could not find parent section for mapped text node \"${textNode.textContent}\"`,\n             !!section);\n      offsetInSection = section.offsetOfMarker(marker, offsetInNode);\n    } else {\n      // all text nodes should be rendered by markers except:\n      //   * text nodes inside cards\n      //   * text nodes created by the browser during text input\n      // both of these should have rendered parent sections, though\n      section = findParentSectionFromNode(renderTree, textNode);\n      assert(`Could not find parent section for un-mapped text node \"${textNode.textContent}\"`,\n             !!section);\n\n      offsetInSection = findOffsetInSection(section, textNode, offsetInNode);\n    }\n\n    return new Position(section, offsetInSection);\n  }\n\n  static fromElementNode(renderTree, elementNode, offset) {\n    let position;\n\n    // The browser may change the reported selection to equal the editor's root\n    // element if the user clicks an element that is immediately removed,\n    // which can happen when clicking to remove a card.\n    if (elementNode === renderTree.rootElement) {\n      let post = renderTree.rootNode.postNode;\n      position = offset === 0 ? post.headPosition() : post.tailPosition();\n    } else {\n      let section = findParentSectionFromNode(renderTree, elementNode);\n      assert('Could not find parent section from element node', !!section);\n\n      if (section.isCardSection) {\n        // Selections in cards are usually made on a text node\n        // containing a &zwnj;  on one side or the other of the card but\n        // some scenarios (Firefox) will result in selecting the\n        // card's wrapper div. If the offset is 2 we've selected\n        // the final zwnj and should consider the cursor at the\n        // end of the card (offset 1). Otherwise,  the cursor is at\n        // the start of the card\n        position = offset < 2 ? section.headPosition() : section.tailPosition();\n      } else {\n\n        // In Firefox it is possible for the cursor to be on an atom's wrapper\n        // element. (In Chrome/Safari, the browser corrects this to be on\n        // one of the text nodes surrounding the wrapper).\n        // This code corrects for when the browser reports the cursor position\n        // to be on the wrapper element itself\n        let renderNode = renderTree.getElementRenderNode(elementNode);\n        let postNode = renderNode && renderNode.postNode;\n        if (postNode && postNode.isAtom) {\n          let sectionOffset = section.offsetOfMarker(postNode);\n          if (offset > 1) {\n            // we are on the tail side of the atom\n            sectionOffset += postNode.length;\n          }\n          position = new Position(section, sectionOffset);\n        } else if (offset >= elementNode.childNodes.length) {\n\n          // This is to deal with how Firefox handles triple-click selections.\n          // See https://stackoverflow.com/a/21234837/1269194 for an\n          // explanation.\n          position = section.tailPosition();\n        } else {\n          // The offset is 0 if the cursor is on a non-atom-wrapper element node\n          // (e.g., a <br> tag in a blank markup section)\n          position = section.headPosition();\n        }\n      }\n    }\n\n    return position;\n  }\n\n  /**\n   * @private\n   */\n  get markerPosition() {\n    assert('Cannot get markerPosition without a section', !!this.section);\n    assert('cannot get markerPosition of a non-markerable', !!this.section.isMarkerable);\n    return this.section.markerPositionAtOffset(this.offset);\n  }\n};\n\nBlankPosition = class BlankPosition extends Position {\n  constructor() {\n    super(null, 0, true);\n  }\n\n  isEqual(other) {\n    return other && other.isBlank;\n  }\n\n  toRange() { return Range.blankRange(); }\n  get leafSectionIndex() { assert('must implement get leafSectionIndex', false); }\n\n  get isMarkerable() { return false; }\n  get marker() { return false; }\n  isHeadOfPost() { return false; }\n  isTailOfPost() { return false; }\n  isHead() { return false; }\n  isTail() { return false; }\n  move() { return this; }\n  moveWord() { return this; }\n\n  get markerPosition() { return {}; }\n};\n\nvar Position$1 = Position;\n\n/**\n * @module UI\n */\n\nlet defaultShowPrompt = (message, defaultValue, callback) => callback(window.prompt(message, defaultValue));\n\n/**\n * @callback promptCallback\n * @param {String} url The URL to pass back to the editor for linking\n *        to the selected text.\n */\n\n/**\n * @callback showPrompt\n * @param {String} message The text of the prompt.\n * @param {String} defaultValue The initial URL to display in the prompt.\n * @param {module:UI~promptCallback} callback Once your handler has accepted a URL,\n *        it should pass it to `callback` so that the editor may link the\n *        selected text.\n */\n\n/**\n * Exposes the core behavior for linking and unlinking text, and allows for\n * customization of the URL input handler.\n * @param {Editor} editor An editor instance to operate on. If a range is selected,\n *        either prompt for a URL and add a link or un-link the\n *        currently linked text.\n * @param {module:UI~showPrompt} [showPrompt] An optional custom input handler. Defaults\n *        to using `window.prompt`.\n * @example\n * let myPrompt = (message, defaultURL, promptCallback) => {\n *   let url = window.prompt(\"Overriding the defaults\", \"http://placekitten.com\");\n *   promptCallback(url);\n * };\n *\n * editor.registerKeyCommand({\n *   str: \"META+K\",\n *   run(editor) {\n *     toggleLink(editor, myPrompt);\n *   }\n * });\n * @public\n */\nfunction toggleLink(editor, showPrompt=defaultShowPrompt) {\n  if (editor.range.isCollapsed) {\n    return;\n  }\n\n  let selectedText = editor.cursor.selectedText();\n  let defaultUrl = '';\n  if (selectedText.indexOf('http') !== -1) { defaultUrl = selectedText; }\n\n  let {range} = editor;\n  let hasLink = editor.detectMarkupInRange(range, 'a');\n\n  if (hasLink) {\n    editor.toggleMarkup('a');\n  } else {\n    showPrompt('Enter a URL', defaultUrl, url => {\n      if (!url) { return; }\n\n      editor.toggleMarkup('a', {href: url});\n    });\n  }\n}\n\n/**\n * Exposes the core behavior for editing an existing link, and allows for\n * customization of the URL input handler.\n * @param {HTMLAnchorElement} target The anchor (<a>) DOM element whose URL should be edited.\n * @param {Editor} editor An editor instance to operate on. If a range is selected,\n *        either prompt for a URL and add a link or un-link the\n *        currently linked text.\n * @param {module:UI~showPrompt} [showPrompt] An optional custom input handler. Defaults\n *        to using `window.prompt`.\n *\n * @public\n */\nfunction editLink(target, editor, showPrompt=defaultShowPrompt) {\n  showPrompt('Enter a URL', target.href, url => {\n    if (!url) { return; }\n\n    const position = Position$1.fromNode(editor._renderTree, target.firstChild);\n    const range = new Range(position, new Position$1(position.section, position.offset + target.textContent.length));\n\n    editor.run(post => {\n      let markup = editor.builder.createMarkup('a', {href: url});\n\n      // This is the only way to \"update\" a markup with new attributes in the\n      // current API.\n      post.toggleMarkup(markup, range);\n      post.toggleMarkup(markup, range);\n    });\n  });\n}\n\nvar ui = {\n  toggleLink,\n  editLink\n};\n\nconst SHOW_DELAY = 200;\nconst HIDE_DELAY = 600;\n\nclass Tooltip extends View {\n  constructor(options) {\n    options.classNames = ['__mobiledoc-tooltip'];\n    super(options);\n\n    this.rootElement = options.rootElement;\n    this.editor = options.editor;\n\n    this.addListeners(options);\n  }\n\n  showLink(linkEl) {\n    const { editor, element: tooltipEl } = this;\n    const { tooltipPlugin } = editor;\n\n    tooltipPlugin.renderLink(tooltipEl, linkEl, {\n      editLink: () => {\n        editLink(linkEl, editor);\n        this.hide();\n      }\n    });\n\n    this.show();\n    positionElementCenteredBelow(this.element, linkEl);\n\n    this.elementObserver = whenElementIsNotInDOM(linkEl, () => this.hide());\n  }\n\n  addListeners(options) {\n    const { rootElement, element: tooltipElement } = this;\n    let showTimeout, hideTimeout;\n\n    const scheduleHide = () => {\n      clearTimeout(hideTimeout);\n      hideTimeout = setTimeout(() => {\n        this.hide();\n      }, HIDE_DELAY);\n    };\n\n    this.addEventListener(tooltipElement, 'mouseenter', e => {\n      clearTimeout(hideTimeout);\n    });\n\n    this.addEventListener(tooltipElement, 'mouseleave', e => {\n      scheduleHide();\n    });\n\n    this.addEventListener(rootElement, 'mouseover', (e) => {\n      let target = getEventTargetMatchingTag(options.showForTag, e.target, rootElement);\n\n      if (target && target.isContentEditable) {\n        clearTimeout(hideTimeout);\n        showTimeout = setTimeout(() => {\n          this.showLink(target);\n        }, SHOW_DELAY);\n      }\n    });\n\n    this.addEventListener(rootElement, 'mouseout', (e) => {\n      clearTimeout(showTimeout);\n      if (this.elementObserver) { this.elementObserver.cancel(); }\n      scheduleHide();\n    });\n  }\n}\n\nconst DEFAULT_TOOLTIP_PLUGIN = {\n  renderLink(tooltipEl, linkEl, { editLink }) {\n    const { href } = linkEl;\n    tooltipEl.innerHTML = `<a href=\"${href}\" target=\"_blank\">${href}</a>`;\n    const button = document.createElement('button');\n    button.classList.add('__mobiledoc-tooltip__edit-link');\n    button.innerText = 'Edit Link';\n    button.addEventListener('click', editLink);\n    tooltipEl.append(button);\n  }\n};\n\nclass LifecycleCallbacks {\n  constructor(queueNames=[]) {\n    this.callbackQueues = {};\n    this.removalQueues = {};\n\n    queueNames.forEach(name => {\n      this.callbackQueues[name] = [];\n      this.removalQueues[name] = [];\n    });\n  }\n\n  runCallbacks(queueName, args=[]) {\n    let queue = this._getQueue(queueName);\n    queue.forEach(cb => cb(...args));\n\n    let toRemove = this.removalQueues[queueName];\n    toRemove.forEach(cb => {\n      let index = queue.indexOf(cb);\n      if (index !== -1) {\n        queue.splice(index, 1);\n      }\n    });\n\n    this.removalQueues[queueName] = [];\n  }\n\n  addCallback(queueName, callback) {\n    this._getQueue(queueName).push(callback);\n  }\n\n  _scheduleCallbackForRemoval(queueName, callback) {\n    this.removalQueues[queueName].push(callback);\n  }\n\n  addCallbackOnce(queueName, callback) {\n    let queue = this._getQueue(queueName);\n    if (queue.indexOf(callback) === -1) {\n      queue.push(callback);\n      this._scheduleCallbackForRemoval(queueName, callback);\n    }\n  }\n\n  _getQueue(queueName) {\n    let queue = this.callbackQueues[queueName];\n    assert(`No queue found for \"${queueName}\"`, !!queue);\n    return queue;\n  }\n}\n\nconst MARKERABLE = 'markerable',\n      NESTED_MARKERABLE = 'nested_markerable',\n      NON_MARKERABLE = 'non_markerable';\n\nclass Visitor {\n  constructor(inserter, cursorPosition) {\n    let { postEditor, post } = inserter;\n    this.postEditor = postEditor;\n    this._post = post;\n    this.cursorPosition = cursorPosition;\n    this.builder = this.postEditor.builder;\n\n    this._hasInsertedFirstLeafSection = false;\n  }\n\n  get cursorPosition() {\n    return this._cursorPosition;\n  }\n\n  set cursorPosition(position) {\n    this._cursorPosition = position;\n    this.postEditor.setRange(position);\n  }\n\n  visit(node) {\n    let method = node.type;\n    assert(`Cannot visit node of type ${node.type}`, !!this[method]);\n    this[method](node);\n  }\n\n  _canMergeSection(section) {\n    if (this._hasInsertedFirstLeafSection) {\n      return false;\n    } else {\n      return this._isMarkerable && section.isMarkerable;\n    }\n  }\n\n  get _isMarkerable() {\n    return this.cursorSection.isMarkerable;\n  }\n\n  get cursorSection() {\n    return this.cursorPosition.section;\n  }\n\n  get cursorOffset() {\n    return this.cursorPosition.offset;\n  }\n\n  get _isNested() {\n    return this.cursorSection.isNested;\n  }\n\n  [POST_TYPE](node) {\n    if (this.cursorSection.isBlank && !this._isNested) {\n      // replace blank section with entire post\n      let newSections = node.sections.map(s => s.clone());\n      this._replaceSection(this.cursorSection, newSections);\n    } else {\n      node.sections.forEach(section => this.visit(section));\n    }\n  }\n\n  [MARKUP_SECTION_TYPE](node) {\n    this[MARKERABLE](node);\n  }\n\n  [LIST_SECTION_TYPE](node) {\n    let hasNext = !!node.next;\n    node.items.forEach(item => this.visit(item));\n\n    if (this._isNested && hasNext) {\n      this._breakNestedAtCursor();\n    }\n  }\n\n  [LIST_ITEM_TYPE](node) {\n    this[NESTED_MARKERABLE](node);\n  }\n\n  [CARD_TYPE](node) {\n    this[NON_MARKERABLE](node);\n  }\n\n  [IMAGE_SECTION_TYPE](node) {\n    this[NON_MARKERABLE](node);\n  }\n\n  [NON_MARKERABLE](section) {\n    if (this._isNested) {\n      this._breakNestedAtCursor();\n    } else if (!this.cursorSection.isBlank) {\n      this._breakAtCursor();\n    }\n\n    this._insertLeafSection(section);\n  }\n\n  [MARKERABLE](section) {\n    if (this._canMergeSection(section)) {\n      this._mergeSection(section);\n    } else if (this._isNested && this._isMarkerable) {\n      // If we are attaching a markerable section to a list item,\n      // insert a linebreak then merge the section onto the resulting blank list item\n      this._breakAtCursor();\n\n      // Advance the cursor to the head of the blank list item\n      let nextPosition = this.cursorSection.next.headPosition();\n      this.cursorPosition = nextPosition;\n\n      // Merge this section onto the list item\n      this._mergeSection(section);\n    } else {\n      this._breakAtCursor();\n      this._insertLeafSection(section);\n    }\n  }\n\n  [NESTED_MARKERABLE](section) {\n    if (this._canMergeSection(section)) {\n      this._mergeSection(section);\n      return;\n    }\n\n    section = this._isNested ? section : this._wrapNestedSection(section);\n    this._breakAtCursor();\n    this._insertLeafSection(section);\n  }\n\n  // break out of a nested cursor position\n  _breakNestedAtCursor() {\n    assert('Cannot call _breakNestedAtCursor if not nested', this._isNested);\n\n    let parent = this.cursorSection.parent;\n    let cursorAtEndOfList = this.cursorPosition.isEqual(parent.tailPosition());\n\n    if (cursorAtEndOfList) {\n      let blank = this.builder.createMarkupSection();\n      this._insertSectionAfter(blank, parent);\n    } else {\n      let [, blank,] = this._breakListAtCursor();\n      this.cursorPosition = blank.tailPosition();\n    }\n  }\n\n  _breakListAtCursor() {\n    assert('Cannot _splitParentSection if cursor position is not nested',\n           this._isNested);\n\n    let list     = this.cursorSection.parent,\n        position = this.cursorPosition,\n        blank    = this.builder.createMarkupSection();\n    let [pre, post] = this.postEditor._splitListAtPosition(list, position);\n\n    let collection = this._post.sections,\n        reference  = post;\n    this.postEditor.insertSectionBefore(collection, blank, reference);\n    return [pre, blank, post];\n  }\n\n  _wrapNestedSection(section) {\n    let tagName = section.parent.tagName;\n    let parent = this.builder.createListSection(tagName);\n    parent.items.append(section.clone());\n    return parent;\n  }\n\n  _mergeSection(section) {\n    assert('Can only merge markerable sections',\n           this._isMarkerable && section.isMarkerable);\n    this._hasInsertedFirstLeafSection = true;\n\n    let markers = section.markers.map(m => m.clone());\n    let position = this.postEditor.insertMarkers(this.cursorPosition, markers);\n\n    this.cursorPosition = position;\n  }\n\n  // Can be called to add a line break when in a nested section or a parent\n  // section.\n  _breakAtCursor() {\n    if (this.cursorSection.isBlank) {\n      return;\n    } else if (this._isMarkerable) {\n      this._breakMarkerableAtCursor();\n    } else {\n      this._breakNonMarkerableAtCursor();\n    }\n  }\n\n  // Inserts a blank section before/after the cursor,\n  // depending on cursor position.\n  _breakNonMarkerableAtCursor() {\n    let collection = this._post.sections,\n        blank = this.builder.createMarkupSection(),\n        reference = this.cursorPosition.isHead() ? this.cursorSection :\n                                                   this.cursorSection.next;\n    this.postEditor.insertSectionBefore(collection, blank, reference);\n    this.cursorPosition = blank.tailPosition();\n  }\n\n  _breakMarkerableAtCursor() {\n    let [pre,] =\n      this.postEditor.splitSection(this.cursorPosition);\n\n    this.cursorPosition = pre.tailPosition();\n  }\n\n  _replaceSection(section, newSections) {\n    assert('Cannot replace section that does not have parent.sections',\n           section.parent && section.parent.sections);\n    assert('Must pass enumerable to _replaceSection', !!newSections.forEach);\n\n    let collection = section.parent.sections;\n    let reference = section.next;\n    this.postEditor.removeSection(section);\n    newSections.forEach(section => {\n      this.postEditor.insertSectionBefore(collection, section, reference);\n    });\n    let lastSection = newSections[newSections.length - 1];\n\n    this.cursorPosition = lastSection.tailPosition();\n  }\n\n  _insertSectionBefore(section, reference) {\n    let collection = this.cursorSection.parent.sections;\n    this.postEditor.insertSectionBefore(collection, section, reference);\n\n    this.cursorPosition = section.tailPosition();\n  }\n\n  // Insert a section after the parent section.\n  // E.g., add a markup section after a list section\n  _insertSectionAfter(section, parent) {\n    assert('Cannot _insertSectionAfter nested section', !parent.isNested);\n    let reference = parent.next;\n    let collection = this._post.sections;\n    this.postEditor.insertSectionBefore(collection, section, reference);\n    this.cursorPosition = section.tailPosition();\n  }\n\n  _insertLeafSection(section) {\n    assert('Can only _insertLeafSection when cursor is at end of section',\n           this.cursorPosition.isTail());\n\n    this._hasInsertedFirstLeafSection = true;\n    section = section.clone();\n\n    if (this.cursorSection.isBlank) {\n      assert('Cannot insert leaf non-markerable section when cursor is nested',\n             !(section.isMarkerable && this._isNested));\n      this._replaceSection(this.cursorSection, [section]);\n    } else if (this.cursorSection.next && this.cursorSection.next.isBlank) {\n      this._replaceSection(this.cursorSection.next, [section]);\n    } else {\n      let reference = this.cursorSection.next;\n      this._insertSectionBefore(section, reference);\n    }\n  }\n}\n\nclass Inserter {\n  constructor(postEditor, post) {\n    this.postEditor = postEditor;\n    this.post = post;\n  }\n\n  insert(cursorPosition, newPost) {\n    let visitor = new Visitor(this, cursorPosition);\n    if (!newPost.isBlank) {\n      visitor.visit(newPost);\n    }\n    return visitor.cursorPosition;\n  }\n}\n\n/**\n * Usage:\n * Without a conditional, always prints deprecate message:\n *   `deprecate('This is deprecated')`\n *\n * Conditional deprecation, works similarly to `assert`, prints deprecation if\n * conditional is false:\n *   `deprecate('Deprecated only if foo !== bar', foo === bar)`\n */\nfunction deprecate(message, conditional=false) {\n  if (!conditional) {\n    // eslint-disable-next-line no-console\n    console.log(`[mobiledoc-kit] [DEPRECATED]: ${message}`);\n  }\n}\n\nfunction toRange(rangeLike) {\n  assert(`Must pass non-blank object to \"toRange\"`, !!rangeLike);\n\n  if (rangeLike instanceof Range) {\n    return rangeLike;\n  } else if (rangeLike instanceof Position$1) {\n    return rangeLike.toRange();\n  }\n\n  assert(`Incorrect structure for rangeLike: ${rangeLike}`, false);\n}\n\nconst { FORWARD: FORWARD$1, BACKWARD: BACKWARD$1 } = DIRECTION;\n\nfunction isListSectionTagName(tagName) {\n  return tagName === 'ul' || tagName === 'ol';\n}\n\nfunction shrinkRange(range) {\n  const { head, tail } = range;\n\n  if (tail.offset === 0 && head.section !== tail.section) {\n    range.tail = new Position$1(tail.section.prev, tail.section.prev.length);\n  }\n\n  return range;\n}\n\nconst CALLBACK_QUEUES = {\n  BEFORE_COMPLETE: 'beforeComplete',\n  COMPLETE: 'complete',\n  AFTER_COMPLETE: 'afterComplete'\n};\n\n// There are only two events that we're concerned about for Undo, that is inserting text and deleting content.\n// These are the only two states that go on a \"run\" and create a combined undo, everything else has it's own\n// deadicated undo.\nconst EDIT_ACTIONS = {\n  INSERT_TEXT: 1,\n  DELETE: 2\n};\n\n/**\n * The PostEditor is used to modify a post. It should not be instantiated directly.\n * Instead, a new instance of a PostEditor is created by the editor and passed\n * as the argument to the callback in {@link Editor#run}.\n *\n * Usage:\n * ```\n * editor.run((postEditor) => {\n *   // postEditor is an instance of PostEditor that can operate on the\n *   // editor's post\n * });\n * ```\n */\nclass PostEditor {\n  /**\n   * @private\n   */\n  constructor(editor) {\n    this.editor = editor;\n    this.builder = this.editor.builder;\n    this._callbacks = new LifecycleCallbacks(values(CALLBACK_QUEUES));\n\n    this._didComplete = false;\n    this.editActionTaken = null;\n\n    this._renderRange = () => this.editor.selectRange(this._range);\n    this._postDidChange = () => this.editor._postDidChange();\n    this._rerender = () => this.editor.rerender();\n  }\n\n  addCallback(...args) {\n    this._callbacks.addCallback(...args);\n  }\n\n  addCallbackOnce(...args) {\n    this._callbacks.addCallbackOnce(...args);\n  }\n\n  runCallbacks(...args) {\n    this._callbacks.runCallbacks(...args);\n  }\n\n  begin() {\n    // cache the editor's range\n    this._range = this.editor.range;\n  }\n\n  /**\n   * Schedules to select the given range on the editor after the postEditor\n   * has completed its work. This also updates the postEditor's active range\n   * (so that multiple calls to range-changing methods on the postEditor will\n   * update the correct range).\n   *\n   * Usage:\n   *   let range = editor.range;\n   *   editor.run(postEditor => {\n   *     let nextPosition = postEditor.deleteRange(range);\n   *\n   *     // Will position the editor's cursor at `nextPosition` after\n   *     // the postEditor finishes work and the editor rerenders.\n   *     postEditor.setRange(nextPosition);\n   *   });\n   * @param {Range|Position} range\n   * @public\n   */\n  setRange(range) {\n    range = toRange(range);\n\n    // TODO validate that the range is valid\n    // (does not contain marked-for-removal head or tail sections?)\n    this._range = range;\n    this.scheduleAfterRender(this._renderRange, true);\n  }\n\n  /**\n   * Delete a range from the post\n   *\n   * Usage:\n   * ```\n   *     let { range } = editor;\n   *     editor.run((postEditor) => {\n   *       let nextPosition = postEditor.deleteRange(range);\n   *       postEditor.setRange(nextPosition);\n   *     });\n   * ```\n   * @param {Range} range Cursor Range object with head and tail Positions\n   * @return {Position} The position where the cursor would go after deletion\n   * @public\n   */\n  deleteRange(range) {\n    assert(\"Must pass MobiledocKit Range to `deleteRange`\", range instanceof Range);\n\n    this.editActionTaken = EDIT_ACTIONS.DELETE;\n\n    let {\n      head, head: {section: headSection},\n      tail, tail: {section: tailSection}\n    } = range;\n\n    let { editor: { post } } = this;\n\n    if (headSection === tailSection) {\n      return this.cutSection(headSection, head, tail);\n    }\n\n    let nextSection = headSection.nextLeafSection();\n\n    let nextPos = this.cutSection(headSection, head, headSection.tailPosition());\n    // cutSection can replace the section, so re-read headSection here\n    headSection = nextPos.section;\n\n    // Remove sections in the middle of the range\n    while (nextSection !== tailSection) {\n      let tmp = nextSection;\n      nextSection = nextSection.nextLeafSection();\n      this.removeSection(tmp);\n    }\n\n    let tailPos = this.cutSection(tailSection, tailSection.headPosition(), tail);\n    // cutSection can replace the section, so re-read tailSection here\n    tailSection = tailPos.section;\n\n    if (tailSection.isBlank) {\n      this.removeSection(tailSection);\n    } else {\n      // If head and tail sections are markerable, join them\n      // Note: They may not be the same section type. E.g. this may join\n      // a tail section that was a list item onto a markup section, or vice versa.\n      // (This is the desired behavior.)\n      if (headSection.isMarkerable && tailSection.isMarkerable) {\n        headSection.join(tailSection);\n        this._markDirty(headSection);\n        this.removeSection(tailSection);\n      } else if (headSection.isBlank) {\n        this.removeSection(headSection);\n        nextPos = tailPos;\n      }\n    }\n\n    if (post.isBlank) {\n      post.sections.append(this.builder.createMarkupSection('p'));\n      nextPos = post.headPosition();\n    }\n\n    return nextPos;\n  }\n\n  /**\n   * Note: This method may replace `section` with a different section.\n   *\n   * \"Cut\" out the part of the section inside `headOffset` and `tailOffset`.\n   * If section is markerable this splits markers that straddle the head or tail (if necessary),\n   * and removes markers that are wholly inside the offsets.\n   * If section is a card, this may replace it with a blank markup section if the\n   * positions contain the entire card.\n   *\n   * @param {Section} section\n   * @param {Position} head\n   * @param {Position} tail\n   * @return {Position}\n   * @private\n   */\n  cutSection(section, head, tail) {\n    assert('Must pass head position and tail position to `cutSection`',\n           head instanceof Position$1 && tail instanceof Position$1);\n    assert('Must pass positions within same section to `cutSection`',\n           head.section === tail.section);\n\n    if (section.isBlank || head.isEqual(tail)) {\n      return head;\n    }\n    if (section.isCardSection) {\n      if (head.isHead() && tail.isTail()) {\n        let newSection = this.builder.createMarkupSection();\n        this.replaceSection(section, newSection);\n        return newSection.headPosition();\n      } else {\n        return tail;\n      }\n    }\n\n    let range = head.toRange(tail);\n    this.splitMarkers(range).forEach(m => this.removeMarker(m));\n\n    return head;\n  }\n\n  _coalesceMarkers(section) {\n    if (section.isMarkerable) {\n      this._removeBlankMarkers(section);\n      this._joinSimilarMarkers(section);\n    }\n  }\n\n  _removeBlankMarkers(section) {\n    forEach(\n      filter(section.markers, m => m.isBlank),\n      m => this.removeMarker(m)\n    );\n  }\n\n  // joins markers that have identical markups\n  _joinSimilarMarkers(section) {\n    let marker = section.markers.head;\n    let nextMarker;\n    while (marker && marker.next) {\n      nextMarker = marker.next;\n\n      if (marker.canJoin(nextMarker)) {\n        nextMarker.value = marker.value + nextMarker.value;\n        this._markDirty(nextMarker);\n        this.removeMarker(marker);\n      }\n\n      marker = nextMarker;\n    }\n  }\n\n  removeMarker(marker) {\n    this._scheduleForRemoval(marker);\n    if (marker.section) {\n      this._markDirty(marker.section);\n      marker.section.markers.remove(marker);\n    }\n  }\n\n  _scheduleForRemoval(postNode) {\n    if (postNode.renderNode) {\n      postNode.renderNode.scheduleForRemoval();\n\n      this.scheduleRerender();\n      this.scheduleDidUpdate();\n    }\n    let removedAdjacentToList = (postNode.prev && postNode.prev.isListSection) ||\n                                (postNode.next && postNode.next.isListSection);\n    if (removedAdjacentToList) {\n      this.addCallback(\n        CALLBACK_QUEUES.BEFORE_COMPLETE,\n        () => this._joinContiguousListSections()\n      );\n    }\n  }\n\n  _joinContiguousListSections() {\n    let { post } = this.editor;\n    let range = this._range;\n    let prev;\n    let groups = [];\n    let currentGroup;\n\n    // FIXME do we need to force a re-render of the range if changed sections\n    // are contained within the range?\n    let updatedHead = null;\n    forEach(post.sections, section => {\n      if (prev &&\n          prev.isListSection &&\n          section.isListSection &&\n          prev.tagName === section.tagName) {\n\n        currentGroup = currentGroup || [prev];\n        currentGroup.push(section);\n      } else {\n        if (currentGroup) {\n          groups.push(currentGroup);\n        }\n        currentGroup = null;\n      }\n      prev = section;\n    });\n\n    if (currentGroup) {\n      groups.push(currentGroup);\n    }\n\n    forEach(groups, group => {\n      let list = group[0];\n      forEach(group, listSection => {\n        if (listSection === list) {\n          return;\n        }\n\n        let currentHead = range.head;\n        let prevPosition;\n\n        // FIXME is there a currentHead if there is no range?\n        // is the current head a list item in the section\n        if (!range.isBlank && currentHead.section.isListItem &&\n            currentHead.section.parent === listSection) {\n          prevPosition = list.tailPosition();\n        }\n        this._joinListSections(list, listSection);\n        if (prevPosition) {\n          updatedHead = prevPosition.move(FORWARD$1);\n        }\n      });\n    });\n\n    if (updatedHead) {\n      this.setRange(updatedHead);\n    }\n  }\n\n  _joinListSections(baseList, nextList) {\n    baseList.join(nextList);\n    this._markDirty(baseList);\n    this.removeSection(nextList);\n  }\n\n  _markDirty(postNode) {\n    if (postNode.renderNode) {\n      postNode.renderNode.markDirty();\n\n      this.scheduleRerender();\n      this.scheduleDidUpdate();\n    }\n    if (postNode.section) {\n      this._markDirty(postNode.section);\n    }\n    if (postNode.isMarkerable) {\n      this.addCallback(\n        CALLBACK_QUEUES.BEFORE_COMPLETE, () => this._coalesceMarkers(postNode));\n    }\n  }\n\n  /**\n   * @param {Position} position object with {section, offset} the marker and offset to delete from\n   * @param {Number} direction The direction to delete in (default is BACKWARD)\n   * @return {Position} for positioning the cursor\n   * @public\n   * @deprecated after v0.10.3\n   */\n  deleteFrom(position, direction=DIRECTION.BACKWARD) {\n    deprecate(\"`postEditor#deleteFrom is deprecated. Use `deleteAtPosition(position, direction=BACKWARD, {unit}={unit: 'char'})` instead\");\n    return this.deleteAtPosition(position, direction, {unit: 'char'});\n  }\n\n  /**\n   * Delete 1 `unit` (can be 'char' or 'word') in the given `direction` at the given\n   * `position`. In almost all cases this will be equivalent to deleting the range formed\n   * by expanding the position 1 unit in the given direction. The exception is when deleting\n   * backward from the beginning of a list item, which reverts the list item into a markup section\n   * instead of joining it with its previous list item (if any).\n   *\n   * Usage:\n   *\n   *     let position = section.tailPosition();\n   *     // Section has text of \"Howdy!\"\n   *     editor.run((postEditor) => {\n   *       postEditor.deleteAtPosition(position);\n   *     });\n   *     // section has text of \"Howdy\"\n   *\n   * @param {Position} position The position to delete at\n   * @param {Direction} [direction=DIRECTION.BACKWARD] direction The direction to delete in\n   * @param {Object} [options]\n   * @param {String} [options.unit=\"char\"] The unit of deletion (\"word\" or \"char\")\n   * @return {Position}\n   */\n  deleteAtPosition(position, direction=DIRECTION.BACKWARD, {unit}={unit: 'char'}) {\n    if (direction === DIRECTION.BACKWARD) {\n      return this._deleteAtPositionBackward(position, unit);\n    } else {\n      return this._deleteAtPositionForward(position, unit);\n    }\n  }\n\n  _deleteAtPositionBackward(position, unit) {\n    if (position.isHead() && position.section.isListItem) {\n      this.toggleSection('p', position);\n      return this._range.head;\n    } else {\n      let prevPosition = unit === 'word' ? position.moveWord(BACKWARD$1) : position.move(BACKWARD$1);\n      let range = prevPosition.toRange(position);\n      return this.deleteRange(range);\n    }\n  }\n\n  _deleteAtPositionForward(position, unit) {\n    let nextPosition = unit === 'word' ? position.moveWord(FORWARD$1) : position.move(FORWARD$1);\n    let range = position.toRange(nextPosition);\n    return this.deleteRange(range);\n  }\n\n  /**\n   * Split markers at two positions, once at the head, and if necessary once\n   * at the tail.\n   *\n   * Usage:\n   * ```\n   *     let range = editor.range;\n   *     editor.run((postEditor) => {\n   *       postEditor.splitMarkers(range);\n   *     });\n   * ```\n   * The return value will be marker object completely inside the offsets\n   * provided. Markers outside of the split may also have been modified.\n   *\n   * @param {Range} markerRange\n   * @return {Array} of markers that are inside the split\n   * @private\n   */\n  splitMarkers(range) {\n    const { post } = this.editor;\n    const { head, tail } = range;\n\n    this.splitSectionMarkerAtOffset(head.section, head.offset);\n    this.splitSectionMarkerAtOffset(tail.section, tail.offset);\n\n    return post.markersContainedByRange(range);\n  }\n\n  splitSectionMarkerAtOffset(section, offset) {\n    const edit = section.splitMarkerAtOffset(offset);\n    edit.removed.forEach(m => this.removeMarker(m));\n  }\n\n  /**\n   * Split the section at the position.\n   *\n   * Usage:\n   * ```\n   *     let position = editor.cursor.offsets.head;\n   *     editor.run((postEditor) => {\n   *       postEditor.splitSection(position);\n   *     });\n   *     // Will result in the creation of two new sections\n   *     // replacing the old one at the cursor position\n   * ```\n   * The return value will be the two new sections. One or both of these\n   * sections can be blank (contain only a blank marker), for example if the\n   * headMarkerOffset is 0.\n   *\n   * @param {Position} position\n   * @return {Array} new sections, one for the first half and one for the second (either one can be null)\n   * @public\n   */\n  splitSection(position) {\n    const { section } = position;\n\n    if (section.isCardSection) {\n      return this._splitCardSection(section, position);\n    } else if (section.isListItem) {\n      let isLastAndBlank = section.isBlank && !section.next;\n      if (isLastAndBlank) {\n        // if is last, replace the item with a blank markup section\n        let parent = section.parent;\n        let collection = this.editor.post.sections;\n        let blank = this.builder.createMarkupSection();\n        this.removeSection(section);\n        this.insertSectionBefore(collection, blank, parent.next);\n\n        return [null, blank];\n      } else {\n        let [pre, post] = this._splitListItem(section, position);\n        return [pre, post];\n      }\n    } else {\n      let splitSections = section.splitAtPosition(position);\n      splitSections.forEach(s => this._coalesceMarkers(s));\n      this._replaceSection(section, splitSections);\n\n      return splitSections;\n    }\n  }\n\n  /**\n   * @param {Section} cardSection\n   * @param {Position} position to split at\n   * @return {Section[]} 2-item array of pre and post-split sections\n   * @private\n   */\n  _splitCardSection(cardSection, position) {\n    let { offset } = position;\n    assert('Cards section must be split at offset 0 or 1',\n           offset === 0 || offset === 1);\n\n    let newSection = this.builder.createMarkupSection();\n    let nextSection;\n    let surroundingSections;\n\n    if (offset === 0) {\n      nextSection = cardSection;\n      surroundingSections = [newSection, cardSection];\n    } else {\n      nextSection = cardSection.next;\n      surroundingSections = [cardSection, newSection];\n    }\n\n    let collection = this.editor.post.sections;\n    this.insertSectionBefore(collection, newSection, nextSection);\n\n    return surroundingSections;\n  }\n\n  /**\n   * @param {Section} section\n   * @param {Section} newSection\n   * @return null\n   * @public\n   */\n  replaceSection(section, newSection) {\n    if (!section) {\n      // FIXME should a falsy section be a valid argument?\n      this.insertSectionBefore(this.editor.post.sections, newSection, null);\n    } else {\n      this._replaceSection(section, [newSection]);\n    }\n  }\n\n  moveSectionBefore(collection, renderedSection, beforeSection) {\n    const newSection = renderedSection.clone();\n    this.removeSection(renderedSection);\n    this.insertSectionBefore(collection, newSection, beforeSection);\n    return newSection;\n  }\n\n  /**\n   * @param {Section} section A section that is already in DOM\n   * @public\n   */\n  moveSectionUp(renderedSection) {\n    const isFirst = !renderedSection.prev;\n    if (isFirst) {\n      return renderedSection;\n    }\n\n    const collection = renderedSection.parent.sections;\n    const beforeSection = renderedSection.prev;\n    return this.moveSectionBefore(collection, renderedSection, beforeSection);\n  }\n\n  /**\n   * @param {Section} section A section that is already in DOM\n   * @public\n   */\n  moveSectionDown(renderedSection) {\n    const isLast = !renderedSection.next;\n    if (isLast) {\n      return renderedSection;\n    }\n\n    const beforeSection = renderedSection.next.next;\n    const collection = renderedSection.parent.sections;\n    return this.moveSectionBefore(collection, renderedSection, beforeSection);\n  }\n\n  /**\n   * Insert an array of markers at the given position. If the position is in\n   * a non-markerable section (like a card section), this method throws an error.\n   *\n   * @param {Position} position\n   * @param {Marker[]} markers\n   * @return {Position} The position that represents the end of the inserted markers.\n   * @public\n   */\n  insertMarkers(position, markers) {\n    let { section, offset } = position;\n    assert('Cannot insert markers at non-markerable position',\n           section.isMarkerable);\n\n    this.editActionTaken = EDIT_ACTIONS.INSERT_TEXT;\n\n    let edit = section.splitMarkerAtOffset(offset);\n    edit.removed.forEach(marker => this._scheduleForRemoval(marker));\n\n    let prevMarker = section.markerBeforeOffset(offset);\n    markers.forEach(marker => {\n      section.markers.insertAfter(marker, prevMarker);\n      offset += marker.length;\n      prevMarker = marker;\n    });\n\n    this._coalesceMarkers(section);\n    this._markDirty(section);\n\n    let nextPosition = section.toPosition(offset);\n    this.setRange(nextPosition);\n    return nextPosition;\n  }\n\n  /**\n   * Inserts text with the given markups, ignoring the existing markups at\n   * the position, if any.\n   *\n   * @param {Position} position\n   * @param {String} text\n   * @param {Markup[]} markups\n   * @return {Position} position at the end of the inserted text\n   */\n  insertTextWithMarkup(position, text, markups=[]) {\n    let { section } = position;\n    if (!section.isMarkerable) { return; }\n    let marker = this.builder.createMarker(text, markups);\n    return this.insertMarkers(position, [marker]);\n  }\n\n  /**\n   * Insert the text at the given position\n   * Inherits the markups already at that position, if any.\n   *\n   * @param {Position} position\n   * @param {String} text\n   * @return {Position} position at the end of the inserted text.\n   */\n  insertText(position, text) {\n    let { section } = position;\n    if (!section.isMarkerable) { return; }\n    let markups = position.marker && position.marker.markups;\n    markups = markups || [];\n    return this.insertTextWithMarkup(position, text, markups);\n  }\n\n  _replaceSection(section, newSections) {\n    let nextSection = section.next;\n    let collection = section.parent.sections;\n\n    let nextNewSection = newSections[0];\n    if (nextNewSection.isMarkupSection && section.isListItem) {\n      // put the new section after the ListSection (section.parent)\n      // instead of after the ListItem\n      collection = section.parent.parent.sections;\n      nextSection = section.parent.next;\n    }\n\n    newSections.forEach(s => this.insertSectionBefore(collection, s, nextSection));\n    this.removeSection(section);\n  }\n\n  /**\n   * Given a markerRange (for example `editor.range`) mark all markers\n   * inside it as a given markup. The markup must be provided as a post\n   * abstract node.\n   *\n   * Usage:\n   *\n   *     let range = editor.range;\n   *     let strongMarkup = editor.builder.createMarkup('strong');\n   *     editor.run((postEditor) => {\n   *       postEditor.addMarkupToRange(range, strongMarkup);\n   *     });\n   *     // Will result some markers possibly being split, and the markup\n   *     // being applied to all markers between the split.\n   *\n   * @param {Range} range\n   * @param {Markup} markup A markup post abstract node\n   * @public\n   */\n  addMarkupToRange(range, markup) {\n    if (range.isCollapsed) { return; }\n\n    let markers = this.splitMarkers(range);\n    if (markers.length) {\n      // We insert the new markup at a consistent index across the range.\n      // If we just push on the end of the list, it can end up in different positions\n      // of the markup stack. This results in unnecessary closing and re-opening of\n      // the markup each time it changes position.\n      // If we just push it at the beginning of the list, this causes unnecessary closing\n      // and re-opening of surrounding tags.\n      // So, we look for any tags open across the whole range, and push into the stack\n      // at the end of those.\n      // Prompted by https://github.com/bustle/mobiledoc-kit/issues/360\n\n      let markupsOpenAcrossRange = reduce(markers, function (soFar, marker) {\n        return commonItems(soFar, marker.markups);\n      }, markers[0].markups);\n      let indexToInsert = markupsOpenAcrossRange.length;\n\n      markers.forEach(marker => {\n        marker.addMarkupAtIndex(markup, indexToInsert);\n        this._markDirty(marker);\n      });\n    }\n  }\n\n  /**\n   * Given a markerRange (for example `editor.range`) remove the given\n   * markup from all contained markers.\n   *\n   * Usage:\n   * ```\n   *     let { range } = editor;\n   *     let markup = markerRange.headMarker.markups[0];\n   *     editor.run(postEditor => {\n   *       postEditor.removeMarkupFromRange(range, markup);\n   *     });\n   *     // Will result in some markers possibly being split, and the markup\n   *     // being removed from all markers between the split.\n   * ```\n   * @param {Range} range Object with offsets\n   * @param {Markup|Function} markupOrCallback A markup post abstract node or\n   * a function that returns true when passed a markup that should be removed\n   * @private\n   */\n  removeMarkupFromRange(range, markupOrMarkupCallback) {\n    if (range.isCollapsed) { return; }\n\n    this.splitMarkers(range).forEach(marker => {\n      marker.removeMarkup(markupOrMarkupCallback);\n      this._markDirty(marker);\n    });\n  }\n\n  /**\n   * Toggle the given markup in the given range (or at the position given). If the range/position\n   * has the markup, the markup will be removed. If nothing in the range/position\n   * has the markup, the markup will be added to everything in the range/position.\n   *\n   * Usage:\n   * ```\n   * // Remove any 'strong' markup if it exists in the selection, otherwise\n   * // make it all 'strong'\n   * editor.run(postEditor => postEditor.toggleMarkup('strong'));\n   *\n   * // add/remove a link to 'bustle.com' to the selection\n   * editor.run(postEditor => {\n   *   const linkMarkup = postEditor.builder.createMarkup('a', {href: 'http://bustle.com'});\n   *   postEditor.toggleMarkup(linkMarkup);\n   * });\n   * ```\n   * @param {Markup|String} markupOrString Either a markup object created using\n   * the builder (useful when adding a markup with attributes, like an 'a' markup),\n   * or, if a string, the tag name of the markup (e.g. 'strong', 'em') to toggle.\n   * @param {Range|Position} range in which to toggle. Defaults to current editor range.\n   * @public\n   */\n  toggleMarkup(markupOrMarkupString, range=this._range) {\n    range = toRange(range);\n    const markup = typeof markupOrMarkupString === 'string' ?\n                     this.builder.createMarkup(markupOrMarkupString) :\n                     markupOrMarkupString;\n\n    const hasMarkup = this.editor.detectMarkupInRange(range, markup.tagName);\n    // FIXME: This implies only a single markup in a range. This may not be\n    // true for links (which are not the same object instance like multiple\n    // strong tags would be).\n    if (hasMarkup) {\n      this.removeMarkupFromRange(range, hasMarkup);\n    } else {\n      this.addMarkupToRange(range, markup);\n    }\n\n    this.setRange(range);\n  }\n\n  /**\n   * Toggles the tagName of the active section or sections in the given range/position.\n   * If every section has the tag name, they will all be reset to default sections.\n   * Otherwise, every section will be changed to the requested type\n   *\n   * @param {String} sectionTagName A valid markup section or\n   *        list section tag name (e.g. 'blockquote', 'h2', 'ul')\n   * @param {Range|Position} range The range over which to toggle.\n   *        Defaults to the current editor range.\n   * @public\n   */\n  toggleSection(sectionTagName, range=this._range) {\n    range = shrinkRange(toRange(range));\n\n    sectionTagName = normalizeTagName(sectionTagName);\n    let { post } = this.editor;\n\n    let everySectionHasTagName = true;\n    post.walkMarkerableSections(range, section => {\n      if (!this._isSameSectionType(section, sectionTagName)) {\n        everySectionHasTagName = false;\n      }\n    });\n\n    let tagName = everySectionHasTagName ? 'p' : sectionTagName;\n    let sectionTransformations = [];\n    post.walkMarkerableSections(range, section => {\n      let changedSection = this.changeSectionTagName(section, tagName);\n\n      sectionTransformations.push({\n        from: section,\n        to: changedSection\n      });\n    });\n\n    let nextRange = this._determineNextRangeAfterToggleSection(range, sectionTransformations);\n    this.setRange(nextRange);\n  }\n\n  _determineNextRangeAfterToggleSection(range, sectionTransformations) {\n    if (sectionTransformations.length) {\n      let changedHeadSection = detect(sectionTransformations, ({ from }) => {\n        return from === range.headSection;\n      }).to;\n      let changedTailSection = detect(sectionTransformations, ({ from }) => {\n        return from === range.tailSection;\n      }).to;\n\n      if (changedHeadSection.isListSection || changedTailSection.isListSection) {\n        // We don't know to which ListItem's the original sections point at, so\n        // we don't have enough information to reconstruct the range when\n        // dealing with lists.\n        return sectionTransformations[0].to.headPosition().toRange();\n      } else {\n        return Range.create(\n          changedHeadSection,\n          range.headSectionOffset,\n          changedTailSection,\n          range.tailSectionOffset,\n          range.direction\n        );\n      }\n    } else {\n      return range;\n    }\n  }\n\n  setAttribute(key, value, range=this._range) {\n    this._mutateAttribute(key, range, (section, attribute) => {\n      if (section.getAttribute(attribute) !== value) {\n        section.setAttribute(attribute, value);\n        return true;\n      }\n    });\n  }\n\n  removeAttribute(key, range=this._range) {\n    this._mutateAttribute(key, range, (section, attribute) => {\n      if (section.hasAttribute(attribute)) {\n        section.removeAttribute(attribute);\n        return true;\n      }\n    });\n  }\n\n  _mutateAttribute(key, range, cb) {\n    range = toRange(range);\n    let { post } = this.editor;\n    let attribute = `data-md-${key}`;\n\n    post.walkMarkerableSections(range, section => {\n      if (section.isListItem) {\n        section = section.parent;\n      }\n\n      if (cb(section, attribute) === true) {\n        this._markDirty(section);\n      }\n    });\n\n    this.setRange(range);\n  }\n\n  _isSameSectionType(section, sectionTagName) {\n    return section.isListItem ?\n      section.parent.tagName === sectionTagName :\n      section.tagName        === sectionTagName;\n  }\n\n  /**\n   * @param {Markerable} section\n   * @private\n   */\n  changeSectionTagName(section, newTagName) {\n    assert('Cannot pass non-markerable section to `changeSectionTagName`',\n           section.isMarkerable);\n\n    if (isListSectionTagName(newTagName)) {\n      return this._changeSectionToListItem(section, newTagName);\n    } else if (section.isListItem) {\n      return this._changeSectionFromListItem(section, newTagName);\n    } else {\n      section.tagName = newTagName;\n      this._markDirty(section);\n      return section;\n    }\n  }\n\n  /**\n   * Splits the item at the position given.\n   * If the position is at the start or end of the item, the pre- or post-item\n   * will contain a single empty (\"\") marker.\n   * @param {ListItem} item\n   * @param {Position} position\n   * @return {Array} the pre-item and post-item on either side of the split\n   * @private\n   */\n  _splitListItem(item, position) {\n    let { section, offset } = position;\n    assert('Cannot split list item at position that does not include item',\n           item === section);\n\n    item.splitMarkerAtOffset(offset);\n    let prevMarker = item.markerBeforeOffset(offset);\n    let preItem  = this.builder.createListItem(),\n        postItem = this.builder.createListItem();\n\n    let currentItem = preItem;\n    item.markers.forEach(marker => {\n      currentItem.markers.append(marker.clone());\n      if (marker === prevMarker) {\n        currentItem = postItem;\n      }\n    });\n    this._replaceSection(item, [preItem, postItem]);\n    return [preItem, postItem];\n  }\n\n  /**\n   * Splits the list at the position given.\n   * @return {Array} pre-split list and post-split list, either of which could\n   * be blank (0-item list) if the position is at the start or end of the list.\n   *\n   * Note: Contiguous list sections will be joined in the before_complete queue\n   * of the postEditor.\n   *\n   * @private\n   */\n  _splitListAtPosition(list, position) {\n    assert('Cannot split list at position not in list',\n           position.section.parent === list);\n\n    let positionIsMiddle = !position.isHead() && !position.isTail();\n    if (positionIsMiddle) {\n      let item = position.section;\n      let [pre,] =\n        this._splitListItem(item, position);\n      position = pre.tailPosition();\n    }\n\n    let preList  = this.builder.createListSection(list.tagName);\n    let postList = this.builder.createListSection(list.tagName);\n\n    let preItem = position.section;\n    let currentList = preList;\n    list.items.forEach(item => {\n      // If this item matches the start item and the position is at its start,\n      // it should be appended to the postList instead of the preList\n      if (item === preItem && position.isEqual(item.headPosition())) {\n        currentList = postList;\n      }\n      currentList.items.append(item.clone());\n      // If we just appended the preItem, append the remaining items to the postList\n      if (item === preItem) {\n        currentList = postList;\n      }\n    });\n\n    this._replaceSection(list, [preList, postList]);\n    return [preList, postList];\n  }\n\n  /**\n   * @return Array of [prev, mid, next] lists. `prev` and `next` can\n   *         be blank, depending on the position of `item`. `mid` will always\n   *         be a 1-item list containing `item`. `prev` and `next` will be\n   *         removed in the before_complete queue if they are blank\n   *         (and still attached).\n   *\n   * @private\n   */\n  _splitListAtItem(list, item) {\n    let next = list;\n    let prev = this.builder.createListSection(next.tagName, [], next.attributes);\n    let mid = this.builder.createListSection(next.tagName);\n\n    let addToPrev = true;\n    // must turn the LinkedList into an array so that we can remove items\n    // as we iterate through it\n    let items = next.items.toArray();\n    items.forEach(i => {\n      let listToAppend;\n      if (i === item) {\n        addToPrev    = false;\n        listToAppend = mid;\n      } else if (addToPrev) {\n        listToAppend = prev;\n      } else {\n        return; // break after iterating prev and mid parts of the list\n      }\n      listToAppend.join(i);\n      this.removeSection(i);\n    });\n    let found = !addToPrev;\n    assert('Cannot split list at item that is not present in the list', found);\n\n    let collection = this.editor.post.sections;\n    this.insertSectionBefore(collection, mid, next);\n    this.insertSectionBefore(collection, prev, mid);\n\n    // Remove possibly blank prev/next lists\n    this.addCallback(CALLBACK_QUEUES.BEFORE_COMPLETE, () => {\n      [prev, next].forEach(_list => {\n        let isAttached = !!_list.parent;\n        if (_list.isBlank && isAttached) {\n          this.removeSection(_list);\n        }\n      });\n    });\n\n    return [prev, mid, next];\n  }\n\n  _changeSectionFromListItem(section, newTagName) {\n    assert('Must pass list item to `_changeSectionFromListItem`',\n           section.isListItem);\n\n    let listSection = section.parent;\n    let markupSection = this.builder.createMarkupSection(newTagName);\n    markupSection.join(section);\n\n    let [, mid,] = this._splitListAtItem(listSection, section);\n    this.replaceSection(mid, markupSection);\n    return markupSection;\n  }\n\n  _changeSectionToListItem(section, newTagName) {\n    let isAlreadyCorrectListItem = section.isListItem &&\n      section.parent.tagName === newTagName;\n\n    if (isAlreadyCorrectListItem) {\n      return section;\n    }\n\n    let listSection = this.builder.createListSection(newTagName);\n    listSection.join(section);\n\n    let sectionToReplace;\n    if (section.isListItem) {\n      let [, mid,] = this._splitListAtItem(section.parent, section);\n      sectionToReplace = mid;\n    } else {\n      sectionToReplace = section;\n    }\n    this.replaceSection(sectionToReplace, listSection);\n    return listSection;\n  }\n\n  /**\n   * Insert a given section before another one, updating the post abstract\n   * and the rendered UI.\n   *\n   * Usage:\n   * ```\n   *     let markerRange = editor.range;\n   *     let sectionWithCursor = markerRange.headMarker.section;\n   *     let section = editor.builder.createCardSection('my-image');\n   *     let collection = sectionWithCursor.parent.sections;\n   *     editor.run((postEditor) => {\n   *       postEditor.insertSectionBefore(collection, section, sectionWithCursor);\n   *     });\n   * ```\n   * @param {LinkedList} collection The list of sections to insert into\n   * @param {Object} section The new section\n   * @param {Object} beforeSection Optional The section \"before\" is relative to,\n   *        if falsy the new section will be appended to the collection\n   * @public\n   */\n  insertSectionBefore(collection, section, beforeSection) {\n    collection.insertBefore(section, beforeSection);\n    this._markDirty(section.parent);\n  }\n\n  /**\n   * Insert the given section after the current active section, or, if no\n   * section is active, at the end of the document.\n   * @param {Section} section\n   * @public\n   */\n  insertSection(section) {\n    const activeSection = this.editor.activeSection;\n    const nextSection = activeSection && activeSection.next;\n\n    const collection = this.editor.post.sections;\n    this.insertSectionBefore(collection, section, nextSection);\n  }\n\n  /**\n   * Insert the given section at the end of the document.\n   * @param {Section} section\n   * @public\n   */\n  insertSectionAtEnd(section) {\n    this.insertSectionBefore(this.editor.post.sections, section, null);\n  }\n\n  /**\n   * Insert the `post` at the given position in the editor's post.\n   * @param {Position} position\n   * @param {Post} post\n   * @private\n   */\n  insertPost(position, newPost) {\n    let post = this.editor.post;\n    let inserter = new Inserter(this, post);\n    let nextPosition = inserter.insert(position, newPost);\n    return nextPosition;\n  }\n\n  /**\n   * Remove a given section from the post abstract and the rendered UI.\n   *\n   * Usage:\n   * ```\n   *     let { range } = editor;\n   *     let sectionWithCursor = range.head.section;\n   *     editor.run((postEditor) => {\n   *       postEditor.removeSection(sectionWithCursor);\n   *     });\n   * ```\n   * @param {Object} section The section to remove\n   * @public\n   */\n  removeSection(section) {\n    let parent          = section.parent;\n    this._scheduleForRemoval(section);\n    parent.sections.remove(section);\n\n    if (parent.isListSection) {\n      this._scheduleListRemovalIfEmpty(parent);\n    }\n  }\n\n  removeAllSections() {\n    this.editor.post.sections.toArray().forEach(section => {\n      this.removeSection(section);\n    });\n  }\n\n  migrateSectionsFromPost(post) {\n    post.sections.toArray().forEach(section => {\n      post.sections.remove(section);\n      this.insertSectionBefore(this.editor.post.sections, section, null);\n    });\n  }\n\n  _scheduleListRemovalIfEmpty(listSection) {\n    this.addCallback(CALLBACK_QUEUES.BEFORE_COMPLETE, () => {\n      // if the list is attached and blank after we do other rendering stuff,\n      // remove it\n      let isAttached = !!listSection.parent;\n      if (isAttached && listSection.isBlank) {\n        this.removeSection(listSection);\n      }\n    });\n  }\n\n  /**\n   * A method for adding work the deferred queue\n   *\n   * @param {Function} callback to run during completion\n   * @param {Boolean} [once=false] Whether to only schedule the callback once.\n   * @public\n   */\n  schedule(callback, once=false) {\n    assert('Work can only be scheduled before a post edit has completed',\n           !this._didComplete);\n    if (once) {\n      this.addCallbackOnce(CALLBACK_QUEUES.COMPLETE, callback);\n    } else {\n      this.addCallback(CALLBACK_QUEUES.COMPLETE, callback);\n    }\n  }\n\n  /**\n   * A method for adding work the deferred queue. The callback will only\n   * be added to the queue once, even if `scheduleOnce` is called multiple times.\n   * The function cannot be an anonymous function.\n   *\n   * @param {Function} callback to run during completion\n   * @public\n   */\n  scheduleOnce(callback) {\n    this.schedule(callback, true);\n  }\n\n  /**\n   * Add a rerender job to the queue\n   *\n   * @public\n   */\n  scheduleRerender() {\n    this.scheduleOnce(this._rerender);\n  }\n\n  /**\n   * Schedule a notification that the post has been changed.\n   * The notification will result in the editor firing its `postDidChange`\n   * hook after the postEditor completes its work (at the end of {@link Editor#run}).\n   *\n   * @public\n   */\n  scheduleDidUpdate() {\n    this.scheduleOnce(this._postDidChange);\n  }\n\n  scheduleAfterRender(callback, once=false) {\n    if (once) {\n      this.addCallbackOnce(CALLBACK_QUEUES.AFTER_COMPLETE, callback);\n    } else {\n      this.addCallback(CALLBACK_QUEUES.AFTER_COMPLETE, callback);\n    }\n  }\n\n  /**\n   * Flush any work on the queue. {@link Editor#run} calls this method; it\n   * should not be called directly.\n   *\n   * @private\n   */\n  complete() {\n    assert('Post editing can only be completed once', !this._didComplete);\n\n    this.runCallbacks(CALLBACK_QUEUES.BEFORE_COMPLETE);\n    this._didComplete = true;\n    this.runCallbacks(CALLBACK_QUEUES.COMPLETE);\n    this.runCallbacks(CALLBACK_QUEUES.AFTER_COMPLETE);\n  }\n\n  undoLastChange() {\n    this.editor._editHistory.stepBackward(this);\n  }\n\n  redoLastChange() {\n    this.editor._editHistory.stepForward(this);\n  }\n\n  cancelSnapshot() {\n    this._shouldCancelSnapshot = true;\n  }\n}\n\nconst placeholderImageSrc = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAMFBMVEXp7vG6vsHm6+63u77Hy868wMPe4+bO09bh5unr8fTR1djAxMfM0NPX3N/c4eTBxcjXRf5TAAACh0lEQVR4nO3b6ZKqMBSFUSQMYZL3f9tbBq/NEEDiqUqOfusn1ZXKbjcQlGQZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACC6RkbsGHuabChEtHmiGYfS3EQYM+Sxw/gMQvmcNnYaj6oTDHi73WPn2eqnj9B8zo3TJXcq5uNjXmVff86VwSR3JtryMa1BYqi7S1hJDCVpSigyLcGhJJEwzlCSNtPKrbVhVwsdCfOhH7uuaG3ARV9DwsaOzxt3N1yPqCHhvXytTUz92VDpmE/LLhZwl++R6Sds6sUa/PL6K/2E2fIhw1xdRKefsFolrPc+xNx/N0k/4fpBsdhL2HfeiN+TsDCms8dDpeRyS3P3QDl6Iqaf8L0rTf+80m6Lmn7Ct+4Wxf+/2RY1/YRv3PHz/u+fsCmqgoTnq7Z+8SGviqoh4dnKu1ieqauiakh4/PQ0r6ivqDoSHj0B97eNRVG1JNxV+L4bnxdVecJtRTdFVZ7QU9F1UXUn9FZ0VVRlCav5ob2KLouqKmFjy676u2HsVnRRVFUJq3J+8KCi86IqSthMvyl209Hjijqm3RsqAZ5pNfa5PJ2KelJRjQmr1/r7cfy0ouoSNvOfvbvhvKLaEr4qOin9kTQnrN7LpDZhE/Zmhp6Eq4p+YcKgiipKGFhRRQkDK6ooYfgLbiSMioQkJGF8P5XwHv4O+7AaKiXzaeXh1kMl5AffTUxiKEm/krD94BR8Gdxl1fceSlR58ZhXKbEpyD2amNiBtmrJLTMHL1LF8/rpXkSZXEmz8K8uvAFFNm6Iq0aBLUFOmeCuJ6exrcCmoLpN7kYx891bSAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgh/wDdr8peyRHLogAAAAASUVORK5CYII=\";\n\nvar ImageCard = {\n  name: 'image',\n  type: 'dom',\n\n  render({payload}) {\n    let img = document.createElement('img');\n    img.src = payload.src || placeholderImageSrc;\n    return img;\n  }\n};\n\nfunction visit(visitor, node, opcodes) {\n  const method = node.type;\n  assert(`Cannot visit unknown type ${method}`, !!visitor[method]);\n  visitor[method](node, opcodes);\n}\n\nfunction compile(compiler, opcodes) {\n  for (var i=0, l=opcodes.length; i<l; i++) {\n    let [method, ...params] = opcodes[i];\n    let length = params.length;\n    if (length === 0) {\n      compiler[method].call(compiler);\n    } else if (length === 1) {\n      compiler[method].call(compiler, params[0]);\n    } else if (length === 2) {\n      compiler[method].call(compiler, params[0], params[1]);\n    } else {\n      compiler[method].apply(compiler, params);\n    }\n  }\n}\n\nfunction visitArray(visitor, nodes, opcodes) {\n  if (!nodes || nodes.length === 0) {\n    return;\n  }\n  forEach(nodes, node => {\n    visit(visitor, node, opcodes);\n  });\n}\n\nconst MOBILEDOC_VERSION = '0.2.0';\nconst MOBILEDOC_MARKUP_SECTION_TYPE = 1;\nconst MOBILEDOC_IMAGE_SECTION_TYPE = 2;\nconst MOBILEDOC_LIST_SECTION_TYPE = 3;\nconst MOBILEDOC_CARD_SECTION_TYPE = 10;\n\nconst visitor = {\n  [POST_TYPE](node, opcodes) {\n    opcodes.push(['openPost']);\n    visitArray(visitor, node.sections, opcodes);\n  },\n  [MARKUP_SECTION_TYPE](node, opcodes) {\n    opcodes.push(['openMarkupSection', node.tagName]);\n    visitArray(visitor, node.markers, opcodes);\n  },\n  [LIST_SECTION_TYPE](node, opcodes) {\n    opcodes.push(['openListSection', node.tagName]);\n    visitArray(visitor, node.items, opcodes);\n  },\n  [LIST_ITEM_TYPE](node, opcodes) {\n    opcodes.push(['openListItem']);\n    visitArray(visitor, node.markers, opcodes);\n  },\n  [IMAGE_SECTION_TYPE](node, opcodes) {\n    opcodes.push(['openImageSection', node.src]);\n  },\n  [CARD_TYPE](node, opcodes) {\n    opcodes.push(['openCardSection', node.name, node.payload]);\n  },\n  [MARKER_TYPE](node, opcodes) {\n    opcodes.push(['openMarker', node.closedMarkups.length, node.value]);\n    visitArray(visitor, node.openedMarkups, opcodes);\n  },\n  [MARKUP_TYPE](node, opcodes) {\n    opcodes.push(['openMarkup', node.tagName, objectToSortedKVArray(node.attributes)]);\n  }\n};\n\nconst postOpcodeCompiler = {\n  openMarker(closeCount, value) {\n    this.markupMarkerIds = [];\n    this.markers.push([\n      this.markupMarkerIds,\n      closeCount,\n      value || ''\n    ]);\n  },\n  openMarkupSection(tagName) {\n    this.markers = [];\n    this.sections.push([MOBILEDOC_MARKUP_SECTION_TYPE, tagName, this.markers]);\n  },\n  openListSection(tagName) {\n    this.items = [];\n    this.sections.push([MOBILEDOC_LIST_SECTION_TYPE, tagName, this.items]);\n  },\n  openListItem() {\n    this.markers = [];\n    this.items.push(this.markers);\n  },\n  openImageSection(url) {\n    this.sections.push([MOBILEDOC_IMAGE_SECTION_TYPE, url]);\n  },\n  openCardSection(name, payload) {\n    this.sections.push([MOBILEDOC_CARD_SECTION_TYPE, name, payload]);\n  },\n  openPost() {\n    this.markerTypes = [];\n    this.sections = [];\n    this.result = {\n      version: MOBILEDOC_VERSION,\n      sections: [this.markerTypes, this.sections]\n    };\n  },\n  openMarkup(tagName, attributes) {\n    const index = this._findOrAddMarkerTypeIndex(tagName, attributes);\n    this.markupMarkerIds.push(index);\n  },\n  _findOrAddMarkerTypeIndex(tagName, attributesArray) {\n    if (!this._markerTypeCache) { this._markerTypeCache = {}; }\n    const key = `${tagName}-${attributesArray.join('-')}`;\n\n    let index = this._markerTypeCache[key];\n    if (index === undefined) {\n      let markerType = [tagName];\n      if (attributesArray.length) { markerType.push(attributesArray); }\n      this.markerTypes.push(markerType);\n\n      index =  this.markerTypes.length - 1;\n      this._markerTypeCache[key] = index;\n    }\n\n    return index;\n  }\n};\n\n/**\n * Render from post -> mobiledoc\n */\nvar MobiledocRenderer_0_2 = {\n  /**\n   * @param {Post}\n   * @return {Mobiledoc}\n   */\n  render(post) {\n    let opcodes = [];\n    visit(visitor, post, opcodes);\n    let compiler = Object.create(postOpcodeCompiler);\n    compile(compiler, opcodes);\n    return compiler.result;\n  }\n};\n\n/*\n * Parses from mobiledoc -> post\n */\nclass MobiledocParser {\n  constructor(builder) {\n    this.builder = builder;\n  }\n\n  /**\n   * @param {Mobiledoc}\n   * @return {Post}\n   */\n  parse({sections: sectionData}) {\n    try {\n      const markerTypes = sectionData[0];\n      const sections    = sectionData[1];\n\n      const post = this.builder.createPost();\n\n      this.markups = [];\n      this.markerTypes = this.parseMarkerTypes(markerTypes);\n      this.parseSections(sections, post);\n\n      return post;\n    } catch (e) {\n      assert(`Unable to parse mobiledoc: ${e.message}`, false);\n    }\n  }\n\n  parseMarkerTypes(markerTypes) {\n    return markerTypes.map((markerType) => this.parseMarkerType(markerType));\n  }\n\n  parseMarkerType([tagName, attributesArray]) {\n    const attributesObject = kvArrayToObject(attributesArray || []);\n    return this.builder.createMarkup(tagName, attributesObject);\n  }\n\n  parseSections(sections, post) {\n    sections.forEach((section) => this.parseSection(section, post));\n  }\n\n  parseSection(section, post) {\n    let [type] = section;\n    switch(type) {\n      case MOBILEDOC_MARKUP_SECTION_TYPE:\n        this.parseMarkupSection(section, post);\n        break;\n      case MOBILEDOC_IMAGE_SECTION_TYPE:\n        this.parseImageSection(section, post);\n        break;\n      case MOBILEDOC_CARD_SECTION_TYPE:\n        this.parseCardSection(section, post);\n        break;\n      case MOBILEDOC_LIST_SECTION_TYPE:\n        this.parseListSection(section, post);\n        break;\n      default:\n        assert(`Unexpected section type ${type}`, false);\n    }\n  }\n\n  parseCardSection([, name, payload], post) {\n    const section = this.builder.createCardSection(name, payload);\n    post.sections.append(section);\n  }\n\n  parseImageSection([, src], post) {\n    const section = this.builder.createImageSection(src);\n    post.sections.append(section);\n  }\n\n  parseMarkupSection([, tagName, markers], post) {\n    const section = this.builder.createMarkupSection(tagName.toLowerCase() === 'pull-quote' ? 'aside' : tagName);\n    post.sections.append(section);\n    this.parseMarkers(markers, section);\n    // Strip blank markers after they have been created. This ensures any\n    // markup they include has been correctly populated.\n    filter(section.markers, m => m.isBlank).forEach(m => {\n      section.markers.remove(m);\n    });\n  }\n\n  parseListSection([, tagName, items], post) {\n    const section = this.builder.createListSection(tagName);\n    post.sections.append(section);\n    this.parseListItems(items, section);\n  }\n\n  parseListItems(items, section) {\n    items.forEach(i => this.parseListItem(i, section));\n  }\n\n  parseListItem(markers, section) {\n    const item = this.builder.createListItem();\n    this.parseMarkers(markers, item);\n    section.items.append(item);\n  }\n\n  parseMarkers(markers, parent) {\n    markers.forEach(m => this.parseMarker(m, parent));\n  }\n\n  parseMarker([markerTypeIndexes, closeCount, value], parent) {\n    markerTypeIndexes.forEach(index => {\n      this.markups.push(this.markerTypes[index]);\n    });\n    const marker = this.builder.createMarker(value, this.markups.slice());\n    parent.markers.append(marker);\n    this.markups = this.markups.slice(0, this.markups.length-closeCount);\n  }\n}\n\nconst MOBILEDOC_VERSION$1 = '0.3.0';\nconst MOBILEDOC_MARKUP_SECTION_TYPE$1 = 1;\nconst MOBILEDOC_IMAGE_SECTION_TYPE$1 = 2;\nconst MOBILEDOC_LIST_SECTION_TYPE$1 = 3;\nconst MOBILEDOC_CARD_SECTION_TYPE$1 = 10;\n\nconst MOBILEDOC_MARKUP_MARKER_TYPE = 0;\nconst MOBILEDOC_ATOM_MARKER_TYPE = 1;\n\nconst visitor$1 = {\n  [POST_TYPE](node, opcodes) {\n    opcodes.push(['openPost']);\n    visitArray(visitor$1, node.sections, opcodes);\n  },\n  [MARKUP_SECTION_TYPE](node, opcodes) {\n    opcodes.push(['openMarkupSection', node.tagName]);\n    visitArray(visitor$1, node.markers, opcodes);\n  },\n  [LIST_SECTION_TYPE](node, opcodes) {\n    opcodes.push(['openListSection', node.tagName]);\n    visitArray(visitor$1, node.items, opcodes);\n  },\n  [LIST_ITEM_TYPE](node, opcodes) {\n    opcodes.push(['openListItem']);\n    visitArray(visitor$1, node.markers, opcodes);\n  },\n  [IMAGE_SECTION_TYPE](node, opcodes) {\n    opcodes.push(['openImageSection', node.src]);\n  },\n  [CARD_TYPE](node, opcodes) {\n    opcodes.push(['openCardSection', node.name, node.payload]);\n  },\n  [MARKER_TYPE](node, opcodes) {\n    opcodes.push(['openMarker', node.closedMarkups.length, node.value]);\n    visitArray(visitor$1, node.openedMarkups, opcodes);\n  },\n  [MARKUP_TYPE](node, opcodes) {\n    opcodes.push(['openMarkup', node.tagName, objectToSortedKVArray(node.attributes)]);\n  },\n  [ATOM_TYPE](node, opcodes) {\n    opcodes.push(['openAtom', node.closedMarkups.length, node.name, node.value, node.payload]);\n    visitArray(visitor$1, node.openedMarkups, opcodes);\n  }\n};\n\nconst postOpcodeCompiler$1 = {\n  openMarker(closeCount, value) {\n    this.markupMarkerIds = [];\n    this.markers.push([\n      MOBILEDOC_MARKUP_MARKER_TYPE,\n      this.markupMarkerIds,\n      closeCount,\n      value || ''\n    ]);\n  },\n  openMarkupSection(tagName) {\n    this.markers = [];\n    this.sections.push([MOBILEDOC_MARKUP_SECTION_TYPE$1, tagName, this.markers]);\n  },\n  openListSection(tagName) {\n    this.items = [];\n    this.sections.push([MOBILEDOC_LIST_SECTION_TYPE$1, tagName, this.items]);\n  },\n  openListItem() {\n    this.markers = [];\n    this.items.push(this.markers);\n  },\n  openImageSection(url) {\n    this.sections.push([MOBILEDOC_IMAGE_SECTION_TYPE$1, url]);\n  },\n  openCardSection(name, payload) {\n    const index = this._addCardTypeIndex(name, payload);\n    this.sections.push([MOBILEDOC_CARD_SECTION_TYPE$1, index]);\n  },\n  openAtom(closeCount, name, value, payload) {\n    const index = this._addAtomTypeIndex(name, value, payload);\n    this.markupMarkerIds = [];\n    this.markers.push([\n      MOBILEDOC_ATOM_MARKER_TYPE,\n      this.markupMarkerIds,\n      closeCount,\n      index\n    ]);\n  },\n  openPost() {\n    this.atomTypes = [];\n    this.cardTypes = [];\n    this.markerTypes = [];\n    this.sections = [];\n    this.result = {\n      version: MOBILEDOC_VERSION$1,\n      atoms: this.atomTypes,\n      cards: this.cardTypes,\n      markups: this.markerTypes,\n      sections: this.sections\n    };\n  },\n  openMarkup(tagName, attributes) {\n    const index = this._findOrAddMarkerTypeIndex(tagName, attributes);\n    this.markupMarkerIds.push(index);\n  },\n  _addCardTypeIndex(cardName, payload) {\n    let cardType = [cardName, payload];\n    this.cardTypes.push(cardType);\n    return this.cardTypes.length - 1;\n  },\n  _addAtomTypeIndex(atomName, atomValue, payload) {\n    let atomType = [atomName, atomValue, payload];\n    this.atomTypes.push(atomType);\n    return this.atomTypes.length - 1;\n  },\n  _findOrAddMarkerTypeIndex(tagName, attributesArray) {\n    if (!this._markerTypeCache) { this._markerTypeCache = {}; }\n    const key = `${tagName}-${attributesArray.join('-')}`;\n\n    let index = this._markerTypeCache[key];\n    if (index === undefined) {\n      let markerType = [tagName];\n      if (attributesArray.length) { markerType.push(attributesArray); }\n      this.markerTypes.push(markerType);\n\n      index =  this.markerTypes.length - 1;\n      this._markerTypeCache[key] = index;\n    }\n\n    return index;\n  }\n};\n\n/**\n * Render from post -> mobiledoc\n */\nvar MobiledocRenderer_0_3 = {\n  /**\n   * @param {Post}\n   * @return {Mobiledoc}\n   */\n  render(post) {\n    let opcodes = [];\n    visit(visitor$1, post, opcodes);\n    let compiler = Object.create(postOpcodeCompiler$1);\n    compile(compiler, opcodes);\n    return compiler.result;\n  }\n};\n\n/*\n * Parses from mobiledoc -> post\n */\nclass MobiledocParser$1 {\n  constructor(builder) {\n    this.builder = builder;\n  }\n\n  /**\n   * @param {Mobiledoc}\n   * @return {Post}\n   */\n  parse({ sections, markups: markerTypes, cards: cardTypes, atoms: atomTypes }) {\n    try {\n      const post = this.builder.createPost();\n\n      this.markups = [];\n      this.markerTypes = this.parseMarkerTypes(markerTypes);\n      this.cardTypes = this.parseCardTypes(cardTypes);\n      this.atomTypes = this.parseAtomTypes(atomTypes);\n      this.parseSections(sections, post);\n\n      return post;\n    } catch (e) {\n      assert(`Unable to parse mobiledoc: ${e.message}`, false);\n    }\n  }\n\n  parseMarkerTypes(markerTypes) {\n    return markerTypes.map((markerType) => this.parseMarkerType(markerType));\n  }\n\n  parseMarkerType([tagName, attributesArray]) {\n    const attributesObject = kvArrayToObject(attributesArray || []);\n    return this.builder.createMarkup(tagName, attributesObject);\n  }\n\n  parseCardTypes(cardTypes) {\n    return cardTypes.map((cardType) => this.parseCardType(cardType));\n  }\n\n  parseCardType([cardName, cardPayload]) {\n    return [cardName, cardPayload];\n  }\n\n  parseAtomTypes(atomTypes) {\n    return atomTypes.map((atomType) => this.parseAtomType(atomType));\n  }\n\n  parseAtomType([atomName, atomValue, atomPayload]) {\n    return [atomName, atomValue, atomPayload];\n  }\n\n  parseSections(sections, post) {\n    sections.forEach((section) => this.parseSection(section, post));\n  }\n\n  parseSection(section, post) {\n    let [type] = section;\n    switch(type) {\n      case MOBILEDOC_MARKUP_SECTION_TYPE$1:\n        this.parseMarkupSection(section, post);\n        break;\n      case MOBILEDOC_IMAGE_SECTION_TYPE$1:\n        this.parseImageSection(section, post);\n        break;\n      case MOBILEDOC_CARD_SECTION_TYPE$1:\n        this.parseCardSection(section, post);\n        break;\n      case MOBILEDOC_LIST_SECTION_TYPE$1:\n        this.parseListSection(section, post);\n        break;\n      default:\n        assert('Unexpected section type ${type}', false);\n    }\n  }\n\n  getAtomTypeFromIndex(index) {\n    const atomType = this.atomTypes[index];\n    assert(`No atom definition found at index ${index}`, !!atomType);\n    return atomType;\n  }\n\n  getCardTypeFromIndex(index) {\n    const cardType = this.cardTypes[index];\n    assert(`No card definition found at index ${index}`, !!cardType);\n    return cardType;\n  }\n\n  parseCardSection([, cardIndex], post) {\n    const [name, payload] = this.getCardTypeFromIndex(cardIndex);\n    const section = this.builder.createCardSection(name, payload);\n    post.sections.append(section);\n  }\n\n  parseImageSection([, src], post) {\n    const section = this.builder.createImageSection(src);\n    post.sections.append(section);\n  }\n\n  parseMarkupSection([, tagName, markers], post) {\n    const section = this.builder.createMarkupSection(tagName.toLowerCase() === 'pull-quote' ? 'aside' : tagName);\n    post.sections.append(section);\n    this.parseMarkers(markers, section);\n    // Strip blank markers after they have been created. This ensures any\n    // markup they include has been correctly populated.\n    filter(section.markers, m => m.isBlank).forEach(m => {\n      section.markers.remove(m);\n    });\n  }\n\n  parseListSection([, tagName, items], post) {\n    const section = this.builder.createListSection(tagName);\n    post.sections.append(section);\n    this.parseListItems(items, section);\n  }\n\n  parseListItems(items, section) {\n    items.forEach(i => this.parseListItem(i, section));\n  }\n\n  parseListItem(markers, section) {\n    const item = this.builder.createListItem();\n    this.parseMarkers(markers, item);\n    section.items.append(item);\n  }\n\n  parseMarkers(markers, parent) {\n    markers.forEach(m => this.parseMarker(m, parent));\n  }\n\n  parseMarker([type, markerTypeIndexes, closeCount, value], parent) {\n    markerTypeIndexes.forEach(index => {\n      this.markups.push(this.markerTypes[index]);\n    });\n\n    const marker = this.buildMarkerType(type, value);\n    parent.markers.append(marker);\n\n    this.markups = this.markups.slice(0, this.markups.length-closeCount);\n  }\n\n  buildMarkerType(type, value) {\n    switch (type) {\n      case MOBILEDOC_MARKUP_MARKER_TYPE:\n        return this.builder.createMarker(value, this.markups.slice());\n      case MOBILEDOC_ATOM_MARKER_TYPE: {\n        const [atomName, atomValue, atomPayload] = this.getAtomTypeFromIndex(value);\n        return this.builder.createAtom(atomName, atomValue, atomPayload, this.markups.slice());\n      }\n      default:\n        assert(`Unexpected marker type ${type}`, false);\n    }\n  }\n}\n\nconst MOBILEDOC_VERSION$2 = '0.3.1';\nconst MOBILEDOC_MARKUP_SECTION_TYPE$2 = 1;\nconst MOBILEDOC_IMAGE_SECTION_TYPE$2 = 2;\nconst MOBILEDOC_LIST_SECTION_TYPE$2 = 3;\nconst MOBILEDOC_CARD_SECTION_TYPE$2 = 10;\n\nconst MOBILEDOC_MARKUP_MARKER_TYPE$1 = 0;\nconst MOBILEDOC_ATOM_MARKER_TYPE$1 = 1;\n\nconst visitor$2 = {\n  [POST_TYPE](node, opcodes) {\n    opcodes.push(['openPost']);\n    visitArray(visitor$2, node.sections, opcodes);\n  },\n  [MARKUP_SECTION_TYPE](node, opcodes) {\n    opcodes.push(['openMarkupSection', node.tagName]);\n    visitArray(visitor$2, node.markers, opcodes);\n  },\n  [LIST_SECTION_TYPE](node, opcodes) {\n    opcodes.push(['openListSection', node.tagName]);\n    visitArray(visitor$2, node.items, opcodes);\n  },\n  [LIST_ITEM_TYPE](node, opcodes) {\n    opcodes.push(['openListItem']);\n    visitArray(visitor$2, node.markers, opcodes);\n  },\n  [IMAGE_SECTION_TYPE](node, opcodes) {\n    opcodes.push(['openImageSection', node.src]);\n  },\n  [CARD_TYPE](node, opcodes) {\n    opcodes.push(['openCardSection', node.name, node.payload]);\n  },\n  [MARKER_TYPE](node, opcodes) {\n    opcodes.push(['openMarker', node.closedMarkups.length, node.value]);\n    visitArray(visitor$2, node.openedMarkups, opcodes);\n  },\n  [MARKUP_TYPE](node, opcodes) {\n    opcodes.push(['openMarkup', node.tagName, objectToSortedKVArray(node.attributes)]);\n  },\n  [ATOM_TYPE](node, opcodes) {\n    opcodes.push(['openAtom', node.closedMarkups.length, node.name, node.value, node.payload]);\n    visitArray(visitor$2, node.openedMarkups, opcodes);\n  }\n};\n\nconst postOpcodeCompiler$2 = {\n  openMarker(closeCount, value) {\n    this.markupMarkerIds = [];\n    this.markers.push([\n      MOBILEDOC_MARKUP_MARKER_TYPE$1,\n      this.markupMarkerIds,\n      closeCount,\n      value || ''\n    ]);\n  },\n  openMarkupSection(tagName) {\n    this.markers = [];\n    this.sections.push([MOBILEDOC_MARKUP_SECTION_TYPE$2, tagName, this.markers]);\n  },\n  openListSection(tagName) {\n    this.items = [];\n    this.sections.push([MOBILEDOC_LIST_SECTION_TYPE$2, tagName, this.items]);\n  },\n  openListItem() {\n    this.markers = [];\n    this.items.push(this.markers);\n  },\n  openImageSection(url) {\n    this.sections.push([MOBILEDOC_IMAGE_SECTION_TYPE$2, url]);\n  },\n  openCardSection(name, payload) {\n    const index = this._addCardTypeIndex(name, payload);\n    this.sections.push([MOBILEDOC_CARD_SECTION_TYPE$2, index]);\n  },\n  openAtom(closeCount, name, value, payload) {\n    const index = this._addAtomTypeIndex(name, value, payload);\n    this.markupMarkerIds = [];\n    this.markers.push([\n      MOBILEDOC_ATOM_MARKER_TYPE$1,\n      this.markupMarkerIds,\n      closeCount,\n      index\n    ]);\n  },\n  openPost() {\n    this.atomTypes = [];\n    this.cardTypes = [];\n    this.markerTypes = [];\n    this.sections = [];\n    this.result = {\n      version: MOBILEDOC_VERSION$2,\n      atoms: this.atomTypes,\n      cards: this.cardTypes,\n      markups: this.markerTypes,\n      sections: this.sections\n    };\n  },\n  openMarkup(tagName, attributes) {\n    const index = this._findOrAddMarkerTypeIndex(tagName, attributes);\n    this.markupMarkerIds.push(index);\n  },\n  _addCardTypeIndex(cardName, payload) {\n    let cardType = [cardName, payload];\n    this.cardTypes.push(cardType);\n    return this.cardTypes.length - 1;\n  },\n  _addAtomTypeIndex(atomName, atomValue, payload) {\n    let atomType = [atomName, atomValue, payload];\n    this.atomTypes.push(atomType);\n    return this.atomTypes.length - 1;\n  },\n  _findOrAddMarkerTypeIndex(tagName, attributesArray) {\n    if (!this._markerTypeCache) { this._markerTypeCache = {}; }\n    const key = `${tagName}-${attributesArray.join('-')}`;\n\n    let index = this._markerTypeCache[key];\n    if (index === undefined) {\n      let markerType = [tagName];\n      if (attributesArray.length) { markerType.push(attributesArray); }\n      this.markerTypes.push(markerType);\n\n      index =  this.markerTypes.length - 1;\n      this._markerTypeCache[key] = index;\n    }\n\n    return index;\n  }\n};\n\n/**\n * Render from post -> mobiledoc\n */\nvar MobiledocRenderer_0_3_1 = {\n  /**\n   * @param {Post}\n   * @return {Mobiledoc}\n   */\n  render(post) {\n    let opcodes = [];\n    visit(visitor$2, post, opcodes);\n    let compiler = Object.create(postOpcodeCompiler$2);\n    compile(compiler, opcodes);\n    return compiler.result;\n  }\n};\n\n/*\n * Parses from mobiledoc -> post\n */\nclass MobiledocParser$2 {\n  constructor(builder) {\n    this.builder = builder;\n  }\n\n  /**\n   * @param {Mobiledoc}\n   * @return {Post}\n   */\n  parse({ sections, markups: markerTypes, cards: cardTypes, atoms: atomTypes }) {\n    try {\n      const post = this.builder.createPost();\n\n      this.markups = [];\n      this.markerTypes = this.parseMarkerTypes(markerTypes);\n      this.cardTypes = this.parseCardTypes(cardTypes);\n      this.atomTypes = this.parseAtomTypes(atomTypes);\n      this.parseSections(sections, post);\n\n      return post;\n    } catch (e) {\n      assert(`Unable to parse mobiledoc: ${e.message}`, false);\n    }\n  }\n\n  parseMarkerTypes(markerTypes) {\n    return markerTypes.map((markerType) => this.parseMarkerType(markerType));\n  }\n\n  parseMarkerType([tagName, attributesArray]) {\n    const attributesObject = kvArrayToObject(attributesArray || []);\n    return this.builder.createMarkup(tagName, attributesObject);\n  }\n\n  parseCardTypes(cardTypes) {\n    return cardTypes.map((cardType) => this.parseCardType(cardType));\n  }\n\n  parseCardType([cardName, cardPayload]) {\n    return [cardName, cardPayload];\n  }\n\n  parseAtomTypes(atomTypes) {\n    return atomTypes.map((atomType) => this.parseAtomType(atomType));\n  }\n\n  parseAtomType([atomName, atomValue, atomPayload]) {\n    return [atomName, atomValue, atomPayload];\n  }\n\n  parseSections(sections, post) {\n    sections.forEach((section) => this.parseSection(section, post));\n  }\n\n  parseSection(section, post) {\n    let [type] = section;\n    switch(type) {\n      case MOBILEDOC_MARKUP_SECTION_TYPE$2:\n        this.parseMarkupSection(section, post);\n        break;\n      case MOBILEDOC_IMAGE_SECTION_TYPE$2:\n        this.parseImageSection(section, post);\n        break;\n      case MOBILEDOC_CARD_SECTION_TYPE$2:\n        this.parseCardSection(section, post);\n        break;\n      case MOBILEDOC_LIST_SECTION_TYPE$2:\n        this.parseListSection(section, post);\n        break;\n      default:\n        assert('Unexpected section type ${type}', false);\n    }\n  }\n\n  getAtomTypeFromIndex(index) {\n    const atomType = this.atomTypes[index];\n    assert(`No atom definition found at index ${index}`, !!atomType);\n    return atomType;\n  }\n\n  getCardTypeFromIndex(index) {\n    const cardType = this.cardTypes[index];\n    assert(`No card definition found at index ${index}`, !!cardType);\n    return cardType;\n  }\n\n  parseCardSection([, cardIndex], post) {\n    const [name, payload] = this.getCardTypeFromIndex(cardIndex);\n    const section = this.builder.createCardSection(name, payload);\n    post.sections.append(section);\n  }\n\n  parseImageSection([, src], post) {\n    const section = this.builder.createImageSection(src);\n    post.sections.append(section);\n  }\n\n  parseMarkupSection([, tagName, markers], post) {\n    const section = this.builder.createMarkupSection(tagName);\n    post.sections.append(section);\n    this.parseMarkers(markers, section);\n    // Strip blank markers after they have been created. This ensures any\n    // markup they include has been correctly populated.\n    filter(section.markers, m => m.isBlank).forEach(m => {\n      section.markers.remove(m);\n    });\n  }\n\n  parseListSection([, tagName, items], post) {\n    const section = this.builder.createListSection(tagName);\n    post.sections.append(section);\n    this.parseListItems(items, section);\n  }\n\n  parseListItems(items, section) {\n    items.forEach(i => this.parseListItem(i, section));\n  }\n\n  parseListItem(markers, section) {\n    const item = this.builder.createListItem();\n    this.parseMarkers(markers, item);\n    section.items.append(item);\n  }\n\n  parseMarkers(markers, parent) {\n    markers.forEach(m => this.parseMarker(m, parent));\n  }\n\n  parseMarker([type, markerTypeIndexes, closeCount, value], parent) {\n    markerTypeIndexes.forEach(index => {\n      this.markups.push(this.markerTypes[index]);\n    });\n\n    const marker = this.buildMarkerType(type, value);\n    parent.markers.append(marker);\n\n    this.markups = this.markups.slice(0, this.markups.length-closeCount);\n  }\n\n  buildMarkerType(type, value) {\n    switch (type) {\n      case MOBILEDOC_MARKUP_MARKER_TYPE$1:\n        return this.builder.createMarker(value, this.markups.slice());\n      case MOBILEDOC_ATOM_MARKER_TYPE$1: {\n        const [atomName, atomValue, atomPayload] = this.getAtomTypeFromIndex(value);\n        return this.builder.createAtom(atomName, atomValue, atomPayload, this.markups.slice());\n      }\n      default:\n        assert(`Unexpected marker type ${type}`, false);\n    }\n  }\n}\n\nconst MOBILEDOC_VERSION$3 = '0.3.2';\nconst MOBILEDOC_MARKUP_SECTION_TYPE$3 = 1;\nconst MOBILEDOC_IMAGE_SECTION_TYPE$3 = 2;\nconst MOBILEDOC_LIST_SECTION_TYPE$3 = 3;\nconst MOBILEDOC_CARD_SECTION_TYPE$3 = 10;\n\nconst MOBILEDOC_MARKUP_MARKER_TYPE$2 = 0;\nconst MOBILEDOC_ATOM_MARKER_TYPE$2 = 1;\n\nconst visitor$3 = {\n  [POST_TYPE](node, opcodes) {\n    opcodes.push(['openPost']);\n    visitArray(visitor$3, node.sections, opcodes);\n  },\n  [MARKUP_SECTION_TYPE](node, opcodes) {\n    opcodes.push(['openMarkupSection', node.tagName, objectToSortedKVArray(node.attributes)]);\n    visitArray(visitor$3, node.markers, opcodes);\n  },\n  [LIST_SECTION_TYPE](node, opcodes) {\n    opcodes.push(['openListSection', node.tagName, objectToSortedKVArray(node.attributes)]);\n    visitArray(visitor$3, node.items, opcodes);\n  },\n  [LIST_ITEM_TYPE](node, opcodes) {\n    opcodes.push(['openListItem']);\n    visitArray(visitor$3, node.markers, opcodes);\n  },\n  [IMAGE_SECTION_TYPE](node, opcodes) {\n    opcodes.push(['openImageSection', node.src]);\n  },\n  [CARD_TYPE](node, opcodes) {\n    opcodes.push(['openCardSection', node.name, node.payload]);\n  },\n  [MARKER_TYPE](node, opcodes) {\n    opcodes.push(['openMarker', node.closedMarkups.length, node.value]);\n    visitArray(visitor$3, node.openedMarkups, opcodes);\n  },\n  [MARKUP_TYPE](node, opcodes) {\n    opcodes.push(['openMarkup', node.tagName, objectToSortedKVArray(node.attributes)]);\n  },\n  [ATOM_TYPE](node, opcodes) {\n    opcodes.push(['openAtom', node.closedMarkups.length, node.name, node.value, node.payload]);\n    visitArray(visitor$3, node.openedMarkups, opcodes);\n  }\n};\n\nconst postOpcodeCompiler$3 = {\n  openMarker(closeCount, value) {\n    this.markupMarkerIds = [];\n    this.markers.push([\n      MOBILEDOC_MARKUP_MARKER_TYPE$2,\n      this.markupMarkerIds,\n      closeCount,\n      value || ''\n    ]);\n  },\n  openMarkupSection(tagName, attributes) {\n    this.markers = [];\n    if (attributes && attributes.length !== 0) {\n      this.sections.push([MOBILEDOC_MARKUP_SECTION_TYPE$3, tagName, this.markers, attributes]);\n    } else {\n      this.sections.push([MOBILEDOC_MARKUP_SECTION_TYPE$3, tagName, this.markers]);\n    }\n  },\n  openListSection(tagName, attributes) {\n    this.items = [];\n    if (attributes && attributes.length !== 0) {\n      this.sections.push([MOBILEDOC_LIST_SECTION_TYPE$3, tagName, this.items, attributes]);\n    } else {\n      this.sections.push([MOBILEDOC_LIST_SECTION_TYPE$3, tagName, this.items]);\n    }\n  },\n  openListItem() {\n    this.markers = [];\n    this.items.push(this.markers);\n  },\n  openImageSection(url) {\n    this.sections.push([MOBILEDOC_IMAGE_SECTION_TYPE$3, url]);\n  },\n  openCardSection(name, payload) {\n    const index = this._addCardTypeIndex(name, payload);\n    this.sections.push([MOBILEDOC_CARD_SECTION_TYPE$3, index]);\n  },\n  openAtom(closeCount, name, value, payload) {\n    const index = this._addAtomTypeIndex(name, value, payload);\n    this.markupMarkerIds = [];\n    this.markers.push([\n      MOBILEDOC_ATOM_MARKER_TYPE$2,\n      this.markupMarkerIds,\n      closeCount,\n      index\n    ]);\n  },\n  openPost() {\n    this.atomTypes = [];\n    this.cardTypes = [];\n    this.markerTypes = [];\n    this.sections = [];\n    this.result = {\n      version: MOBILEDOC_VERSION$3,\n      atoms: this.atomTypes,\n      cards: this.cardTypes,\n      markups: this.markerTypes,\n      sections: this.sections\n    };\n  },\n  openMarkup(tagName, attributes) {\n    const index = this._findOrAddMarkerTypeIndex(tagName, attributes);\n    this.markupMarkerIds.push(index);\n  },\n  _addCardTypeIndex(cardName, payload) {\n    let cardType = [cardName, payload];\n    this.cardTypes.push(cardType);\n    return this.cardTypes.length - 1;\n  },\n  _addAtomTypeIndex(atomName, atomValue, payload) {\n    let atomType = [atomName, atomValue, payload];\n    this.atomTypes.push(atomType);\n    return this.atomTypes.length - 1;\n  },\n  _findOrAddMarkerTypeIndex(tagName, attributesArray) {\n    if (!this._markerTypeCache) { this._markerTypeCache = {}; }\n    const key = `${tagName}-${attributesArray.join('-')}`;\n\n    let index = this._markerTypeCache[key];\n    if (index === undefined) {\n      let markerType = [tagName];\n      if (attributesArray.length) { markerType.push(attributesArray); }\n      this.markerTypes.push(markerType);\n\n      index =  this.markerTypes.length - 1;\n      this._markerTypeCache[key] = index;\n    }\n\n    return index;\n  }\n};\n\n/**\n * Render from post -> mobiledoc\n */\nvar MobiledocRenderer_0_3_2 = {\n  /**\n   * @param {Post}\n   * @return {Mobiledoc}\n   */\n  render(post) {\n    let opcodes = [];\n    visit(visitor$3, post, opcodes);\n    let compiler = Object.create(postOpcodeCompiler$3);\n    compile(compiler, opcodes);\n    return compiler.result;\n  }\n};\n\nfunction entries(obj) {\n  const ownProps = Object.keys(obj);\n  let i = ownProps.length;\n  const resArray = new Array(i);\n\n  while (i--) {\n    resArray[i] = [ownProps[i], obj[ownProps[i]]];\n  }\n\n  return resArray;\n}\n\n/*\n * Parses from mobiledoc -> post\n */\nclass MobiledocParser$3 {\n  constructor(builder) {\n    this.builder = builder;\n  }\n\n  /**\n   * @param {Mobiledoc}\n   * @return {Post}\n   */\n  parse({ sections, markups: markerTypes, cards: cardTypes, atoms: atomTypes }) {\n    try {\n      const post = this.builder.createPost();\n\n      this.markups = [];\n      this.markerTypes = this.parseMarkerTypes(markerTypes);\n      this.cardTypes = this.parseCardTypes(cardTypes);\n      this.atomTypes = this.parseAtomTypes(atomTypes);\n      this.parseSections(sections, post);\n\n      return post;\n    } catch (e) {\n      assert(`Unable to parse mobiledoc: ${e.message}`, false);\n    }\n  }\n\n  parseMarkerTypes(markerTypes) {\n    return markerTypes.map((markerType) => this.parseMarkerType(markerType));\n  }\n\n  parseMarkerType([tagName, attributesArray]) {\n    const attributesObject = kvArrayToObject(attributesArray || []);\n    return this.builder.createMarkup(tagName, attributesObject);\n  }\n\n  parseCardTypes(cardTypes) {\n    return cardTypes.map((cardType) => this.parseCardType(cardType));\n  }\n\n  parseCardType([cardName, cardPayload]) {\n    return [cardName, cardPayload];\n  }\n\n  parseAtomTypes(atomTypes) {\n    return atomTypes.map((atomType) => this.parseAtomType(atomType));\n  }\n\n  parseAtomType([atomName, atomValue, atomPayload]) {\n    return [atomName, atomValue, atomPayload];\n  }\n\n  parseSections(sections, post) {\n    sections.forEach((section) => this.parseSection(section, post));\n  }\n\n  parseSection(section, post) {\n    let [type] = section;\n    switch(type) {\n      case MOBILEDOC_MARKUP_SECTION_TYPE$3:\n        this.parseMarkupSection(section, post);\n        break;\n      case MOBILEDOC_IMAGE_SECTION_TYPE$3:\n        this.parseImageSection(section, post);\n        break;\n      case MOBILEDOC_CARD_SECTION_TYPE$3:\n        this.parseCardSection(section, post);\n        break;\n      case MOBILEDOC_LIST_SECTION_TYPE$3:\n        this.parseListSection(section, post);\n        break;\n      default:\n        assert('Unexpected section type ${type}', false);\n    }\n  }\n\n  getAtomTypeFromIndex(index) {\n    const atomType = this.atomTypes[index];\n    assert(`No atom definition found at index ${index}`, !!atomType);\n    return atomType;\n  }\n\n  getCardTypeFromIndex(index) {\n    const cardType = this.cardTypes[index];\n    assert(`No card definition found at index ${index}`, !!cardType);\n    return cardType;\n  }\n\n  parseCardSection([, cardIndex], post) {\n    const [name, payload] = this.getCardTypeFromIndex(cardIndex);\n    const section = this.builder.createCardSection(name, payload);\n    post.sections.append(section);\n  }\n\n  parseImageSection([, src], post) {\n    const section = this.builder.createImageSection(src);\n    post.sections.append(section);\n  }\n\n  parseMarkupSection([, tagName, markers, attributesArray], post) {\n    const section = this.builder.createMarkupSection(tagName);\n    post.sections.append(section);\n    if (attributesArray) {\n      entries(kvArrayToObject(attributesArray)).forEach(([key, value]) => {\n        section.setAttribute(key, value);\n      });\n    }\n    this.parseMarkers(markers, section);\n    // Strip blank markers after they have been created. This ensures any\n    // markup they include has been correctly populated.\n    filter(section.markers, m => m.isBlank).forEach(m => {\n      section.markers.remove(m);\n    });\n  }\n\n  parseListSection([, tagName, items, attributesArray], post) {\n    const section = this.builder.createListSection(tagName);\n    post.sections.append(section);\n    if (attributesArray) {\n      entries(kvArrayToObject(attributesArray)).forEach(([key, value]) => {\n        section.setAttribute(key, value);\n      });\n    }\n    this.parseListItems(items, section);\n  }\n\n  parseListItems(items, section) {\n    items.forEach(i => this.parseListItem(i, section));\n  }\n\n  parseListItem(markers, section) {\n    const item = this.builder.createListItem();\n    this.parseMarkers(markers, item);\n    section.items.append(item);\n  }\n\n  parseMarkers(markers, parent) {\n    markers.forEach(m => this.parseMarker(m, parent));\n  }\n\n  parseMarker([type, markerTypeIndexes, closeCount, value], parent) {\n    markerTypeIndexes.forEach(index => {\n      this.markups.push(this.markerTypes[index]);\n    });\n\n    const marker = this.buildMarkerType(type, value);\n    parent.markers.append(marker);\n\n    this.markups = this.markups.slice(0, this.markups.length-closeCount);\n  }\n\n  buildMarkerType(type, value) {\n    switch (type) {\n      case MOBILEDOC_MARKUP_MARKER_TYPE$2:\n        return this.builder.createMarker(value, this.markups.slice());\n      case MOBILEDOC_ATOM_MARKER_TYPE$2: {\n        const [atomName, atomValue, atomPayload] = this.getAtomTypeFromIndex(value);\n        return this.builder.createAtom(atomName, atomValue, atomPayload, this.markups.slice());\n      }\n      default:\n        assert(`Unexpected marker type ${type}`, false);\n    }\n  }\n}\n\nfunction parseVersion(mobiledoc) {\n  return mobiledoc.version;\n}\n\nvar mobiledocParsers = {\n  parse(builder, mobiledoc) {\n    let version = parseVersion(mobiledoc);\n    switch (version) {\n      case MOBILEDOC_VERSION:\n        return new MobiledocParser(builder).parse(mobiledoc);\n      case MOBILEDOC_VERSION$1:\n        return new MobiledocParser$1(builder).parse(mobiledoc);\n      case MOBILEDOC_VERSION$2:\n        return new MobiledocParser$2(builder).parse(mobiledoc);\n      case MOBILEDOC_VERSION$3:\n        return new MobiledocParser$3(builder).parse(mobiledoc);\n      default:\n        assert(`Unknown version of mobiledoc parser requested: ${version}`,\n               false);\n    }\n  }\n};\n\nclass CardNode {\n  constructor(editor, card, section, element, options) {\n    this.editor  = editor;\n    this.card    = card;\n    this.section = section;\n    this.element = element;\n    this.options = options;\n\n    this.mode = null;\n\n    this._teardownCallback = null;\n    this._rendered         = null;\n  }\n\n  render(mode) {\n    if (this.mode === mode) { return; }\n\n    this.teardown();\n\n    this.mode = mode;\n\n    let method = mode === 'display' ? 'render' : 'edit';\n    method = this.card[method];\n\n    assert(`Card is missing \"${method}\" (tried to render mode: \"${mode}\")`,\n           !!method);\n    let rendered = method({\n      env: this.env,\n      options: this.options,\n      payload: this.section.payload\n    });\n\n    this._validateAndAppendRenderResult(rendered);\n  }\n\n  teardown() {\n    if (this._teardownCallback) {\n      this._teardownCallback();\n      this._teardownCallback = null;\n    }\n    if (this._rendered) {\n      this.element.removeChild(this._rendered);\n      this._rendered = null;\n    }\n  }\n\n  didRender() {\n    if (this._didRenderCallback) {\n      this._didRenderCallback();\n    }\n  }\n\n  get env() {\n    return {\n      name: this.card.name,\n      isInEditor: true,\n      onTeardown: (callback) => this._teardownCallback = callback,\n      didRender: (callback) => this._didRenderCallback = callback,\n      edit: () => this.edit(),\n      save: (payload, transition=true) => {\n        this.section.payload = payload;\n\n        this.editor._postDidChange();\n        if (transition) {\n          this.display();\n        }\n      },\n      cancel: () => this.display(),\n      remove: () => this.remove(),\n      postModel: this.section\n    };\n  }\n\n  display() {\n    this.render('display');\n  }\n\n  edit() {\n    this.render('edit');\n  }\n\n  remove() {\n    this.editor.run(postEditor => postEditor.removeSection(this.section));\n  }\n\n  _validateAndAppendRenderResult(rendered) {\n    if (!rendered) {\n      return;\n    }\n\n    let { card: { name } } = this;\n    assert(\n      `Card \"${name}\" must render dom (render value was: \"${rendered}\")`,\n      !!rendered.nodeType\n    );\n    this.element.appendChild(rendered);\n    this._rendered = rendered;\n    this.didRender();\n  }\n}\n\nclass AtomNode {\n  constructor(editor, atom, model, element, atomOptions) {\n    this.editor = editor;\n    this.atom = atom;\n    this.model = model;\n    this.atomOptions = atomOptions;\n    this.element = element;\n\n    this._teardownCallback = null;\n    this._rendered         = null;\n  }\n\n  render() {\n    if (!this._rendered) {\n      let {atomOptions: options, env, model: { value, payload } } = this;\n      // cache initial render\n      this._rendered = this.atom.render({options, env, value, payload});\n    }\n\n    this._validateAndAppendRenderResult(this._rendered);\n  }\n\n  get env() {\n    return {\n      name: this.atom.name,\n      onTeardown: (callback) => this._teardownCallback = callback,\n      save: (value, payload={}) => {\n        this.model.value = value;\n        this.model.payload = payload;\n\n        this.editor._postDidChange();\n        this.teardown();\n        this.render();\n      }\n    };\n  }\n\n  teardown() {\n    if (this._teardownCallback) {\n      this._teardownCallback();\n      this._teardownCallback = null;\n    }\n    if (this._rendered) {\n      this.element.removeChild(this._rendered);\n      this._rendered = null;\n    }\n  }\n\n  _validateAndAppendRenderResult(rendered) {\n    if (!rendered) {\n      return;\n    }\n\n    let { atom: { name } } = this;\n    assert(\n      `Atom \"${name}\" must return a DOM node (returned value was: \"${rendered}\")`,\n      !!rendered.nodeType\n    );\n    this.element.appendChild(rendered);\n  }\n}\n\nclass Set {\n  constructor(items=[]) {\n    this.items = [];\n    items.forEach(i => this.add(i));\n  }\n\n  add(item) {\n    if (!this.has(item)) {\n      this.items.push(item);\n    }\n  }\n\n  get length() {\n    return this.items.length;\n  }\n\n  has(item) {\n    return this.items.indexOf(item) !== -1;\n  }\n\n  toArray() {\n    return this.items;\n  }\n}\n\nconst PARENT_PROP = '__parent';\n\nclass LinkedList {\n  constructor(options) {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n\n    if (options) {\n      const {adoptItem, freeItem} = options;\n      this._adoptItem = adoptItem;\n      this._freeItem = freeItem;\n    }\n  }\n  adoptItem(item) {\n    item[PARENT_PROP]= this;\n    this.length++;\n    if (this._adoptItem) { this._adoptItem(item); }\n  }\n  freeItem(item) {\n    item[PARENT_PROP] = null;\n    this.length--;\n    if (this._freeItem) { this._freeItem(item); }\n  }\n  get isEmpty() {\n    return this.length === 0;\n  }\n  prepend(item) {\n    this.insertBefore(item, this.head);\n  }\n  append(item) {\n    this.insertBefore(item, null);\n  }\n  insertAfter(item, prevItem) {\n    let nextItem = prevItem ? prevItem.next : this.head;\n    this.insertBefore(item, nextItem);\n  }\n  _ensureItemIsNotAlreadyInList(item){\n    assert(\n      'Cannot insert an item into a list if it is already in a list',\n      !item.next && !item.prev && this.head !== item\n    );\n  }\n  insertBefore(item, nextItem) {\n    this._ensureItemIsNotInList(item);\n    this.adoptItem(item);\n\n    let insertPos;\n    if (nextItem && nextItem.prev) {\n      insertPos = 'middle';\n    } else if (nextItem) {\n      insertPos = 'start';\n    } else {\n      insertPos = 'end';\n    }\n\n    switch (insertPos) {\n      case 'start':\n        if (this.head) {\n          item.next      = this.head;\n          this.head.prev = item;\n        }\n        this.head = item;\n\n        break;\n      case 'middle': {\n        let prevItem  = nextItem.prev;\n        item.next     = nextItem;\n        item.prev     = prevItem;\n        nextItem.prev = item;\n        prevItem.next = item;\n\n        break;\n      }\n      case 'end': {\n        let tail = this.tail;\n        item.prev = tail;\n\n        if (tail) {\n          tail.next = item;\n        } else {\n          this.head = item;\n        }\n        this.tail = item;\n\n        break;\n      }\n    }\n  }\n  remove(item) {\n    if (!item[PARENT_PROP]) {\n      return;\n    }\n    this._ensureItemIsInThisList(item);\n    this.freeItem(item);\n\n    let [prev, next] = [item.prev, item.next];\n    item.prev = null;\n    item.next = null;\n\n    if (prev) {\n      prev.next = next;\n    } else {\n      this.head = next;\n    }\n\n    if (next) {\n      next.prev = prev;\n    } else {\n      this.tail = prev;\n    }\n  }\n  forEach(callback) {\n    let item = this.head;\n    let index = 0;\n    while (item) {\n      callback(item, index++);\n      item = item.next;\n    }\n  }\n  map(callback) {\n    let result = [];\n    this.forEach(i => result.push(callback(i)));\n    return result;\n  }\n  walk(startItem, endItem, callback) {\n    let item = startItem || this.head;\n    while (item) {\n      callback(item);\n      if (item === endItem) {\n        break;\n      }\n      item = item.next;\n    }\n  }\n  readRange(startItem, endItem) {\n    let items = [];\n    this.walk(startItem, endItem, (item) => {\n      items.push(item);\n    });\n    return items;\n  }\n  toArray() {\n    return this.readRange();\n  }\n  detect(callback, item=this.head, reverse=false) {\n    while (item) {\n      if (callback(item)) {\n        return item;\n      }\n      item = reverse ? item.prev : item.next;\n    }\n  }\n  any(callback) {\n    return !!this.detect(callback);\n  }\n  every(callback) {\n    let item = this.head;\n    while (item) {\n      if (!callback(item)) {\n        return false;\n      }\n      item = item.next;\n    }\n    return true;\n  }\n  objectAt(targetIndex) {\n    let index = -1;\n    return this.detect(() => {\n      index++;\n      return (targetIndex === index);\n    });\n  }\n  splice(targetItem, removalCount, newItems) {\n    let item = targetItem;\n    let nextItem = item.next;\n    let count = 0;\n    while (item && count < removalCount) {\n      count++;\n      nextItem = item.next;\n      this.remove(item);\n      item = nextItem;\n    }\n    newItems.forEach((newItem) => {\n      this.insertBefore(newItem, nextItem);\n    });\n  }\n  removeBy(conditionFn) {\n    let item = this.head;\n    while (item) {\n      let nextItem = item.next;\n\n      if (conditionFn(item)) {\n        this.remove(item);\n      }\n\n      item = nextItem;\n    }\n  }\n  _ensureItemIsNotInList(item) {\n    assert('Cannot insert an item into a list if it is already in a list',\n           !item[PARENT_PROP]);\n  }\n  _ensureItemIsInThisList(item) {\n    assert('Cannot remove item that is in another list',\n           item[PARENT_PROP] === this);\n  }\n}\n\nfunction unimplementedMethod(methodName, me) {\n  assert(`\\`${methodName}()\\` must be implemented by ${me.constructor.name}`,\n         false);\n}\n\nclass Section extends LinkedItem {\n  constructor(type) {\n    super();\n    assert('Cannot create section without type', !!type);\n    this.type = type;\n    this.isSection = true;\n    this.isMarkerable = false;\n    this.isNested = false;\n    this.isSection = true;\n    this.isLeafSection = true;\n  }\n\n  set tagName(val) {\n    let normalizedTagName = normalizeTagName(val);\n    assert(`Cannot set section tagName to ${val}`,\n           this.isValidTagName(normalizedTagName));\n    this._tagName = normalizedTagName;\n  }\n\n  get tagName() {\n    return this._tagName;\n  }\n\n  isValidTagName(/* normalizedTagName */) {\n    unimplementedMethod('isValidTagName', this);\n  }\n\n  get length() {\n    return 0;\n  }\n\n  get isBlank() {\n    unimplementedMethod('isBlank', this);\n  }\n\n  clone() {\n    unimplementedMethod('clone', this);\n  }\n\n  canJoin(/* otherSection */) {\n    unimplementedMethod('canJoin', this);\n  }\n\n  /**\n   * @return {Position} The position at the start of this section\n   * @public\n   */\n  headPosition() {\n    return this.toPosition(0);\n  }\n\n  /**\n   * @return {Position} The position at the end of this section\n   * @public\n   */\n  tailPosition() {\n    return this.toPosition(this.length);\n  }\n\n  /**\n   * @param {Number} offset\n   * @return {Position} The position in this section at the given offset\n   * @public\n   */\n  toPosition(offset) {\n    assert(\"Must pass number to `toPosition`\", typeof offset === 'number');\n    assert(\"Cannot call `toPosition` with offset > length\", offset <= this.length);\n\n    return new Position$1(this, offset);\n  }\n\n  /**\n   * @return {Range} A range from this section's head to tail positions\n   * @public\n   */\n  toRange() {\n    return this.headPosition().toRange(this.tailPosition());\n  }\n\n  join() {\n    unimplementedMethod('join', this);\n  }\n\n  textUntil(/* position */) {\n    return '';\n  }\n\n  /**\n   * Markerable sections should override this method\n   */\n  splitMarkerAtOffset() {\n    let blankEdit = { added: [], removed: [] };\n    return blankEdit;\n  }\n\n  nextLeafSection() {\n    const next = this.next;\n    if (next) {\n      if (next.items) {\n        return next.items.head;\n      } else {\n        return next;\n      }\n    } else {\n      if (this.isNested) {\n        return this.parent.nextLeafSection();\n      }\n    }\n  }\n\n  immediatelyNextMarkerableSection() {\n    let next = this.nextLeafSection();\n    while (next && !next.isMarkerable) {\n      next = next.nextLeafSection();\n    }\n    return next;\n  }\n\n  previousLeafSection() {\n    const prev = this.prev;\n\n    if (prev) {\n      if (prev.items) {\n        return prev.items.tail;\n      } else {\n        return prev;\n      }\n    } else {\n      if (this.isNested) {\n        return this.parent.previousLeafSection();\n      }\n    }\n  }\n}\n\nclass Markerable extends Section {\n  constructor(type, tagName, markers=[]) {\n    super(type);\n    this.isMarkerable = true;\n    this.tagName = tagName;\n    this.markers = new LinkedList({\n      adoptItem: m => {\n        assert(`Can only insert markers and atoms into markerable (was: ${m.type})`,\n               m.isMarker || m.isAtom);\n        m.section = m.parent = this;\n      },\n      freeItem: m => m.section = m.parent = null\n    });\n\n    markers.forEach(m => this.markers.append(m));\n  }\n\n  canJoin(other) {\n    return other.isMarkerable &&\n      other.type === this.type &&\n      other.tagName === this.tagName;\n  }\n\n  clone() {\n    const newMarkers = this.markers.map(m => m.clone());\n    return this.builder.createMarkerableSection(\n      this.type, this.tagName, newMarkers);\n  }\n\n  get isBlank() {\n    if (!this.markers.length) {\n      return true;\n    }\n    return this.markers.every(m => m.isBlank);\n  }\n\n  textUntil(position) {\n    assert(`Cannot get textUntil for a position not in this section`, position.section === this);\n    let {marker, offsetInMarker} = position;\n    let text = '';\n    let currentMarker = this.markers.head;\n    while (currentMarker) {\n      if (currentMarker === marker) {\n        text += currentMarker.textUntil(offsetInMarker);\n        break;\n      } else {\n        text += currentMarker.text;\n        currentMarker = currentMarker.next;\n      }\n    }\n    return text;\n  }\n\n  /**\n   * @param {Marker}\n   * @param {Number} markerOffset The offset relative to the start of the marker\n   *\n   * @return {Number} The offset relative to the start of this section\n   */\n  offsetOfMarker(marker, markerOffset=0) {\n    assert(`Cannot get offsetOfMarker for marker that is not child of this`,\n           marker.section === this);\n\n    // FIXME it is possible, when we get a cursor position before having finished reparsing,\n    // for markerOffset to be > marker.length. We shouldn't rely on this functionality.\n\n    let offset = 0;\n    let currentMarker = this.markers.head;\n    while (currentMarker && currentMarker !== marker.next) {\n      let length = currentMarker === marker ? markerOffset :\n                                              currentMarker.length;\n      offset += length;\n      currentMarker = currentMarker.next;\n    }\n\n    return offset;\n  }\n\n  // puts clones of this.markers into beforeSection and afterSection,\n  // all markers before the marker/offset split go in beforeSection, and all\n  // after the marker/offset split go in afterSection\n  // @return {Array} [beforeSection, afterSection], two new sections\n  _redistributeMarkers(beforeSection, afterSection, marker, offset=0) {\n    let currentSection = beforeSection;\n    forEach(this.markers, m => {\n      if (m === marker) {\n        const [beforeMarker, ...afterMarkers] = marker.split(offset);\n        beforeSection.markers.append(beforeMarker);\n        forEach(afterMarkers, _m => afterSection.markers.append(_m));\n        currentSection = afterSection;\n      } else {\n        currentSection.markers.append(m.clone());\n      }\n    });\n\n    return [beforeSection, afterSection];\n  }\n\n  splitAtMarker(/*marker, offset=0*/) {\n    assert('splitAtMarker must be implemented by sub-class', false);\n  }\n\n  /**\n   * Split this section's marker (if any) at the given offset, so that\n   * there is now a marker boundary at that offset (useful for later applying\n   * a markup to a range)\n   * @param {Number} sectionOffset The offset relative to start of this section\n   * @return {EditObject} An edit object with 'removed' and 'added' keys with arrays of Markers. The added markers may be blank.\n   * After calling `splitMarkerAtOffset(offset)`, there will always be a valid\n   * result returned from `markerBeforeOffset(offset)`.\n   */\n  splitMarkerAtOffset(sectionOffset) {\n    assert('Cannot splitMarkerAtOffset when offset is > length',\n           sectionOffset <= this.length);\n    let markerOffset;\n    let len = 0;\n    let currentMarker = this.markers.head;\n    let edit = {added: [], removed: []};\n\n    if (!currentMarker) {\n      let blankMarker = this.builder.createMarker();\n      this.markers.prepend(blankMarker);\n      edit.added.push(blankMarker);\n    } else {\n      while (currentMarker) {\n        len += currentMarker.length;\n        if (len === sectionOffset) {\n          // nothing to do, there is a gap at the requested offset\n          break;\n        } else if (len > sectionOffset) {\n          markerOffset = currentMarker.length - (len - sectionOffset);\n          let newMarkers = currentMarker.splitAtOffset(markerOffset);\n          edit.added.push(...newMarkers);\n          edit.removed.push(currentMarker);\n          this.markers.splice(currentMarker, 1, newMarkers);\n          break;\n        } else {\n          currentMarker = currentMarker.next;\n        }\n      }\n    }\n\n    return edit;\n  }\n\n  splitAtPosition(position) {\n    const {marker, offsetInMarker} = position;\n    return this.splitAtMarker(marker, offsetInMarker);\n  }\n\n  // returns the marker just before this offset.\n  // It is an error to call this method with an offset that is in the middle\n  // of a marker.\n  markerBeforeOffset(sectionOffset) {\n    let len = 0;\n    let currentMarker = this.markers.head;\n\n    while (currentMarker) {\n      len += currentMarker.length;\n      if (len === sectionOffset) {\n        return currentMarker;\n      } else {\n        assert('markerBeforeOffset called with sectionOffset not between markers',\n               len < sectionOffset);\n        currentMarker = currentMarker.next;\n      }\n    }\n  }\n\n  markerPositionAtOffset(offset) {\n    let currentOffset = 0;\n    let currentMarker;\n    let remaining = offset;\n    this.markers.detect((marker) => {\n      currentOffset = Math.min(remaining, marker.length);\n      remaining -= currentOffset;\n      if (remaining === 0) {\n        currentMarker = marker;\n        return true; // break out of detect\n      }\n    });\n\n    return {marker:currentMarker, offset:currentOffset};\n  }\n\n  get text() {\n    return reduce(this.markers, (prev, m) => prev + m.value, '');\n  }\n\n  get length() {\n    return reduce(this.markers, (prev, m) => prev + m.length, 0);\n  }\n\n  /**\n   * @return {Array} New markers that match the boundaries of the\n   * range. Does not change the existing markers in this section.\n   */\n  markersFor(headOffset, tailOffset) {\n    const range = {head: {section:this, offset:headOffset},\n                   tail: {section:this, offset:tailOffset}};\n\n    let markers = [];\n    this._markersInRange(range, (marker, {markerHead, markerTail, isContained}) => {\n      const cloned = marker.clone();\n      if (!isContained) {\n        // cannot do marker.value.slice if the marker is an atom -- this breaks the atom's \"atomic\" value\n        // If a marker is an atom `isContained` should always be true so\n        // we shouldn't hit this code path. FIXME add tests\n        cloned.value = marker.value.slice(markerHead, markerTail);\n      }\n      markers.push(cloned);\n    });\n    return markers;\n  }\n\n  markupsInRange(range) {\n    const markups = new Set();\n    this._markersInRange(range, marker => {\n      marker.markups.forEach(m => markups.add(m));\n    });\n    return markups.toArray();\n  }\n\n  // calls the callback with (marker, {markerHead, markerTail, isContained})\n  // for each marker that is wholly or partially contained in the range.\n  _markersInRange(range, callback) {\n    const { head, tail } = range;\n    assert('Cannot call #_markersInRange if range expands beyond this section',\n           head.section === this && tail.section === this);\n    const {offset:headOffset} = head, {offset:tailOffset} = tail;\n\n    let currentHead = 0, currentTail = 0, currentMarker = this.markers.head;\n\n    while (currentMarker) {\n      currentTail += currentMarker.length;\n\n      if (currentTail > headOffset && currentHead < tailOffset) {\n        let markerHead = Math.max(headOffset - currentHead, 0);\n        let markerTail = currentMarker.length -\n          Math.max(currentTail - tailOffset, 0);\n        let isContained = markerHead === 0 && markerTail === currentMarker.length;\n\n        callback(currentMarker, {markerHead, markerTail, isContained});\n      }\n\n      currentHead += currentMarker.length;\n      currentMarker = currentMarker.next;\n\n      if (currentHead > tailOffset) { break; }\n    }\n  }\n\n  // mutates this by appending the other section's (cloned) markers to it\n  join(otherSection) {\n    let beforeMarker = this.markers.tail;\n    let afterMarker = null;\n\n    otherSection.markers.forEach(m => {\n      if (!m.isBlank) {\n        m = m.clone();\n        this.markers.append(m);\n        if (!afterMarker) {\n          afterMarker = m;\n        }\n      }\n    });\n\n    return { beforeMarker, afterMarker };\n  }\n}\n\nconst VALID_ATTRIBUTES = [\n  'data-md-text-align'\n];\n\n/*\n * A \"mixin\" to add section attribute support\n * to markup and list sections.\n */\nfunction attributable(ctx) {\n  ctx.attributes = {};\n\n  ctx.hasAttribute = key => key in ctx.attributes;\n\n  ctx.setAttribute = (key, value) => {\n    if (!contains(VALID_ATTRIBUTES, key)) {\n      throw new Error(`Invalid attribute \"${key}\" was passed. Constrain attributes to the spec-compliant whitelist.`);\n    }\n    ctx.attributes[key] = value;\n  };\n  ctx.removeAttribute = key => {\n    delete ctx.attributes[key];\n  };\n  ctx.getAttribute = key => ctx.attributes[key];\n  ctx.eachAttribute = cb => {\n    entries(ctx.attributes).forEach(([k,v]) => cb(k,v));\n  };\n}\n\n// valid values of `tagName` for a MarkupSection\nconst VALID_MARKUP_SECTION_TAGNAMES = [\n  'aside',\n  'blockquote',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'p'\n].map(normalizeTagName);\n\n// valid element names for a MarkupSection. A MarkupSection with a tagName\n// not in this will be rendered as a div with a className matching the\n// tagName\nconst MARKUP_SECTION_ELEMENT_NAMES = [\n  'aside',\n  'blockquote',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'p'\n].map(normalizeTagName);\nconst DEFAULT_TAG_NAME = VALID_MARKUP_SECTION_TAGNAMES[8];\n\nconst MarkupSection = class MarkupSection extends Markerable {\n  constructor(tagName=DEFAULT_TAG_NAME, markers=[], attributes={}) {\n    super(MARKUP_SECTION_TYPE, tagName, markers);\n\n    attributable(this);\n    entries(attributes).forEach(([k,v]) => this.setAttribute(k, v));\n\n    this.isMarkupSection = true;\n  }\n\n  isValidTagName(normalizedTagName) {\n    return contains(VALID_MARKUP_SECTION_TAGNAMES, normalizedTagName);\n  }\n\n  splitAtMarker(marker, offset=0) {\n    let [beforeSection, afterSection] = [\n      this.builder.createMarkupSection(this.tagName, [], false, this.attributes),\n      this.builder.createMarkupSection()\n    ];\n\n    return this._redistributeMarkers(beforeSection, afterSection, marker, offset);\n  }\n};\n\nconst CARD_ELEMENT_CLASS_NAME = '__mobiledoc-card';\nconst NO_BREAK_SPACE = '\\u00A0';\nconst TAB_CHARACTER = '\\u2003';\nconst SPACE = ' ';\nconst ZWNJ = '\\u200c';\nconst ATOM_CLASS_NAME = '-mobiledoc-kit__atom';\nconst EDITOR_HAS_NO_CONTENT_CLASS_NAME = '__has-no-content';\nconst EDITOR_ELEMENT_CLASS_NAME = '__mobiledoc-editor';\n\nfunction createElementFromMarkup(doc, markup) {\n  let element = doc.createElement(markup.tagName);\n  Object.keys(markup.attributes).forEach(k => {\n    element.setAttribute(k, markup.attributes[k]);\n  });\n  return element;\n}\n\nconst TWO_SPACES         = `${SPACE}${SPACE}`;\nconst SPACE_AND_NO_BREAK = `${SPACE}${NO_BREAK_SPACE}`;\nconst SPACES_REGEX       = new RegExp(TWO_SPACES, 'g');\nconst TAB_REGEX          = new RegExp(TAB, 'g');\nconst endsWithSpace = function(text) {\n  return endsWith(text, SPACE);\n};\nconst startsWithSpace = function(text) {\n  return startsWith(text, SPACE);\n};\n\n// FIXME: This can be done more efficiently with a single pass\n// building a correct string based on the original.\nfunction renderHTMLText(marker) {\n  let text = marker.value;\n  text = text.replace(SPACES_REGEX, SPACE_AND_NO_BREAK)\n             .replace(TAB_REGEX,    TAB_CHARACTER);\n\n  // If the first marker has a leading space or the last marker has a\n  // trailing space, the browser will collapse the space when we position\n  // the cursor.\n  // See https://github.com/bustle/mobiledoc-kit/issues/68\n  //   and https://github.com/bustle/mobiledoc-kit/issues/75\n  if (marker.isMarker && endsWithSpace(text) && !marker.next) {\n    text = text.substr(0, text.length - 1) + NO_BREAK_SPACE;\n  }\n  if (marker.isMarker && startsWithSpace(text) &&\n      (!marker.prev || (marker.prev.isMarker && endsWithSpace(marker.prev.value)))) {\n    text = NO_BREAK_SPACE + text.substr(1);\n  }\n  return text;\n}\n\n// ascends from element upward, returning the last parent node that is not\n// parentElement\nfunction penultimateParentOf(element, parentElement) {\n  while (parentElement &&\n         element.parentNode !== parentElement &&\n         element.parentNode !== document.body // ensure the while loop stops\n        ) {\n    element = element.parentNode;\n  }\n  return element;\n}\n\nfunction setSectionAttributesOnElement(section, element) {\n  section.eachAttribute((key, value) => {\n    element.setAttribute(key, value);\n  });\n}\n\nfunction renderMarkupSection(section) {\n  let element;\n  if (MARKUP_SECTION_ELEMENT_NAMES.indexOf(section.tagName) !== -1) {\n    element = document.createElement(section.tagName);\n  } else {\n    element = document.createElement('div');\n    addClassName(element, section.tagName);\n  }\n\n  setSectionAttributesOnElement(section, element);\n\n  return element;\n}\n\nfunction renderListSection(section) {\n  let element = document.createElement(section.tagName);\n\n  setSectionAttributesOnElement(section, element);\n\n  return element;\n}\n\nfunction renderListItem() {\n  return document.createElement('li');\n}\n\nfunction renderCursorPlaceholder() {\n  return document.createElement('br');\n}\n\nfunction renderInlineCursorPlaceholder() {\n  return document.createTextNode(ZWNJ);\n}\n\nfunction renderCard() {\n  let wrapper = document.createElement('div');\n  let cardElement = document.createElement('div');\n  cardElement.contentEditable = false;\n  addClassName(cardElement, CARD_ELEMENT_CLASS_NAME);\n  wrapper.appendChild(renderInlineCursorPlaceholder());\n  wrapper.appendChild(cardElement);\n  wrapper.appendChild(renderInlineCursorPlaceholder());\n  return { wrapper, cardElement };\n}\n\n/**\n * Wrap the element in all of the opened markups\n * @return {DOMElement} the wrapped element\n * @private\n */\nfunction wrapElement(element, openedMarkups) {\n  let wrappedElement = element;\n\n  for (let i=openedMarkups.length - 1; i>=0; i--) {\n    let markup = openedMarkups[i];\n    let openedElement = createElementFromMarkup(document, markup);\n    openedElement.appendChild(wrappedElement);\n    wrappedElement = openedElement;\n  }\n\n  return wrappedElement;\n}\n\n// Attach the element to its parent element at the correct position based on the\n// previousRenderNode\nfunction attachElementToParent(element, parentElement, previousRenderNode=null) {\n  if (previousRenderNode) {\n    let previousSibling = previousRenderNode.element;\n    let previousSiblingPenultimate = penultimateParentOf(previousSibling,\n                                                         parentElement);\n    parentElement.insertBefore(element, previousSiblingPenultimate.nextSibling);\n  } else {\n    parentElement.insertBefore(element, parentElement.firstChild);\n  }\n}\n\nfunction renderAtom(atom, element, previousRenderNode) {\n  let atomElement = document.createElement('span');\n  atomElement.contentEditable = false;\n\n  let wrapper = document.createElement('span');\n  addClassName(wrapper, ATOM_CLASS_NAME);\n  let headTextNode = renderInlineCursorPlaceholder();\n  let tailTextNode = renderInlineCursorPlaceholder();\n\n  wrapper.appendChild(headTextNode);\n  wrapper.appendChild(atomElement);\n  wrapper.appendChild(tailTextNode);\n\n  let wrappedElement = wrapElement(wrapper, atom.openedMarkups);\n  attachElementToParent(wrappedElement, element, previousRenderNode);\n\n  return {\n    markupElement: wrappedElement,\n    wrapper,\n    atomElement,\n    headTextNode,\n    tailTextNode\n  };\n}\n\nfunction getNextMarkerElement(renderNode) {\n  let element = renderNode.element.parentNode;\n  let marker = renderNode.postNode;\n  let closedCount = marker.closedMarkups.length;\n\n  while (closedCount--) {\n    element = element.parentNode;\n  }\n  return element;\n}\n\n/**\n * Render the marker\n * @param {Marker} marker the marker to render\n * @param {DOMNode} element the element to attach the rendered marker to\n * @param {RenderNode} [previousRenderNode] The render node before this one, which\n *        affects the determination of where to insert this rendered marker.\n * @return {Object} With properties `element` and `markupElement`.\n *         The element (textNode) that has the text for\n *         this marker, and the outermost rendered element. If the marker has no\n *         markups, element and markupElement will be the same textNode\n * @private\n */\nfunction renderMarker(marker, parentElement, previousRenderNode) {\n  let text = renderHTMLText(marker);\n\n  let element = document.createTextNode(text);\n  let markupElement = wrapElement(element, marker.openedMarkups);\n  attachElementToParent(markupElement, parentElement, previousRenderNode);\n\n  return { element, markupElement };\n}\n\n// Attach the render node's element to the DOM,\n// replacing the originalElement if it exists\nfunction attachRenderNodeElementToDOM(renderNode, originalElement=null) {\n  const element = renderNode.element;\n  const hasRendered = !!originalElement;\n\n  if (hasRendered) {\n    let parentElement = renderNode.parent.element;\n    parentElement.replaceChild(element, originalElement);\n  } else {\n    let parentElement, nextSiblingElement;\n    if (renderNode.prev) {\n      let previousElement = renderNode.prev.element;\n      parentElement = previousElement.parentNode;\n      nextSiblingElement = previousElement.nextSibling;\n    } else {\n      parentElement = renderNode.parent.element;\n      nextSiblingElement = parentElement.firstChild;\n    }\n    parentElement.insertBefore(element, nextSiblingElement);\n  }\n}\n\nfunction removeRenderNodeSectionFromParent(renderNode, section) {\n  const parent = renderNode.parent.postNode;\n  parent.sections.remove(section);\n}\n\nfunction removeRenderNodeElementFromParent(renderNode) {\n  if (renderNode.element && renderNode.element.parentNode) {\n    renderNode.element.parentNode.removeChild(renderNode.element);\n  }\n}\n\nfunction validateCards(cards=[]) {\n  forEach(cards, card => {\n    assert(\n      `Card \"${card.name}\" must define type \"dom\", has: \"${card.type}\"`,\n      card.type === 'dom'\n    );\n    assert(\n      `Card \"${card.name}\" must define \\`render\\` method`,\n      !!card.render\n    );\n  });\n  return cards;\n}\n\nfunction validateAtoms(atoms=[]) {\n  forEach(atoms, atom => {\n    assert(\n      `Atom \"${atom.name}\" must define type \"dom\", has: \"${atom.type}\"`,\n      atom.type === 'dom'\n    );\n    assert(\n      `Atom \"${atom.name}\" must define \\`render\\` method`,\n      !!atom.render\n    );\n  });\n  return atoms;\n}\n\nclass Visitor$1 {\n  constructor(editor, cards, atoms, unknownCardHandler, unknownAtomHandler, options) {\n    this.editor = editor;\n    this.cards = validateCards(cards);\n    this.atoms = validateAtoms(atoms);\n    this.unknownCardHandler = unknownCardHandler;\n    this.unknownAtomHandler = unknownAtomHandler;\n    this.options = options;\n  }\n\n  _findCard(cardName) {\n    let card = detect(this.cards, card => card.name === cardName);\n    return card || this._createUnknownCard(cardName);\n  }\n\n  _createUnknownCard(cardName) {\n    assert(\n      `Unknown card \"${cardName}\" found, but no unknownCardHandler is defined`,\n      !!this.unknownCardHandler\n    );\n\n    return {\n      name: cardName,\n      type: 'dom',\n      render: this.unknownCardHandler,\n      edit:   this.unknownCardHandler\n    };\n  }\n\n  _findAtom(atomName) {\n    let atom = detect(this.atoms, atom => atom.name === atomName);\n    return atom || this._createUnknownAtom(atomName);\n  }\n\n  _createUnknownAtom(atomName) {\n    assert(\n      `Unknown atom \"${atomName}\" found, but no unknownAtomHandler is defined`,\n      !!this.unknownAtomHandler\n    );\n\n    return {\n      name: atomName,\n      type: 'dom',\n      render: this.unknownAtomHandler\n    };\n  }\n\n  [POST_TYPE](renderNode, post, visit) {\n    if (!renderNode.element) {\n      renderNode.element = document.createElement('div');\n    }\n    addClassName(renderNode.element, EDITOR_ELEMENT_CLASS_NAME);\n    if (post.hasContent) {\n      removeClassName(renderNode.element, EDITOR_HAS_NO_CONTENT_CLASS_NAME);\n    } else {\n      addClassName(renderNode.element, EDITOR_HAS_NO_CONTENT_CLASS_NAME);\n    }\n    visit(renderNode, post.sections);\n  }\n\n  [MARKUP_SECTION_TYPE](renderNode, section, visit) {\n    const originalElement = renderNode.element;\n\n    // Always rerender the section -- its tag name or attributes may have changed.\n    // TODO make this smarter, only rerendering and replacing the element when necessary\n    renderNode.element = renderMarkupSection(section);\n    renderNode.cursorElement = null;\n    attachRenderNodeElementToDOM(renderNode, originalElement);\n\n    if (section.isBlank) {\n      let cursorPlaceholder = renderCursorPlaceholder();\n      renderNode.element.appendChild(cursorPlaceholder);\n      renderNode.cursorElement = cursorPlaceholder;\n    } else {\n      const visitAll = true;\n      visit(renderNode, section.markers, visitAll);\n    }\n  }\n\n  [LIST_SECTION_TYPE](renderNode, section, visit) {\n    const originalElement = renderNode.element;\n\n    renderNode.element = renderListSection(section);\n    attachRenderNodeElementToDOM(renderNode, originalElement);\n\n    const visitAll = true;\n    visit(renderNode, section.items, visitAll);\n  }\n\n  [LIST_ITEM_TYPE](renderNode, item, visit) {\n    // FIXME do we need to do anything special for rerenders?\n    renderNode.element = renderListItem();\n    renderNode.cursorElement = null;\n    attachRenderNodeElementToDOM(renderNode, null);\n\n    if (item.isBlank) {\n      let cursorPlaceholder = renderCursorPlaceholder();\n      renderNode.element.appendChild(cursorPlaceholder);\n      renderNode.cursorElement = cursorPlaceholder;\n    } else {\n      const visitAll = true;\n      visit(renderNode, item.markers, visitAll);\n    }\n  }\n\n  [MARKER_TYPE](renderNode, marker) {\n    let parentElement;\n\n    if (renderNode.prev) {\n      parentElement = getNextMarkerElement(renderNode.prev);\n    } else {\n      parentElement = renderNode.parent.element;\n    }\n\n    let { element, markupElement } =\n      renderMarker(marker, parentElement, renderNode.prev);\n\n    renderNode.element = element;\n    renderNode.markupElement = markupElement;\n  }\n\n  [IMAGE_SECTION_TYPE](renderNode, section) {\n    if (renderNode.element) {\n      if (renderNode.element.src !== section.src) {\n        renderNode.element.src = section.src;\n      }\n    } else {\n      let element = document.createElement('img');\n      element.src = section.src;\n      if (renderNode.prev) {\n        let previousElement = renderNode.prev.element;\n        let nextElement = previousElement.nextSibling;\n        if (nextElement) {\n          nextElement.parentNode.insertBefore(element, nextElement);\n        }\n      }\n      if (!element.parentNode) {\n        renderNode.parent.element.appendChild(element);\n      }\n      renderNode.element = element;\n    }\n  }\n\n  [CARD_TYPE](renderNode, section) {\n    const originalElement = renderNode.element;\n    const {editor, options} = this;\n\n    const card = this._findCard(section.name);\n\n    let { wrapper, cardElement } = renderCard();\n    renderNode.element = wrapper;\n    attachRenderNodeElementToDOM(renderNode, originalElement);\n\n    const cardNode = new CardNode(\n      editor, card, section, cardElement, options);\n    renderNode.cardNode = cardNode;\n\n    const initialMode = section._initialMode;\n    cardNode[initialMode]();\n  }\n\n  [ATOM_TYPE](renderNode, atomModel) {\n    let parentElement;\n\n    if (renderNode.prev) {\n      parentElement = getNextMarkerElement(renderNode.prev);\n    } else {\n      parentElement = renderNode.parent.element;\n    }\n\n    const { editor, options } = this;\n    const {\n      wrapper,\n      markupElement,\n      atomElement,\n      headTextNode,\n      tailTextNode\n    } = renderAtom(atomModel, parentElement, renderNode.prev);\n    const atom = this._findAtom(atomModel.name);\n\n    let atomNode = renderNode.atomNode;\n    if (!atomNode) {\n      // create new AtomNode\n      atomNode = new AtomNode(editor, atom, atomModel, atomElement, options);\n    } else {\n      // retarget atomNode to new atom element\n      atomNode.element = atomElement;\n    }\n\n    atomNode.render();\n\n    renderNode.atomNode = atomNode;\n    renderNode.element = wrapper;\n    renderNode.headTextNode = headTextNode;\n    renderNode.tailTextNode = tailTextNode;\n    renderNode.markupElement = markupElement;\n  }\n}\n\nlet destroyHooks = {\n  [POST_TYPE](/*renderNode, post*/) {\n    assert('post destruction is not supported by the renderer', false);\n  },\n\n  [MARKUP_SECTION_TYPE](renderNode, section) {\n    removeRenderNodeSectionFromParent(renderNode, section);\n    removeRenderNodeElementFromParent(renderNode);\n  },\n\n  [LIST_SECTION_TYPE](renderNode, section) {\n    removeRenderNodeSectionFromParent(renderNode, section);\n    removeRenderNodeElementFromParent(renderNode);\n  },\n\n  [LIST_ITEM_TYPE](renderNode, li) {\n    removeRenderNodeSectionFromParent(renderNode, li);\n    removeRenderNodeElementFromParent(renderNode);\n  },\n\n  [MARKER_TYPE](renderNode, marker) {\n    // FIXME before we render marker, should delete previous renderNode's element\n    // and up until the next marker element\n\n    // If an atom throws during render we may end up later destroying a renderNode\n    // that has not rendered yet, so exit early here if so.\n    if (!renderNode.isRendered) {\n      return;\n    }\n    let { markupElement } = renderNode;\n\n    if (marker.section) {\n      marker.section.markers.remove(marker);\n    }\n\n    if (markupElement.parentNode) {\n      // if no parentNode, the browser already removed this element\n      markupElement.parentNode.removeChild(markupElement);\n    }\n  },\n\n  [IMAGE_SECTION_TYPE](renderNode, section) {\n    removeRenderNodeSectionFromParent(renderNode, section);\n    removeRenderNodeElementFromParent(renderNode);\n  },\n\n  [CARD_TYPE](renderNode, section) {\n    if (renderNode.cardNode) {\n      renderNode.cardNode.teardown();\n    }\n    removeRenderNodeSectionFromParent(renderNode, section);\n    removeRenderNodeElementFromParent(renderNode);\n  },\n\n  [ATOM_TYPE](renderNode, atom) {\n    if (renderNode.atomNode) {\n      renderNode.atomNode.teardown();\n    }\n\n    // an atom is a kind of marker so just call its destroy hook vs copying here\n    destroyHooks[MARKER_TYPE](renderNode, atom);\n  }\n};\n\n// removes children from parentNode (a RenderNode) that are scheduled for removal\nfunction removeDestroyedChildren(parentNode, forceRemoval=false) {\n  let child = parentNode.childNodes.head;\n  let nextChild, method;\n  while (child) {\n    nextChild = child.next;\n    if (child.isRemoved || forceRemoval) {\n      removeDestroyedChildren(child, true);\n      method = child.postNode.type;\n      assert(`editor-dom cannot destroy \"${method}\"`, !!destroyHooks[method]);\n      destroyHooks[method](child, child.postNode);\n      parentNode.childNodes.remove(child);\n    }\n    child = nextChild;\n  }\n}\n\n// Find an existing render node for the given postNode, or\n// create one, insert it into the tree, and return it\nfunction lookupNode(renderTree, parentNode, postNode, previousNode) {\n  if (postNode.renderNode) {\n    return postNode.renderNode;\n  } else {\n    const renderNode = renderTree.buildRenderNode(postNode);\n    parentNode.childNodes.insertAfter(renderNode, previousNode);\n    return renderNode;\n  }\n}\n\nclass Renderer {\n  constructor(editor, cards, atoms, unknownCardHandler, unknownAtomHandler, options) {\n    this.editor = editor;\n    this.visitor = new Visitor$1(editor, cards, atoms, unknownCardHandler, unknownAtomHandler, options);\n    this.nodes = [];\n    this.hasRendered = false;\n  }\n\n  destroy() {\n    if (!this.hasRendered) {\n      return;\n    }\n    let renderNode = this.renderTree.rootNode;\n    let force = true;\n    removeDestroyedChildren(renderNode, force);\n  }\n\n  visit(renderTree, parentNode, postNodes, visitAll=false) {\n    let previousNode;\n    postNodes.forEach(postNode => {\n      let node = lookupNode(renderTree, parentNode, postNode, previousNode);\n      if (node.isDirty || visitAll) {\n        this.nodes.push(node);\n      }\n      previousNode = node;\n    });\n  }\n\n  render(renderTree) {\n    this.hasRendered = true;\n    this.renderTree = renderTree;\n    let renderNode = renderTree.rootNode;\n    let method, postNode;\n\n    while (renderNode) {\n      removeDestroyedChildren(renderNode);\n      postNode = renderNode.postNode;\n\n      method = postNode.type;\n      assert(`EditorDom visitor cannot handle type ${method}`, !!this.visitor[method]);\n      this.visitor[method](renderNode, postNode,\n                           (...args) => this.visit(renderTree, ...args));\n      renderNode.markClean();\n      renderNode = this.nodes.shift();\n    }\n  }\n}\n\nconst VALID_LIST_SECTION_TAGNAMES = [\n  'ul', 'ol'\n].map(normalizeTagName);\n\nconst DEFAULT_TAG_NAME$1 = VALID_LIST_SECTION_TAGNAMES[0];\n\nclass ListSection extends Section {\n  constructor(tagName=DEFAULT_TAG_NAME$1, items=[], attributes={}) {\n    super(LIST_SECTION_TYPE);\n    this.tagName = tagName;\n    this.isListSection = true;\n    this.isLeafSection = false;\n\n    attributable(this);\n    entries(attributes).forEach(([k,v]) => this.setAttribute(k, v));\n\n    this.items = new LinkedList({\n      adoptItem: i => {\n        assert(`Cannot insert non-list-item to list (is: ${i.type})`,\n               i.isListItem);\n        i.section = i.parent = this;\n      },\n      freeItem:  i => i.section = i.parent = null\n    });\n    this.sections = this.items;\n\n    items.forEach(i => this.items.append(i));\n  }\n\n  canJoin() {\n    return false;\n  }\n\n  isValidTagName(normalizedTagName) {\n    return contains(VALID_LIST_SECTION_TAGNAMES, normalizedTagName);\n  }\n\n  headPosition() {\n    return this.items.head.headPosition();\n  }\n\n  tailPosition() {\n    return this.items.tail.tailPosition();\n  }\n\n  get isBlank() {\n    return this.items.isEmpty;\n  }\n\n  clone() {\n    let newSection = this.builder.createListSection(this.tagName);\n    forEach(this.items, i => newSection.items.append(i.clone()));\n    return newSection;\n  }\n\n  /**\n   * Mutates this list\n   * @param {ListSection|Markerable}\n   * @return null\n   */\n  join(other) {\n    if (other.isListSection) {\n      other.items.forEach(i => this.join(i));\n    } else if (other.isMarkerable) {\n      let item = this.builder.createListItem();\n      item.join(other);\n      this.items.append(item);\n    }\n  }\n}\n\nconst VALID_LIST_ITEM_TAGNAMES = [\n  'li'\n].map(normalizeTagName);\n\nclass ListItem extends Markerable {\n  constructor(tagName, markers=[]) {\n    super(LIST_ITEM_TYPE, tagName, markers);\n    this.isListItem = true;\n    this.isNested = true;\n  }\n\n  isValidTagName(normalizedTagName) {\n    return contains(VALID_LIST_ITEM_TAGNAMES, normalizedTagName);\n  }\n\n  splitAtMarker(marker, offset=0) {\n    // FIXME need to check if we are going to split into two list items\n    // or a list item and a new markup section:\n    const isLastItem = !this.next;\n    const createNewSection = (!marker && offset === 0 && isLastItem);\n\n    let [beforeSection, afterSection] = [\n      this.builder.createListItem(),\n      createNewSection ? this.builder.createMarkupSection() :\n                         this.builder.createListItem()\n    ];\n\n    return this._redistributeMarkers(\n      beforeSection, afterSection, marker, offset);\n  }\n\n  get post() {\n    return this.section.post;\n  }\n}\n\nconst VALID_MARKUP_TAGNAMES = [\n  'a',\n  'b',\n  'code',\n  'em',\n  'i',\n  's',   // strikethrough\n  'del', // deleted text (also strikethrough)\n  'strong',\n  'sub', // subscript\n  'sup', // superscript\n  'u'\n].map(normalizeTagName);\n\nconst VALID_ATTRIBUTES$1 = [\n  'href',\n  'rel'\n];\n\n/**\n * A Markup is similar with an inline HTML tag that might be added to\n * text to modify its meaning and/or display. Examples of types of markup\n * that could be added are bold ('b'), italic ('i'), strikethrough ('s'), and `a` tags (links).\n * @property {String} tagName\n */\nclass Markup {\n  /*\n   * @param {Object} attributes key-values\n   */\n  constructor(tagName, attributes={}) {\n    this.tagName = normalizeTagName(tagName);\n\n    assert('Must use attributes object param (not array) for Markup',\n           !Array.isArray(attributes));\n\n    this.attributes = filterObject(attributes, VALID_ATTRIBUTES$1);\n    this.type = MARKUP_TYPE;\n\n    assert(`Cannot create markup of tagName ${tagName}`,\n           VALID_MARKUP_TAGNAMES.indexOf(this.tagName) !== -1);\n  }\n\n  /**\n   * Whether text in the forward direction of the cursor (i.e. to the right in ltr text)\n   * should be considered to have this markup applied to it.\n   * @private\n   */\n  isForwardInclusive() {\n    return this.tagName === normalizeTagName(\"a\") ? false : true;\n  }\n\n  isBackwardInclusive() {\n    return false;\n  }\n\n  hasTag(tagName) {\n    return this.tagName === normalizeTagName(tagName);\n  }\n\n  /**\n   * Returns the attribute value\n   * @param {String} name, e.g. \"href\"\n   */\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n\n  static isValidElement(element) {\n    const tagName = normalizeTagName(element.tagName);\n    return VALID_MARKUP_TAGNAMES.indexOf(tagName) !== -1;\n  }\n}\n\nconst SKIPPABLE_ELEMENT_TAG_NAMES = [\n  'style', 'head', 'title', 'meta'\n].map(normalizeTagName);\n\nconst NEWLINES = /\\s*\\n\\s*/g;\nfunction sanitize(text) {\n  return text.replace(NEWLINES, ' ');\n}\n\n/**\n * parses an element into a section, ignoring any non-markup\n * elements contained within\n * @private\n */\nclass SectionParser {\n  constructor(builder, options={}) {\n    this.builder = builder;\n    this.plugins = options.plugins || [];\n  }\n\n  parse(element) {\n    if (this._isSkippable(element)) {\n      return [];\n    }\n    this.sections = [];\n    this.state = {};\n\n    this._updateStateFromElement(element);\n\n    let finished = false;\n\n    // top-level text nodes will be run through parseNode later so avoid running\n    // the node through parserPlugins twice\n    if (!isTextNode(element)) {\n      finished = this.runPlugins(element);\n    }\n\n    if (!finished) {\n      let childNodes = isTextNode(element) ? [element] : element.childNodes;\n\n      forEach(childNodes, el => {\n        this.parseNode(el);\n      });\n    }\n\n    this._closeCurrentSection();\n\n    return this.sections;\n  }\n\n  runPlugins(node) {\n    let isNodeFinished = false;\n    let env = {\n      addSection: (section) => {\n        // avoid creating empty paragraphs due to wrapper elements around\n        // parser-plugin-handled elements\n        if (this.state.section && this.state.section.isMarkerable && !this.state.section.text && !this.state.text) {\n          this.state.section = null;\n        } else {\n          this._closeCurrentSection();\n        }\n        this.sections.push(section);\n      },\n      addMarkerable: (marker) => {\n        let { state } = this;\n        let { section } = state;\n        // if the first element doesn't create it's own state and it's plugin\n        // handler uses `addMarkerable` we won't have a section yet\n        if (!section) {\n          state.text = '';\n          state.section = this.builder.createMarkupSection(normalizeTagName('p'));\n          section = state.section;\n        }\n        assert(\n          'Markerables can only be appended to markup sections and list item sections',\n          section && section.isMarkerable\n        );\n        if (state.text) {\n          this._createMarker();\n        }\n        section.markers.append(marker);\n      },\n      nodeFinished() {\n        isNodeFinished = true;\n      }\n    };\n    for (let i=0; i<this.plugins.length; i++) {\n      let plugin = this.plugins[i];\n      plugin(node, this.builder, env);\n      if (isNodeFinished) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /* eslint-disable complexity */\n  parseNode(node) {\n    if (!this.state.section) {\n      this._updateStateFromElement(node);\n    }\n\n    let nodeFinished = this.runPlugins(node);\n    if (nodeFinished) {\n      return;\n    }\n\n    // handle closing the current section and starting a new one if we hit a\n    // new-section-creating element.\n    if (this.state.section && !isTextNode(node) && node.tagName) {\n      let tagName = normalizeTagName(node.tagName);\n      let isListSection = contains(VALID_LIST_SECTION_TAGNAMES, tagName);\n      let isListItem = contains(VALID_LIST_ITEM_TAGNAMES, tagName);\n      let isMarkupSection = contains(VALID_MARKUP_SECTION_TAGNAMES, tagName);\n      let isNestedListSection = isListSection && this.state.section.isListItem;\n      let lastSection = this.sections[this.sections.length - 1];\n\n      // lists can continue after breaking out for a markup section,\n      // in that situation, start a new list using the same list type\n      if (isListItem && this.state.section.isMarkupSection) {\n        this._closeCurrentSection();\n        this._updateStateFromElement(node.parentElement);\n      }\n\n      // we can hit a list item after parsing a nested list, when that happens\n      // and the lists are of different types we need to make sure we switch\n      // the list type back\n      if (isListItem && lastSection && lastSection.isListSection) {\n        let parentElement = node.parentElement;\n        let parentElementTagName = normalizeTagName(parentElement.tagName);\n        if (parentElementTagName !== lastSection.tagName) {\n          this._closeCurrentSection();\n          this._updateStateFromElement(parentElement);\n        }\n      }\n\n      // if we've broken out of a list due to nested section-level elements we\n      // can hit the next list item without having a list section in the current\n      // state. In this instance we find the parent list node and use it to\n      // re-initialize the state with a new list section\n      if (\n        isListItem &&\n        !(this.state.section.isListItem || this.state.section.isListSection) &&\n        !lastSection.isListSection\n      ) {\n        this._closeCurrentSection();\n        this._updateStateFromElement(node.parentElement);\n      }\n\n      // if we have consecutive list sections of different types (ul, ol) then\n      // ensure we close the current section and start a new one\n      let isNewListSection = lastSection\n        && lastSection.isListSection\n        && this.state.section.isListItem\n        && isListSection\n        && tagName !== lastSection.tagName;\n\n      if (\n        isNewListSection ||\n        (isListSection && !isNestedListSection) ||\n        isMarkupSection ||\n        isListItem\n      ) {\n        // don't break out of the list for list items that contain a single <p>.\n        // deals with typical case of <li><p>Text</p></li><li><p>Text</p></li>\n        if (\n          this.state.section.isListItem &&\n          tagName === 'p' &&\n          !node.nextSibling &&\n          contains(VALID_LIST_ITEM_TAGNAMES, normalizeTagName(node.parentElement.tagName))\n         ) {\n          this.parseElementNode(node);\n          return;\n        }\n\n        // avoid creating empty paragraphs due to wrapper elements around\n        // section-creating elements\n        if (this.state.section.isMarkerable && !this.state.text && this.state.section.markers.length === 0) {\n          this.state.section = null;\n        } else {\n          this._closeCurrentSection();\n        }\n\n        this._updateStateFromElement(node);\n      }\n\n      if (this.state.section.isListSection) {\n        // ensure the list section is closed and added to the sections list.\n        // _closeCurrentSection handles pushing list items onto the list section\n        this._closeCurrentSection();\n\n        forEach(node.childNodes, (node) => {\n          this.parseNode(node);\n        });\n        return;\n      }\n    }\n\n    switch (node.nodeType) {\n      case NODE_TYPES.TEXT:\n        this.parseTextNode(node);\n        break;\n      case NODE_TYPES.ELEMENT:\n        this.parseElementNode(node);\n        break;\n    }\n  }\n\n  parseElementNode(element) {\n    let { state } = this;\n\n    const markups = this._markupsFromElement(element);\n    if (markups.length && state.text.length && state.section.isMarkerable) {\n      this._createMarker();\n    }\n    state.markups.push(...markups);\n\n    forEach(element.childNodes, (node) => {\n      this.parseNode(node);\n    });\n\n    if (markups.length && state.text.length && state.section.isMarkerable) {\n      // create the marker started for this node\n      this._createMarker();\n    }\n\n    // pop the current markups from the stack\n    state.markups.splice(-markups.length, markups.length);\n  }\n\n  parseTextNode(textNode) {\n    let { state } = this;\n    state.text += sanitize(textNode.textContent);\n  }\n\n  _updateStateFromElement(element) {\n    if (isCommentNode(element)) {\n      return;\n    }\n\n    let { state } = this;\n    state.section = this._createSectionFromElement(element);\n    state.markups = this._markupsFromElement(element);\n    state.text = '';\n  }\n\n  _closeCurrentSection() {\n    let { sections, state } = this;\n    let lastSection = sections[sections.length - 1];\n\n    if (!state.section) {\n      return;\n    }\n\n    // close a trailing text node if it exists\n    if (state.text.length && state.section.isMarkerable) {\n      this._createMarker();\n    }\n\n    // push listItems onto the listSection or add a new section\n    if (state.section.isListItem && lastSection && lastSection.isListSection) {\n      trimSectionText(state.section);\n      lastSection.items.append(state.section);\n    } else {\n      // avoid creating empty markup sections, especially useful for indented source\n      if (\n        state.section.isMarkerable &&\n        !state.section.text.trim() &&\n        !any(state.section.markers, marker => marker.isAtom)\n      ) {\n        state.section = null;\n        state.text = '';\n        return;\n      }\n\n      // remove empty list sections before creating a new section\n      if (lastSection && lastSection.isListSection && lastSection.items.length === 0) {\n        sections.pop();\n      }\n\n      sections.push(state.section);\n    }\n\n    state.section = null;\n    state.text = '';\n  }\n\n  _markupsFromElement(element) {\n    let { builder } = this;\n    let markups = [];\n    if (isTextNode(element)) {\n      return markups;\n    }\n\n    const tagName = normalizeTagName(element.tagName);\n    if (this._isValidMarkupForElement(tagName, element)) {\n      markups.push(builder.createMarkup(tagName, getAttributes(element)));\n    }\n\n    this._markupsFromElementStyle(element).forEach(\n      markup => markups.push(markup)\n    );\n\n    return markups;\n  }\n\n  _isValidMarkupForElement(tagName, element) {\n    if (VALID_MARKUP_TAGNAMES.indexOf(tagName) === -1) {\n      return false;\n    } else if (tagName === 'b') {\n      // google docs add a <b style=\"font-weight: normal;\"> that should not\n      // create a \"b\" markup\n      return element.style.fontWeight !== 'normal';\n    }\n    return true;\n  }\n\n  _markupsFromElementStyle(element) {\n    let { builder } = this;\n    let markups = [];\n    let { fontStyle, fontWeight } = element.style;\n    if (fontStyle === 'italic') {\n      markups.push(builder.createMarkup('em'));\n    }\n    if (fontWeight === 'bold' || fontWeight === '700') {\n      markups.push(builder.createMarkup('strong'));\n    }\n    return markups;\n  }\n\n  _createMarker() {\n    let { state } = this;\n    let text = transformHTMLText(state.text);\n    let marker = this.builder.createMarker(text, state.markups);\n    state.section.markers.append(marker);\n    state.text = '';\n  }\n\n  _getSectionDetails(element) {\n    let sectionType,\n        tagName,\n        inferredTagName = false;\n\n    if (isTextNode(element)) {\n      tagName = DEFAULT_TAG_NAME;\n      sectionType = MARKUP_SECTION_TYPE;\n      inferredTagName = true;\n    } else {\n      tagName = normalizeTagName(element.tagName);\n\n      // blockquote>p is valid html and should be treated as a blockquote section\n      // rather than a plain markup section\n      if (\n        tagName === 'p' &&\n        element.parentElement &&\n        normalizeTagName(element.parentElement.tagName) === 'blockquote'\n      ) {\n        tagName = 'blockquote';\n      }\n\n      if (contains(VALID_LIST_SECTION_TAGNAMES, tagName)) {\n        sectionType = LIST_SECTION_TYPE;\n      } else if (contains(VALID_LIST_ITEM_TAGNAMES, tagName)) {\n        sectionType = LIST_ITEM_TYPE;\n      } else if (contains(VALID_MARKUP_SECTION_TAGNAMES, tagName)) {\n        sectionType = MARKUP_SECTION_TYPE;\n      } else {\n        sectionType = MARKUP_SECTION_TYPE;\n        tagName = DEFAULT_TAG_NAME;\n        inferredTagName = true;\n      }\n    }\n\n    return {sectionType, tagName, inferredTagName};\n  }\n\n  _createSectionFromElement(element) {\n    if (isCommentNode(element)) {\n      return;\n    }\n\n    let { builder } = this;\n    let section;\n    let {tagName, sectionType, inferredTagName} =\n      this._getSectionDetails(element);\n\n    switch (sectionType) {\n      case LIST_SECTION_TYPE:\n        section = builder.createListSection(tagName);\n        break;\n      case LIST_ITEM_TYPE:\n        section = builder.createListItem();\n        break;\n      case MARKUP_SECTION_TYPE:\n        section = builder.createMarkupSection(tagName);\n        section._inferredTagName = inferredTagName;\n        break;\n      default:\n        assert('Cannot parse section from element', false);\n    }\n\n    return section;\n  }\n\n  _isSkippable(element) {\n    return element.nodeType === NODE_TYPES.ELEMENT &&\n           contains(SKIPPABLE_ELEMENT_TAG_NAMES,\n                    normalizeTagName(element.tagName));\n  }\n}\n\nconst GOOGLE_DOCS_CONTAINER_ID_REGEX = /^docs\\-internal\\-guid/;\n\nconst NO_BREAK_SPACE_REGEX = new RegExp(NO_BREAK_SPACE, 'g');\nconst TAB_CHARACTER_REGEX = new RegExp(TAB_CHARACTER, 'g');\nfunction transformHTMLText(textContent) {\n  let text = textContent;\n  text = text.replace(NO_BREAK_SPACE_REGEX, ' ');\n  text = text.replace(TAB_CHARACTER_REGEX, TAB);\n  return text;\n}\n\nfunction trimSectionText(section) {\n  if (section.isMarkerable && section.markers.length) {\n    let { head, tail } = section.markers;\n    head.value = head.value.replace(/^\\s+/, '');\n    tail.value = tail.value.replace(/\\s+$/, '');\n  }\n}\n\nfunction isGoogleDocsContainer(element) {\n  return !isTextNode(element) &&\n         !isCommentNode(element) &&\n         normalizeTagName(element.tagName) === normalizeTagName('b') &&\n         GOOGLE_DOCS_CONTAINER_ID_REGEX.test(element.id);\n}\n\nfunction detectRootElement(element) {\n  let childNodes = element.childNodes || [];\n  let googleDocsContainer = detect(childNodes, isGoogleDocsContainer);\n\n  if (googleDocsContainer) {\n    return googleDocsContainer;\n  } else {\n    return element;\n  }\n}\n\nconst TAG_REMAPPING = {\n  'b': 'strong',\n  'i': 'em'\n};\n\nfunction remapTagName(tagName) {\n  let normalized = normalizeTagName(tagName);\n  let remapped = TAG_REMAPPING[normalized];\n  return remapped || normalized;\n}\n\nfunction trim(str) {\n  return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n}\n\nfunction walkMarkerableNodes(parent, callback) {\n  let currentNode = parent;\n\n  if (\n    isTextNode(currentNode) ||\n    (\n      isElementNode(currentNode) &&\n      currentNode.classList.contains(ATOM_CLASS_NAME)\n    )\n  ) {\n    callback(currentNode);\n  } else {\n    currentNode = currentNode.firstChild;\n    while (currentNode) {\n      walkMarkerableNodes(currentNode, callback);\n      currentNode = currentNode.nextSibling;\n    }\n  }\n}\n\n/**\n * Parses DOM element -> Post\n * @private\n */\nclass DOMParser {\n  constructor(builder, options={}) {\n    this.builder = builder;\n    this.sectionParser = new SectionParser(this.builder, options);\n  }\n\n  parse(element) {\n    const post = this.builder.createPost();\n    let rootElement = detectRootElement(element);\n\n    this._eachChildNode(rootElement, child => {\n      let sections = this.parseSections(child);\n      this.appendSections(post, sections);\n    });\n\n    // trim leading/trailing whitespace of markerable sections to avoid\n    // unnessary whitespace from indented HTML input\n    forEach(post.sections, section => trimSectionText(section));\n\n    return post;\n  }\n\n  appendSections(post, sections) {\n    forEach(sections, section => this.appendSection(post, section));\n  }\n\n  appendSection(post, section) {\n    if (\n      section.isBlank ||\n      (section.isMarkerable &&\n        trim(section.text) === \"\" &&\n        !any(section.markers, marker => marker.isAtom))\n    ) {\n      return;\n    }\n\n    let lastSection = post.sections.tail;\n    if (lastSection &&\n        lastSection._inferredTagName &&\n        section._inferredTagName &&\n        lastSection.tagName === section.tagName) {\n      lastSection.join(section);\n    } else {\n      post.sections.append(section);\n    }\n  }\n\n  _eachChildNode(element, callback) {\n    let nodes = isTextNode(element) ? [element] : element.childNodes;\n    forEach(nodes, node => callback(node));\n  }\n\n  parseSections(element) {\n    return this.sectionParser.parse(element);\n  }\n\n  // walk up from the textNode until the rootNode, converting each\n  // parentNode into a markup\n  collectMarkups(textNode, rootNode) {\n    let markups = [];\n    let currentNode = textNode.parentNode;\n    while (currentNode && currentNode !== rootNode) {\n      let markup = this.markupFromNode(currentNode);\n      if (markup) {\n        markups.push(markup);\n      }\n\n      currentNode = currentNode.parentNode;\n    }\n    return markups;\n  }\n\n  // Turn an element node into a markup\n  markupFromNode(node) {\n    if (Markup.isValidElement(node)) {\n      let tagName = remapTagName(node.tagName);\n      let attributes = getAttributes(node);\n      return this.builder.createMarkup(tagName, attributes);\n    }\n  }\n\n  // FIXME should move to the section parser?\n  // FIXME the `collectMarkups` logic could simplify the section parser?\n  reparseSection(section, renderTree) {\n    switch (section.type) {\n      case LIST_SECTION_TYPE:\n        return this.reparseListSection(section, renderTree);\n      case LIST_ITEM_TYPE:\n        return this.reparseListItem(section, renderTree);\n      case MARKUP_SECTION_TYPE:\n        return this.reparseMarkupSection(section, renderTree);\n      default:\n        return; // can only parse the above types\n    }\n  }\n\n  reparseMarkupSection(section, renderTree) {\n    return this._reparseSectionContainingMarkers(section, renderTree);\n  }\n\n  reparseListItem(listItem, renderTree) {\n    return this._reparseSectionContainingMarkers(listItem, renderTree);\n  }\n\n  reparseListSection(listSection, renderTree) {\n    listSection.items.forEach(li => this.reparseListItem(li, renderTree));\n  }\n\n  _reparseSectionContainingMarkers(section, renderTree) {\n    let element = section.renderNode.element;\n    let seenRenderNodes = [];\n    let previousMarker;\n\n    walkMarkerableNodes(element, (node) => {\n      let marker;\n      let renderNode = renderTree.getElementRenderNode(node);\n      if (renderNode) {\n        if (renderNode.postNode.isMarker) {\n          let text = transformHTMLText(node.textContent);\n          let markups = this.collectMarkups(node, element);\n          if (text.length) {\n            marker = renderNode.postNode;\n            marker.value = text;\n            marker.markups = markups;\n          } else {\n            renderNode.scheduleForRemoval();\n          }\n        } else if (renderNode.postNode.isAtom) {\n          let { headTextNode, tailTextNode } = renderNode;\n          if (headTextNode.textContent !== ZWNJ) {\n            let value = headTextNode.textContent.replace(new RegExp(ZWNJ, 'g'), '');\n            headTextNode.textContent = ZWNJ;\n            if (previousMarker && previousMarker.isMarker) {\n              previousMarker.value += value;\n              if (previousMarker.renderNode) {\n                previousMarker.renderNode.markDirty();\n              }\n            } else {\n              let postNode = renderNode.postNode;\n              let newMarkups = postNode.markups.slice();\n              let newPreviousMarker = this.builder.createMarker(value, newMarkups);\n              section.markers.insertBefore(newPreviousMarker, postNode);\n\n              let newPreviousRenderNode = renderTree.buildRenderNode(newPreviousMarker);\n              newPreviousRenderNode.markDirty();\n              section.renderNode.markDirty();\n\n              seenRenderNodes.push(newPreviousRenderNode);\n              section.renderNode.childNodes.insertBefore(newPreviousRenderNode,\n                                                         renderNode);\n            }\n          }\n          if (tailTextNode.textContent !== ZWNJ) {\n            let value = tailTextNode.textContent.replace(new RegExp(ZWNJ, 'g'), '');\n            tailTextNode.textContent = ZWNJ;\n\n            if (renderNode.postNode.next && renderNode.postNode.next.isMarker) {\n              let nextMarker = renderNode.postNode.next;\n\n              if (nextMarker.renderNode) {\n                let nextValue = nextMarker.renderNode.element.textContent;\n                nextMarker.renderNode.element.textContent = value + nextValue;\n              } else {\n                let nextValue = value + nextMarker.value;\n                nextMarker.value = nextValue;\n              }\n            } else {\n              let postNode = renderNode.postNode;\n              let newMarkups = postNode.markups.slice();\n              let newMarker = this.builder.createMarker(value, newMarkups);\n\n              section.markers.insertAfter(newMarker, postNode);\n\n              let newRenderNode = renderTree.buildRenderNode(newMarker);\n              seenRenderNodes.push(newRenderNode);\n\n              newRenderNode.markDirty();\n              section.renderNode.markDirty();\n\n              section.renderNode.childNodes.insertAfter(newRenderNode, renderNode);\n            }\n          }\n          if (renderNode) {\n            marker = renderNode.postNode;\n          }\n        }\n      } else if (isTextNode(node)) {\n        let text = transformHTMLText(node.textContent);\n        let markups = this.collectMarkups(node, element);\n        marker = this.builder.createMarker(text, markups);\n\n        renderNode = renderTree.buildRenderNode(marker);\n        renderNode.element = node;\n        renderNode.markClean();\n        section.renderNode.markDirty();\n\n        let previousRenderNode = previousMarker && previousMarker.renderNode;\n        section.markers.insertAfter(marker, previousMarker);\n        section.renderNode.childNodes.insertAfter(renderNode, previousRenderNode);\n      }\n\n      if (renderNode) {\n        seenRenderNodes.push(renderNode);\n      }\n      previousMarker = marker;\n    });\n\n    let renderNode = section.renderNode.childNodes.head;\n    while (renderNode) {\n      if (seenRenderNodes.indexOf(renderNode) === -1) {\n        renderNode.scheduleForRemoval();\n      }\n      renderNode = renderNode.next;\n    }\n  }\n}\n\nclass HTMLParser {\n  constructor(builder, options={}) {\n    assert('Must pass builder to HTMLParser', builder);\n    this.builder = builder;\n    this.options = options;\n  }\n\n  /**\n   * @param {String} html to parse\n   * @return {Post} A post abstract\n   */\n  parse(html) {\n    let dom = parseHTML(html);\n    let parser = new DOMParser(this.builder, this.options);\n    return parser.parse(dom);\n  }\n}\n\nclass RenderNode extends LinkedItem {\n  constructor(postNode, renderTree) {\n    super();\n    this.parent = null;\n    this.isDirty = true;\n    this.isRemoved = false;\n    this.postNode = postNode;\n    this._childNodes = null;\n    this._element = null;\n    this._cursorElement = null; // blank render nodes need a cursor element\n    this.renderTree = renderTree;\n\n    // RenderNodes for Markers keep track of their markupElement\n    this.markupElement = null;\n\n    // RenderNodes for Atoms use these properties\n    this.headTextNode = null;\n    this.tailTextNode = null;\n    this.atomNode = null;\n\n    // RenderNodes for cards use this property\n    this.cardNode = null;\n  }\n  isAttached() {\n    assert('Cannot check if a renderNode is attached without an element.',\n           !!this.element);\n    return containsNode(this.renderTree.rootElement, this.element);\n  }\n  get childNodes() {\n    if (!this._childNodes) {\n      this._childNodes = new LinkedList({\n        adoptItem: item => item.parent = this,\n        freeItem: item => item.destroy()\n      });\n    }\n    return this._childNodes;\n  }\n  scheduleForRemoval() {\n    this.isRemoved = true;\n    if (this.parent) { this.parent.markDirty(); }\n  }\n  markDirty() {\n    this.isDirty = true;\n    if (this.parent) { this.parent.markDirty(); }\n  }\n  get isRendered() {\n    return !!this.element;\n  }\n  markClean() {\n    this.isDirty = false;\n  }\n  set element(element) {\n    const currentElement = this._element;\n    this._element = element;\n\n    if (currentElement) {\n      this.renderTree.removeElementRenderNode(currentElement);\n    }\n\n    if (element) {\n      this.renderTree.setElementRenderNode(element, this);\n    }\n  }\n  get element() {\n    return this._element;\n  }\n  set cursorElement(cursorElement) {\n    this._cursorElement = cursorElement;\n  }\n  get cursorElement() {\n    return this._cursorElement || this.element;\n  }\n  destroy() {\n    this.element = null;\n    this.parent = null;\n    this.postNode = null;\n    this.renderTree = null;\n  }\n  reparsesMutationOfChildNode(node) {\n    if (this.postNode.isCardSection) {\n      return !containsNode(this.cardNode.element, node);\n    } else if (this.postNode.isAtom) {\n      return !containsNode(this.atomNode.element, node);\n    }\n    return true;\n  }\n}\n\n// start at one to make the falsy semantics easier\nlet uuidGenerator = 1;\n\nclass ElementMap {\n  constructor() {\n    this._map = {};\n  }\n  set(key, value) {\n    let uuid = key._uuid;\n    if (!uuid) {\n      key._uuid = uuid = '' + uuidGenerator++;\n    }\n    this._map[uuid] = value;\n  }\n  get(key) {\n    if (key._uuid) {\n      return this._map[key._uuid];\n    }\n    return null;\n  }\n  remove(key) {\n    assert('tried to fetch a value for an element not seen before', !!key._uuid);\n    delete this._map[key._uuid];\n  }\n\n}\n\nclass RenderTree {\n  constructor(rootPostNode) {\n    this._rootNode = this.buildRenderNode(rootPostNode);\n    this._elements = new ElementMap();\n  }\n  /*\n   * @return {RenderNode} The root render node in this tree\n   */\n  get rootNode() {\n    return this._rootNode;\n  }\n  /**\n   * @return {Boolean}\n   */\n  get isDirty() {\n    return this.rootNode && this.rootNode.isDirty;\n  }\n  /*\n   * @return {DOMNode} The root DOM element in this tree\n   */\n  get rootElement() {\n    return this.rootNode.element;\n  }\n  /*\n   * @param {DOMNode} element\n   * @return {RenderNode} The renderNode for this element, if any\n   */\n  getElementRenderNode(element) {\n    return this._elements.get(element);\n  }\n  setElementRenderNode(element, renderNode) {\n    this._elements.set(element, renderNode);\n  }\n  removeElementRenderNode(element) {\n    this._elements.remove(element);\n  }\n  /**\n   * @param {DOMNode} element\n   * Walk up from the dom element until we find a renderNode element\n   */\n  findRenderNodeFromElement(element, conditionFn=()=>true) {\n    let renderNode;\n    while (element) {\n      renderNode = this.getElementRenderNode(element);\n      if (renderNode && conditionFn(renderNode)) {\n        return renderNode;\n      }\n\n      // continue loop\n      element = element.parentNode;\n\n      // stop if we are at the root element\n      if (element === this.rootElement) {\n        if (conditionFn(this.rootNode)) {\n          return this.rootNode;\n        } else {\n          return;\n        }\n      }\n    }\n  }\n  buildRenderNode(postNode) {\n    const renderNode = new RenderNode(postNode, this);\n    postNode.renderNode = renderNode;\n    return renderNode;\n  }\n}\n\nconst MOBILEDOC_VERSION$4 = MOBILEDOC_VERSION$3;\n\nvar mobiledocRenderers = {\n  render(post, version) {\n    switch (version) {\n      case MOBILEDOC_VERSION:\n        return MobiledocRenderer_0_2.render(post);\n      case MOBILEDOC_VERSION$1:\n        return MobiledocRenderer_0_3.render(post);\n      case MOBILEDOC_VERSION$2:\n        return MobiledocRenderer_0_3_1.render(post);\n      case undefined:\n      case null:\n      case MOBILEDOC_VERSION$3:\n        return MobiledocRenderer_0_3_2.render(post);\n      default:\n        assert(`Unknown version of mobiledoc renderer requested: ${version}`, false);\n    }\n  }\n};\n\nfunction mergeWithOptions(original, updates, options) {\n  options = options || {};\n  for(var prop in updates) {\n    if (options.hasOwnProperty(prop)) {\n      original[prop] = options[prop];\n    } else if (updates.hasOwnProperty(prop)) {\n      original[prop] = updates[prop];\n    }\n  }\n  return original;\n}\n\nconst Cursor = class Cursor {\n  constructor(editor) {\n    this.editor = editor;\n    this.renderTree = editor._renderTree;\n    this.post = editor.post;\n  }\n\n  clearSelection() {\n    clearSelection();\n  }\n\n  /**\n   * @return {Boolean} true when there is either a collapsed cursor in the\n   * editor's element or a selection that is contained in the editor's element\n   */\n  hasCursor() {\n    return this.editor.hasRendered &&\n           (this._hasCollapsedSelection() || this._hasSelection());\n  }\n\n  hasSelection() {\n    return this.editor.hasRendered &&\n           this._hasSelection();\n  }\n\n  /**\n   * @return {Boolean} Can the cursor be on this element?\n   */\n  isAddressable(element) {\n    let { renderTree } = this;\n    let renderNode = renderTree.findRenderNodeFromElement(element);\n    if (renderNode && renderNode.postNode.isCardSection) {\n      let renderedElement = renderNode.element;\n\n      // card sections have addressable text nodes containing &zwnj;\n      // as their first and last child\n      if (element !== renderedElement &&\n          element !== renderedElement.firstChild &&\n          element !== renderedElement.lastChild) {\n        return false;\n      }\n    }\n\n    return !!renderNode;\n  }\n\n  /*\n   * @return {Range} Cursor#Range object\n   */\n  get offsets() {\n    if (!this.hasCursor()) { return Range.blankRange(); }\n\n    let { selection, renderTree } = this;\n    let parentNode = this.editor.element;\n    selection = constrainSelectionTo(selection, parentNode);\n\n    const {\n      headNode, headOffset, tailNode, tailOffset, direction\n    } = comparePosition(selection);\n\n    const headPosition = Position$1.fromNode(renderTree, headNode, headOffset);\n    const tailPosition = Position$1.fromNode(renderTree, tailNode, tailOffset);\n\n    return new Range(headPosition, tailPosition, direction);\n  }\n\n  _findNodeForPosition(position) {\n    let { section } = position;\n    let node, offset;\n    if (section.isCardSection) {\n      offset = 0;\n      if (position.offset === 0) {\n        node = section.renderNode.element.firstChild;\n      } else {\n        node = section.renderNode.element.lastChild;\n      }\n    } else if (section.isBlank) {\n      node = section.renderNode.cursorElement;\n      offset = 0;\n    } else {\n      let {marker, offsetInMarker} = position;\n      if (marker.isAtom) {\n        if (offsetInMarker > 0) {\n          // FIXME -- if there is a next marker, focus on it?\n          offset = 0;\n          node = marker.renderNode.tailTextNode;\n        } else {\n          offset = 0;\n          node = marker.renderNode.headTextNode;\n        }\n      } else {\n        node = marker.renderNode.element;\n        offset = offsetInMarker;\n      }\n    }\n\n    return {node, offset};\n  }\n\n  selectRange(range) {\n    if (range.isBlank) {\n      this.clearSelection();\n      return;\n    }\n\n    const { head, tail, direction } = range;\n    const { node:headNode, offset:headOffset } = this._findNodeForPosition(head),\n          { node:tailNode, offset:tailOffset } = this._findNodeForPosition(tail);\n    this._moveToNode(headNode, headOffset, tailNode, tailOffset, direction);\n\n    // Firefox sometimes doesn't keep focus in the editor after adding a card\n    this.editor._ensureFocus();\n  }\n\n  get selection() {\n    return window.getSelection();\n  }\n\n  selectedText() {\n    // FIXME remove this\n    return this.selection.toString();\n  }\n\n  /**\n   * @param {textNode} node\n   * @param {integer} offset\n   * @param {textNode} endNode\n   * @param {integer} endOffset\n   * @param {integer} direction forward or backward, default forward\n   * @private\n   */\n  _moveToNode(node, offset, endNode, endOffset, direction=DIRECTION.FORWARD) {\n    this.clearSelection();\n\n    if (direction === DIRECTION.BACKWARD) {\n      [node, offset, endNode, endOffset] = [ endNode, endOffset, node, offset ];\n    }\n\n    const range = document.createRange();\n    range.setStart(node, offset);\n    if (direction === DIRECTION.BACKWARD && !!this.selection.extend) {\n      this.selection.addRange(range);\n      this.selection.extend(endNode, endOffset);\n    } else {\n      range.setEnd(endNode, endOffset);\n      this.selection.addRange(range);\n    }\n  }\n\n  _hasSelection() {\n    const element = this.editor.element;\n    const { _selectionRange } = this;\n    if (!_selectionRange || _selectionRange.collapsed) { return false; }\n\n    return containsNode(element, this.selection.anchorNode) &&\n           containsNode(element, this.selection.focusNode);\n  }\n\n  _hasCollapsedSelection() {\n    const { _selectionRange } = this;\n    if (!_selectionRange) { return false; }\n\n    const element = this.editor.element;\n    return containsNode(element, this.selection.anchorNode);\n  }\n\n  get _selectionRange() {\n    const { selection } = this;\n    if (selection.rangeCount === 0) { return null; }\n    return selection.getRangeAt(0);\n  }\n};\n\nvar Environment = {\n  hasDOM() {\n    return typeof document !== 'undefined';\n  }\n};\n\nconst ATOM_LENGTH = 1;\n\nclass Atom extends LinkedItem {\n  constructor(name, value, payload, markups=[]) {\n    super();\n    this.name = name;\n    this.value = value;\n    this.text = ''; // An atom never has text, but it does have a value\n    assert('Atom must have value', value !== undefined && value !== null);\n    this.payload = payload;\n    this.type = ATOM_TYPE;\n    this.isMarker = false;\n    this.isAtom = true;\n\n    this.markups = [];\n    markups.forEach(m => this.addMarkup(m));\n  }\n\n  clone() {\n    let clonedMarkups = this.markups.slice();\n    return this.builder.createAtom(\n      this.name, this.value, this.payload, clonedMarkups\n    );\n  }\n\n  get isBlank() {\n    return false;\n  }\n\n  get length() {\n    return ATOM_LENGTH;\n  }\n\n  canJoin(/* other */) {\n    return false;\n  }\n\n  textUntil(/* offset */) {\n    return '';\n  }\n\n  split(offset=0, endOffset=offset) {\n    let markers = [];\n\n    if (endOffset === 0) {\n      markers.push(this.builder.createMarker('', this.markups.slice()));\n    }\n\n    markers.push(this.clone());\n\n    if (offset === ATOM_LENGTH) {\n      markers.push(this.builder.createMarker('', this.markups.slice()));\n    }\n\n    return markers;\n  }\n\n  splitAtOffset(offset) {\n    assert('Cannot split a marker at an offset > its length',\n           offset <= this.length);\n\n    let { builder } = this;\n    let clone = this.clone();\n    let blankMarker = builder.createMarker('');\n    let pre, post;\n\n    if (offset === 0) {\n      ([pre, post] = [blankMarker, clone]);\n    } else if (offset === ATOM_LENGTH) {\n      ([pre, post] = [clone, blankMarker]);\n    } else {\n      assert(`Invalid offset given to Atom#splitAtOffset: \"${offset}\"`, false);\n    }\n\n    this.markups.forEach(markup => {\n      pre.addMarkup(markup);\n      post.addMarkup(markup);\n    });\n    return [pre, post];\n  }\n}\n\nmixin(Atom, Markerupable);\n\n/**\n * The Post is an in-memory representation of an editor's document.\n * An editor always has a single post. The post is organized into a list of\n * sections. Each section may be markerable (contains \"markers\", aka editable\n * text) or non-markerable (e.g., a card).\n * When persisting a post, it must first be serialized (loss-lessly) into\n * mobiledoc using {@link Editor#serialize}.\n */\nclass Post {\n  /**\n   * @private\n   */\n  constructor() {\n    this.type = POST_TYPE;\n    this.sections = new LinkedList({\n      adoptItem: s => s.post = s.parent = this,\n      freeItem: s => s.post = s.parent = null\n    });\n  }\n\n  /**\n   * @return {Position} The position at the start of the post (will be a {@link BlankPosition}\n   * if the post is blank)\n   * @public\n   */\n  headPosition() {\n    if (this.isBlank) {\n      return Position$1.blankPosition();\n    } else {\n      return this.sections.head.headPosition();\n    }\n  }\n\n  /**\n   * @return {Position} The position at the end of the post (will be a {@link BlankPosition}\n   * if the post is blank)\n   * @public\n   */\n  tailPosition() {\n    if (this.isBlank) {\n      return Position$1.blankPosition();\n    } else {\n      return this.sections.tail.tailPosition();\n    }\n  }\n\n  /**\n   * @return {Range} A range encompassing the entire post\n   * @public\n   */\n  toRange() {\n    return this.headPosition().toRange(this.tailPosition());\n  }\n\n  get isBlank() {\n    return this.sections.isEmpty;\n  }\n\n  /**\n   * If the post has no sections, or only has one, blank section, then it does\n   * not have content and this method returns false. Otherwise it is true.\n   * @return {Boolean}\n   * @public\n   */\n  get hasContent() {\n    if ((this.sections.length > 1) ||\n        (this.sections.length === 1 && !this.sections.head.isBlank)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @param {Range} range\n   * @return {Array} markers that are completely contained by the range\n   */\n  markersContainedByRange(range) {\n    const markers = [];\n\n    this.walkMarkerableSections(range, section => {\n      section._markersInRange(\n        range.trimTo(section),\n        (m, {isContained}) => { if (isContained) { markers.push(m); } }\n      );\n    });\n\n    return markers;\n  }\n\n  markupsInRange(range) {\n    const markups = new Set();\n\n    if (range.isCollapsed) {\n      let pos = range.head;\n      if (pos.isMarkerable) {\n        let [back, forward] = [pos.markerIn(-1), pos.markerIn(1)];\n        if (back && forward && back === forward) {\n          back.markups.forEach(m => markups.add(m));\n        } else {\n          (back && back.markups || []).forEach(m => {\n            if (m.isForwardInclusive()) {\n              markups.add(m);\n            }\n          });\n          (forward && forward.markups || []).forEach(m => {\n            if (m.isBackwardInclusive()) {\n              markups.add(m);\n            }\n          });\n        }\n      }\n    } else {\n      this.walkMarkerableSections(range, (section) => {\n        forEach(\n          section.markupsInRange(range.trimTo(section)),\n          m => markups.add(m)\n        );\n      });\n    }\n\n    return markups.toArray();\n  }\n\n  walkAllLeafSections(callback) {\n    let range = this.headPosition().toRange(this.tailPosition());\n    return this.walkLeafSections(range, callback);\n  }\n\n  walkLeafSections(range, callback) {\n    const { head, tail } = range;\n\n    let index = 0;\n    let nextSection, shouldStop;\n    let currentSection = head.section;\n\n    while (currentSection) {\n      nextSection = this._nextLeafSection(currentSection);\n      shouldStop = currentSection === tail.section;\n\n      callback(currentSection, index);\n      index++;\n\n      if (shouldStop) {\n        break;\n      } else {\n        currentSection = nextSection;\n      }\n    }\n  }\n\n  walkMarkerableSections(range, callback) {\n    this.walkLeafSections(range, section => {\n      if (section.isMarkerable) {\n        callback(section);\n      }\n    });\n  }\n\n  // return the next section that has markers after this one,\n  // possibly skipping non-markerable sections\n  _nextLeafSection(section) {\n    if (!section) { return null; }\n\n    const next = section.next;\n    if (next) {\n      if (next.isLeafSection) {\n        return next;\n      } else if (next.items) {\n        return next.items.head;\n      } else {\n        assert('Cannot determine next section from non-leaf-section', false);\n      }\n    } else if (section.isNested) {\n      // if there is no section after this, but this section is a child\n      // (e.g. a ListItem inside a ListSection), check for a markerable\n      // section after its parent\n      return this._nextLeafSection(section.parent);\n    }\n  }\n\n  /**\n   * @param {Range} range\n   * @return {Post} A new post, constrained to {range}\n   */\n  trimTo(range) {\n    const post = this.builder.createPost();\n    const { builder } = this;\n    const { head, tail } = range;\n    const tailNotSelected = tail.offset === 0 && head.section !== tail.section;\n\n    let sectionParent = post,\n        listParent = null;\n    this.walkLeafSections(range, section => {\n      let newSection;\n      if (section.isMarkerable) {\n        if (section.isListItem) {\n          if (listParent) {\n            sectionParent = null;\n          } else {\n            listParent = builder.createListSection(section.parent.tagName);\n            post.sections.append(listParent);\n            sectionParent = null;\n          }\n          newSection = builder.createListItem();\n          listParent.items.append(newSection);\n        } else {\n          listParent = null;\n          sectionParent = post;\n          const tagName = tailNotSelected && tail.section === section ?\n              'p' :\n              section.tagName;\n          newSection = builder.createMarkupSection(tagName);\n        }\n\n        let currentRange = range.trimTo(section);\n        forEach(\n          section.markersFor(currentRange.headSectionOffset, currentRange.tailSectionOffset),\n          m => newSection.markers.append(m)\n        );\n      } else {\n        newSection = tailNotSelected && tail.section === section ?\n            builder.createMarkupSection('p') :\n            section.clone();\n\n        sectionParent = post;\n      }\n      if (sectionParent) {\n        sectionParent.sections.append(newSection);\n      }\n    });\n    return post;\n  }\n}\n\nclass Image extends Section {\n  constructor() {\n    super(IMAGE_SECTION_TYPE);\n    this.src = null;\n  }\n\n  canJoin() {\n    return false;\n  }\n\n  get isBlank() {\n    return false;\n  }\n\n  get length() {\n    return 1;\n  }\n}\n\nfunction shallowCopyObject(object) {\n  let copy = {};\n  Object.keys(object).forEach(key => {\n    copy[key] = object[key];\n  });\n  return copy;\n}\n\nconst CARD_MODES = {\n  DISPLAY: 'display',\n  EDIT: 'edit'\n};\n\nconst CARD_LENGTH = 1;\n\nconst DEFAULT_INITIAL_MODE = CARD_MODES.DISPLAY;\n\nclass Card extends Section {\n  constructor(name, payload) {\n    super(CARD_TYPE);\n    this.name = name;\n    this.payload = payload;\n    this.setInitialMode(DEFAULT_INITIAL_MODE);\n    this.isCardSection = true;\n  }\n\n  get isBlank() {\n    return false;\n  }\n\n  canJoin() {\n    return false;\n  }\n\n  get length() {\n    return CARD_LENGTH;\n  }\n\n  clone() {\n    let payload = shallowCopyObject(this.payload);\n    let card = this.builder.createCardSection(this.name, payload);\n    // If this card is currently rendered, clone the mode it is\n    // currently in as the default mode of the new card.\n    let mode = this._initialMode;\n    if (this.renderNode && this.renderNode.cardNode) {\n      mode = this.renderNode.cardNode.mode;\n    }\n    card.setInitialMode(mode);\n    return card;\n  }\n\n  /**\n   * set the mode that this will be rendered into initially\n   * @private\n   */\n  setInitialMode(initialMode) {\n    // TODO validate initialMode\n    this._initialMode = initialMode;\n  }\n}\n\nfunction cacheKey(tagName, attributes) {\n  return `${normalizeTagName(tagName)}-${objectToSortedKVArray(attributes).join('-')}`;\n}\n\nfunction addMarkupToCache(cache, markup) {\n  cache[cacheKey(markup.tagName, markup.attributes)] = markup;\n}\n\nfunction findMarkupInCache(cache, tagName, attributes) {\n  const key = cacheKey(tagName, attributes);\n  return cache[key];\n}\n\n/**\n * The PostNodeBuilder is used to create new {@link Post} primitives, such\n * as a MarkupSection, a CardSection, a Markup, etc. Every instance of an\n * {@link Editor} has its own builder instance. The builder can be used\n * inside an {@link Editor#run} callback to programmatically create new\n * Post primitives to insert into the document.\n * A PostNodeBuilder should be read from the Editor, *not* instantiated on its own.\n */\nclass PostNodeBuilder {\n  /**\n   * @private\n   */\n  constructor() {\n    this.markupCache = {};\n  }\n\n  /**\n   * @return {Post} A new, blank post\n   */\n  createPost(sections=[]) {\n    const post = new Post();\n    post.builder = this;\n\n    sections.forEach(s => post.sections.append(s));\n\n    return post;\n  }\n\n  createMarkerableSection(type, tagName, markers=[]) {\n    switch (type) {\n      case LIST_ITEM_TYPE:\n        return this.createListItem(markers);\n      case MARKUP_SECTION_TYPE:\n        return this.createMarkupSection(tagName, markers);\n      default:\n        assert(`Cannot create markerable section of type ${type}`, false);\n    }\n  }\n\n  /**\n   * @param {tagName} [tagName='P']\n   * @param {Marker[]} [markers=[]]\n   * @return {MarkupSection}\n   */\n  createMarkupSection(tagName=DEFAULT_TAG_NAME, markers=[], isGenerated=false, attributes={}) {\n    tagName = normalizeTagName(tagName);\n    const section = new MarkupSection(tagName, markers, attributes);\n    if (isGenerated) {\n      section.isGenerated = true;\n    }\n    section.builder = this;\n    return section;\n  }\n\n  createListSection(tagName=DEFAULT_TAG_NAME$1, items=[], attributes={}) {\n    tagName = normalizeTagName(tagName);\n    const section = new ListSection(tagName, items, attributes);\n    section.builder = this;\n    return section;\n  }\n\n  createListItem(markers=[]) {\n    const tagName = normalizeTagName('li');\n    const item = new ListItem(tagName, markers);\n    item.builder = this;\n    return item;\n  }\n\n  createImageSection(url) {\n    let section = new Image();\n    if (url) {\n      section.src = url;\n    }\n    return section;\n  }\n\n  /**\n   * @param {String} name\n   * @param {Object} [payload={}]\n   * @return {CardSection}\n   */\n  createCardSection(name, payload={}) {\n    const card = new Card(name, payload);\n    card.builder = this;\n    return card;\n  }\n\n  /**\n   * @param {String} value\n   * @param {Markup[]} [markups=[]]\n   * @return {Marker}\n   */\n  createMarker(value, markups=[]) {\n    const marker = new Marker(value, markups);\n    marker.builder = this;\n    return marker;\n  }\n\n  /**\n   * @param {String} name\n   * @param {String} [value='']\n   * @param {Object} [payload={}]\n   * @param {Markup[]} [markups=[]]\n   * @return {Atom}\n   */\n  createAtom(name, value='', payload={}, markups=[]) {\n    const atom = new Atom(name, value, payload, markups);\n    atom.builder = this;\n    return atom;\n  }\n\n  /**\n   * @param {String} tagName\n   * @param {Object} attributes Key-value pairs of attributes for the markup\n   * @return {Markup}\n   */\n  createMarkup(tagName, attributes={}) {\n    tagName = normalizeTagName(tagName);\n\n    let markup = findMarkupInCache(this.markupCache, tagName, attributes);\n    if (!markup) {\n      markup = new Markup(tagName, attributes);\n      markup.builder = this;\n      addMarkupToCache(this.markupCache, markup);\n    }\n\n    return markup;\n  }\n}\n\n/**\n * Convert section at the editor's cursor position into a list.\n * Does nothing if the cursor position is not at the start of the section,\n * or if the section is already a list item.\n *\n * @param {Editor} editor\n * @param {String} listTagName (\"ul\" or \"ol\")\n * @public\n */\nfunction replaceWithListSection(editor, listTagName) {\n  let { range: { head, head: { section } } } = editor;\n  // Skip if cursor is not at end of section\n  if (!head.isTail()) {\n    return;\n  }\n\n  if (section.isListItem) {\n    return;\n  }\n\n  editor.run(postEditor => {\n    let { builder } = postEditor;\n    let item = builder.createListItem();\n    let listSection = builder.createListSection(listTagName, [item]);\n\n    postEditor.replaceSection(section, listSection);\n    postEditor.setRange(listSection.headPosition());\n  });\n}\n\n/**\n * Convert section at the editor's cursor position into a header section.\n * Does nothing if the cursor position is not at the start of the section.\n *\n * @param {Editor} editor\n * @param {String} headingTagName ('h1', 'h2', 'h3', 'h4', 'h5', 'h6')\n * @public\n */\nfunction replaceWithHeaderSection(editor, headingTagName) {\n  let { range: { head, head: { section } } } = editor;\n  // Skip if cursor is not at end of section\n  if (!head.isTail()) {\n    return;\n  }\n\n  editor.run(postEditor => {\n    let { builder } = postEditor;\n    let newSection = builder.createMarkupSection(headingTagName);\n    postEditor.replaceSection(section, newSection);\n    postEditor.setRange(newSection.headPosition());\n  });\n}\n\nconst DEFAULT_TEXT_INPUT_HANDLERS = [\n  {\n    name: 'ul',\n    // \"* \" -> ul\n    match: /^\\* $/,\n    run(editor) {\n      replaceWithListSection(editor, 'ul');\n    }\n  },\n  {\n    name: 'ol',\n    // \"1\" -> ol, \"1.\" -> ol\n    match: /^1\\.? $/,\n    run(editor) {\n      replaceWithListSection(editor, 'ol');\n    }\n  },\n  {\n    name: 'heading',\n    /*\n     * \"# \" -> h1\n     * \"## \" -> h2\n     * \"### \" -> h3\n     * \"#### \" -> h4\n     * \"##### \" -> h5\n     * \"###### \" -> h6\n     */\n    match: /^(#{1,6}) $/,\n    run(editor, matches) {\n      let capture = matches[1];\n      let headingTag = 'h' + capture.length;\n      replaceWithHeaderSection(editor, headingTag);\n    }\n  }\n];\n\nvar Browser = {\n  isMac() {\n    return (typeof window !== 'undefined') && window.navigator && /Mac/.test(window.navigator.platform);\n  },\n  isWin() {\n    return (typeof window !== 'undefined') && window.navigator && /Win/.test(window.navigator.platform);\n  }\n};\n\nfunction selectAll(editor) {\n  let { post } = editor;\n  editor.selectRange(post.toRange());\n}\n\nfunction gotoStartOfLine(editor) {\n  let {range} = editor;\n  let {tail: {section}} = range;\n  editor.run(postEditor => {\n    postEditor.setRange(section.headPosition());\n  });\n}\n\nfunction gotoEndOfLine(editor) {\n  let {range} = editor;\n  let {tail: {section}} = range;\n  editor.run(postEditor => {\n    postEditor.setRange(section.tailPosition());\n  });\n}\n\nfunction deleteToEndOfSection(editor) {\n  let { range } = editor;\n  if (range.isCollapsed) {\n    let { head, head: { section } } = range;\n    range = head.toRange(section.tailPosition());\n  }\n  editor.run(postEditor => {\n    let nextPosition = postEditor.deleteRange(range);\n    postEditor.setRange(nextPosition);\n  });\n}\n\nconst DEFAULT_KEY_COMMANDS = [{\n  str: 'META+B',\n  run(editor) {\n    editor.toggleMarkup('strong');\n  }\n}, {\n  str: 'CTRL+B',\n  run(editor) {\n    editor.toggleMarkup('strong');\n  }\n}, {\n  str: 'META+I',\n  run(editor) {\n    editor.toggleMarkup('em');\n  }\n}, {\n  str: 'CTRL+I',\n  run(editor) {\n    editor.toggleMarkup('em');\n  }\n}, {\n  str: 'META+U',\n  run(editor) {\n    editor.toggleMarkup('u');\n  }\n}, {\n  str: 'CTRL+U',\n  run(editor) {\n    editor.toggleMarkup('u');\n  }\n}, {\n  str: 'CTRL+K',\n  run(editor) {\n    if (Browser.isMac()) {\n      return deleteToEndOfSection(editor);\n    } else if (Browser.isWin()) {\n      return toggleLink(editor);\n    }\n  }\n}, {\n  str: 'CTRL+A',\n  run(editor) {\n    if (Browser.isMac()) {\n      gotoStartOfLine(editor);\n    } else {\n      selectAll(editor);\n    }\n  }\n}, {\n  str: 'META+A',\n  run(editor) {\n    if (Browser.isMac()) {\n      selectAll(editor);\n    }\n  }\n}, {\n  str: 'CTRL+E',\n  run(editor) {\n    if (Browser.isMac()) {\n      gotoEndOfLine(editor);\n    }\n  }\n}, {\n  str: 'META+K',\n  run(editor) {\n    return toggleLink(editor);\n  },\n\n}, {\n  str: 'META+Z',\n  run(editor) {\n    editor.run(postEditor => {\n      postEditor.undoLastChange();\n    });\n  }\n}, {\n  str: 'META+SHIFT+Z',\n  run(editor) {\n    editor.run(postEditor => {\n      postEditor.redoLastChange();\n    });\n  }\n}, {\n  str: 'CTRL+Z',\n  run(editor) {\n    if (Browser.isMac()) { return false; }\n    editor.run(postEditor => postEditor.undoLastChange());\n  }\n}, {\n  str: 'CTRL+SHIFT+Z',\n  run(editor) {\n    if (Browser.isMac()) { return false; }\n    editor.run(postEditor => postEditor.redoLastChange());\n  }\n}];\n\nfunction modifierNamesToMask(modiferNames) {\n  let defaultVal = 0;\n  return reduce(modiferNames,\n                (sum, name) => {\n                  let modifier = MODIFIERS[name.toUpperCase()];\n                  assert(`No modifier named \"${name}\" found`, !!modifier);\n                  return sum + modifier;\n                },\n                defaultVal);\n}\n\nfunction characterToCode(character) {\n  const upperCharacter = character.toUpperCase();\n  const special = specialCharacterToCode(upperCharacter);\n  if (special) {\n    return special;\n  } else {\n    assert(`Only 1 character can be used in a key command str (got \"${character}\")`,\n           character.length === 1);\n    return upperCharacter.charCodeAt(0);\n  }\n}\n\nfunction buildKeyCommand(keyCommand) {\n  let { str } = keyCommand;\n\n  if (!str) {\n    return keyCommand;\n  }\n  assert('[deprecation] Key commands no longer use the `modifier` property',\n         !keyCommand.modifier);\n\n  let [character, ...modifierNames] = str.split('+').reverse();\n\n  keyCommand.modifierMask = modifierNamesToMask(modifierNames);\n  keyCommand.code = characterToCode(character);\n\n  return keyCommand;\n}\n\nfunction validateKeyCommand(keyCommand) {\n  return !!keyCommand.code && !!keyCommand.run;\n}\n\nfunction findKeyCommands(keyCommands, keyEvent) {\n  const key = Key.fromEvent(keyEvent);\n\n  return filter(keyCommands, ({modifierMask, code}) => {\n    return key.keyCode === code && key.modifierMask === modifierMask;\n  });\n}\n\nconst MUTATION = {\n  NODES_CHANGED: 'childList',\n  CHARACTER_DATA: 'characterData'\n};\n\nclass MutationHandler {\n  constructor(editor) {\n    this.editor     = editor;\n    this.logger     = editor.loggerFor('mutation-handler');\n    this.renderTree = null;\n    this._isObserving = false;\n\n    this._observer = new MutationObserver((mutations) => {\n      this._handleMutations(mutations);\n    });\n  }\n\n  init() {\n    this.startObserving();\n  }\n\n  destroy() {\n    this.stopObserving();\n    this._observer = null;\n  }\n\n  suspendObservation(callback) {\n    this.stopObserving();\n    callback();\n    this.startObserving();\n  }\n\n  stopObserving() {\n    if (this._isObserving) {\n      this._isObserving = false;\n      this._observer.disconnect();\n    }\n  }\n\n  startObserving() {\n    if (!this._isObserving) {\n      let { editor } = this;\n      assert('Cannot observe un-rendered editor', editor.hasRendered);\n\n      this._isObserving = true;\n      this.renderTree = editor._renderTree;\n\n      this._observer.observe(editor.element, {\n        characterData: true,\n        childList: true,\n        subtree: true\n      });\n    }\n  }\n\n  reparsePost() {\n    this.editor._reparsePost();\n  }\n\n  reparseSections(sections) {\n    this.editor._reparseSections(sections);\n  }\n\n  /**\n   * for each mutation:\n   *   * find the target nodes:\n   *     * if nodes changed, target nodes are:\n   *        * added nodes\n   *        * the target from which removed nodes were removed\n   *     * if character data changed\n   *       * target node is the mutation event's target (text node)\n   *     * filter out nodes that are no longer attached (parentNode is null)\n   *   * for each remaining node:\n   *   *  find its section, add to sections-to-reparse\n   *   *  if no section, reparse all (and break)\n   */\n  _handleMutations(mutations) {\n    let reparsePost = false;\n    let sections = new Set();\n\n    for (let i = 0; i < mutations.length; i++) {\n      if (reparsePost) {\n        break;\n      }\n\n      let nodes = this._findTargetNodes(mutations[i]);\n\n      for (let j=0; j < nodes.length; j++) {\n        let node = nodes[j];\n        let renderNode = this._findRenderNodeFromNode(node);\n        if (renderNode) {\n          if (renderNode.reparsesMutationOfChildNode(node)) {\n            let section = this._findSectionFromRenderNode(renderNode);\n            if (section) {\n              sections.add(section);\n            } else {\n              reparsePost = true;\n            }\n          }\n        } else {\n          reparsePost = true;\n          break;\n        }\n      }\n    }\n\n    if (reparsePost) {\n      this.logger.log(`reparsePost (${mutations.length} mutations)`);\n      this.reparsePost();\n    } else if (sections.length) {\n      this.logger.log(`reparse ${sections.length} sections (${mutations.length} mutations)`);\n      this.reparseSections(sections.toArray());\n    }\n  }\n\n  _findTargetNodes(mutation) {\n    let nodes = [];\n\n    switch (mutation.type) {\n      case MUTATION.CHARACTER_DATA:\n        nodes.push(mutation.target);\n        break;\n      case MUTATION.NODES_CHANGED:\n        forEach(mutation.addedNodes, n => nodes.push(n));\n        if (mutation.removedNodes.length) {\n          nodes.push(mutation.target);\n        }\n        break;\n    }\n\n    let element = this.editor.element;\n    let attachedNodes = filter(nodes, node => containsNode(element, node));\n    return attachedNodes;\n  }\n\n  _findSectionRenderNodeFromNode(node) {\n    return this.renderTree.findRenderNodeFromElement(node, (rn) => {\n      return rn.postNode.isSection;\n    });\n  }\n\n  _findRenderNodeFromNode(node) {\n    return this.renderTree.findRenderNodeFromElement(node);\n  }\n\n  _findSectionFromRenderNode(renderNode) {\n    let sectionRenderNode = this._findSectionRenderNodeFromNode(renderNode.element);\n    return sectionRenderNode && sectionRenderNode.postNode;\n  }\n\n}\n\nclass FixedQueue {\n  constructor(length=0) {\n    this._maxLength = length;\n    this._items = [];\n  }\n\n  get length() {\n    return this._items.length;\n  }\n\n  pop() {\n    return this._items.pop();\n  }\n\n  push(item) {\n    this._items.push(item);\n    if (this.length > this._maxLength) {\n      this._items.shift();\n    }\n  }\n\n  clear() {\n    this._items = [];\n  }\n\n  toArray() {\n    return this._items;\n  }\n}\n\nfunction findLeafSectionAtIndex(post, index) {\n  let section;\n  post.walkAllLeafSections((_section, _index) => {\n    if (index === _index) {\n      section = _section;\n    }\n  });\n  return section;\n}\n\nclass Snapshot {\n  constructor(takenAt, editor, editAction=null) {\n    this.mobiledoc = editor.serialize();\n    this.editor = editor;\n    this.editAction = editAction;\n    this.takenAt = takenAt;\n\n    this.snapshotRange();\n  }\n\n  snapshotRange() {\n    let { range, cursor } = this.editor;\n    if (cursor.hasCursor() && !range.isBlank) {\n      let { head, tail } = range;\n      this.range = {\n        head: [head.leafSectionIndex, head.offset],\n        tail: [tail.leafSectionIndex, tail.offset]\n      };\n    }\n  }\n\n  getRange(post) {\n    if (this.range) {\n      let { head, tail } = this.range;\n      let [headLeafSectionIndex, headOffset] = head;\n      let [tailLeafSectionIndex, tailOffset] = tail;\n      let headSection = findLeafSectionAtIndex(post, headLeafSectionIndex);\n      let tailSection = findLeafSectionAtIndex(post, tailLeafSectionIndex);\n\n      head = headSection.toPosition(headOffset);\n      tail = tailSection.toPosition(tailOffset);\n\n      return head.toRange(tail);\n    }\n  }\n\n  groupsWith(groupingTimeout, editAction, takenAt) {\n    return (\n      editAction !== null &&\n      this.editAction === editAction &&\n      this.takenAt + groupingTimeout > takenAt\n    );\n  }\n}\n\nclass EditHistory {\n  constructor(editor, queueLength, groupingTimeout) {\n    this.editor = editor;\n    this._undoStack = new FixedQueue(queueLength);\n    this._redoStack = new FixedQueue(queueLength);\n\n    this._pendingSnapshot = null;\n    this._groupingTimeout = groupingTimeout;\n  }\n\n  snapshot() {\n    // update the current snapshot with the range read from DOM\n    if (this._pendingSnapshot) {\n      this._pendingSnapshot.snapshotRange();\n    }\n  }\n\n  storeSnapshot(editAction=null) {\n    let now = Date.now();\n    // store pending snapshot\n    let pendingSnapshot = this._pendingSnapshot;\n    if (pendingSnapshot) {\n      if (!pendingSnapshot.groupsWith(this._groupingTimeout, editAction, now)) {\n        this._undoStack.push(pendingSnapshot);\n      }\n      this._redoStack.clear();\n    }\n\n    // take new pending snapshot to store next time `storeSnapshot` is called\n    this._pendingSnapshot = new Snapshot(now, this.editor, editAction);\n  }\n\n  stepBackward(postEditor) {\n    // Throw away the pending snapshot\n    this._pendingSnapshot = null;\n\n    let snapshot = this._undoStack.pop();\n    if (snapshot) {\n      this._redoStack.push(new Snapshot(Date.now(), this.editor));\n      this._restoreFromSnapshot(snapshot, postEditor);\n    }\n  }\n\n  stepForward(postEditor) {\n    let snapshot = this._redoStack.pop();\n    if (snapshot) {\n      this._undoStack.push(new Snapshot(Date.now(), this.editor));\n      this._restoreFromSnapshot(snapshot, postEditor);\n    }\n    postEditor.cancelSnapshot();\n  }\n\n  _restoreFromSnapshot(snapshot, postEditor) {\n    let { mobiledoc } = snapshot;\n    let { editor } = this;\n    let { builder, post } = editor;\n    let restoredPost = mobiledocParsers.parse(builder, mobiledoc);\n\n    postEditor.removeAllSections();\n    postEditor.migrateSectionsFromPost(restoredPost);\n\n    // resurrect snapshotted range if it exists\n    let newRange = snapshot.getRange(post);\n    if (newRange) {\n      postEditor.setRange(newRange);\n    }\n  }\n}\n\nconst UL_LI_REGEX = /^\\* (.*)$/;\nconst OL_LI_REGEX = /^\\d\\.? (.*)$/;\nconst CR = '\\r';\nconst LF = '\\n';\nconst CR_REGEX = new RegExp(CR, 'g');\nconst CR_LF_REGEX = new RegExp(CR+LF, 'g');\n\nconst SECTION_BREAK = LF;\n\nfunction normalizeLineEndings(text) {\n  return text.replace(CR_LF_REGEX, LF)\n             .replace(CR_REGEX, LF);\n}\n\nclass TextParser {\n  constructor(builder, options) {\n    this.builder = builder;\n    this.options = options;\n\n    this.post = this.builder.createPost();\n    this.prevSection = null;\n  }\n\n  /**\n   * @param {String} text to parse\n   * @return {Post} a post abstract\n   */\n  parse(text) {\n    text = normalizeLineEndings(text);\n    text.split(SECTION_BREAK).forEach(text => {\n      let section = this._parseSection(text);\n      this._appendSection(section);\n    });\n\n    return this.post;\n  }\n\n  _parseSection(text) {\n    let tagName = DEFAULT_TAG_NAME,\n        type    = MARKUP_SECTION_TYPE,\n        section;\n\n    if (UL_LI_REGEX.test(text)) {\n      tagName = 'ul';\n      type = LIST_SECTION_TYPE;\n      text = text.match(UL_LI_REGEX)[1];\n    } else if (OL_LI_REGEX.test(text)) {\n      tagName = 'ol';\n      type = LIST_SECTION_TYPE;\n      text = text.match(OL_LI_REGEX)[1];\n    }\n\n    let markers = [this.builder.createMarker(text)];\n\n    switch (type) {\n      case LIST_SECTION_TYPE: {\n        let item = this.builder.createListItem(markers);\n        let list = this.builder.createListSection(tagName, [item]);\n        section = list;\n        break;\n      }\n      case MARKUP_SECTION_TYPE:\n        section = this.builder.createMarkupSection(tagName, markers);\n        break;\n      default:\n        assert(`Unknown type encountered ${type}`, false);\n    }\n\n    return section;\n  }\n\n  _appendSection(section) {\n    let isSameListSection =\n      section.isListSection &&\n      this.prevSection && this.prevSection.isListSection &&\n      this.prevSection.tagName === section.tagName;\n\n    if (isSameListSection) {\n      section.items.forEach(item => {\n        this.prevSection.items.append(item.clone());\n      });\n    } else {\n      this.post.sections.insertAfter(section, this.prevSection);\n      this.prevSection = section;\n    }\n  }\n}\n\n/* global JSON */\n\nconst MIME_TEXT_PLAIN = 'text/plain';\nconst MIME_TEXT_HTML = 'text/html';\nconst NONSTANDARD_IE_TEXT_TYPE = 'Text';\n\nconst MOBILEDOC_REGEX = new RegExp(/data\\-mobiledoc='(.*?)'>/);\n\n/**\n * @return {Post}\n * @private\n */\nfunction parsePostFromHTML(html, builder, plugins) {\n  let post;\n\n  if (MOBILEDOC_REGEX.test(html)) {\n    let mobiledocString = html.match(MOBILEDOC_REGEX)[1];\n    let mobiledoc = JSON.parse(mobiledocString);\n    post = mobiledocParsers.parse(builder, mobiledoc);\n  } else {\n    post = new HTMLParser(builder, {plugins}).parse(html);\n  }\n\n  return post;\n}\n\n/**\n * @return {Post}\n * @private\n */\nfunction parsePostFromText(text, builder, plugins) {\n  let parser = new TextParser(builder, {plugins});\n  let post = parser.parse(text);\n  return post;\n}\n\n/**\n * @return {{html: String, text: String}}\n * @private\n */\nfunction getContentFromPasteEvent(event, window) {\n  let html = '', text = '';\n\n  let { clipboardData } = event;\n\n  if (clipboardData && clipboardData.getData) {\n    html = clipboardData.getData(MIME_TEXT_HTML);\n    text = clipboardData.getData(MIME_TEXT_PLAIN);\n  } else if (window.clipboardData && window.clipboardData.getData) { // IE\n    // The Internet Explorers (including Edge) have a non-standard way of interacting with the\n    // Clipboard API (see http://caniuse.com/#feat=clipboard). In short, they expose a global window.clipboardData\n    // object instead of the per-event event.clipboardData object on the other browsers.\n    html = window.clipboardData.getData(NONSTANDARD_IE_TEXT_TYPE);\n  }\n\n  return { html, text };\n}\n\n/**\n * @return {{html: String, text: String}}\n * @private\n */\nfunction getContentFromDropEvent(event, logger) {\n  let html = '', text = '';\n\n  try {\n    html = event.dataTransfer.getData(MIME_TEXT_HTML);\n    text = event.dataTransfer.getData(MIME_TEXT_PLAIN);\n  } catch (e) {\n    // FIXME IE11 does not include any data in the 'text/html' or 'text/plain'\n    // mimetypes. It throws an error 'Invalid argument' when attempting to read\n    // these properties.\n    if (logger) {\n      logger.log('Error getting drop data: ', e);\n    }\n  }\n\n  return { html, text };\n}\n\n/**\n * @param {CopyEvent|CutEvent}\n * @param {Editor}\n * @param {Window}\n * @private\n */\nfunction setClipboardData(event, {mobiledoc, html, text}, window) {\n  if (mobiledoc && html) {\n    html = `<div data-mobiledoc='${JSON.stringify(mobiledoc)}'>${html}</div>`;\n  }\n\n  let { clipboardData } = event;\n  let { clipboardData: nonstandardClipboardData } = window;\n\n  if (clipboardData && clipboardData.setData) {\n    clipboardData.setData(MIME_TEXT_HTML, html);\n    clipboardData.setData(MIME_TEXT_PLAIN, text);\n  } else if (nonstandardClipboardData && nonstandardClipboardData.setData) {\n    // The Internet Explorers (including Edge) have a non-standard way of interacting with the\n    // Clipboard API (see http://caniuse.com/#feat=clipboard). In short, they expose a global window.clipboardData\n    // object instead of the per-event event.clipboardData object on the other browsers.\n    nonstandardClipboardData.setData(NONSTANDARD_IE_TEXT_TYPE, html);\n  }\n}\n\n/**\n * @param {PasteEvent}\n * @param {{builder: Builder, _parserPlugins: Array}} options\n * @return {Post}\n * @private\n */\nfunction parsePostFromPaste(pasteEvent, {builder, _parserPlugins: plugins}, {targetFormat}={targetFormat:'html'}) {\n  let { html, text } = getContentFromPasteEvent(pasteEvent, window);\n\n  if (targetFormat === 'html' && html && html.length) {\n    return parsePostFromHTML(html, builder, plugins);\n  } else if (text && text.length) {\n    return parsePostFromText(text, builder, plugins);\n  }\n}\n\n/**\n * @param {DropEvent}\n * @param {Editor} editor\n * @param {Object} [options={}] Can pass a logger\n * @return {Post}\n * @private\n */\nfunction parsePostFromDrop(dropEvent, editor, {logger}={}) {\n  let { builder, _parserPlugins: plugins } = editor;\n  let { html, text } = getContentFromDropEvent(dropEvent, logger);\n\n  if (html && html.length) {\n    return parsePostFromHTML(html, builder, plugins);\n  } else if (text && text.length) {\n    return parsePostFromText(text, builder, plugins);\n  }\n}\n\nclass TextInputHandler {\n  constructor(editor) {\n    this.editor = editor;\n    this._handlers = [];\n  }\n\n  register(handler) {\n    assert(`Input Handler is not valid`, this._validateHandler(handler));\n    this._handlers.push(handler);\n  }\n\n  unregister(name) {\n    let handlers = this._handlers;\n    for (let i=0; i<handlers.length; i++) {\n      if (handlers[i].name === name) {\n        handlers.splice(i, 1);\n      }\n    }\n  }\n\n  handle(string) {\n    let { editor } = this;\n\n    editor.insertText(string);\n\n    let matchedHandler = this._findHandler();\n    if (matchedHandler) {\n      let [ handler, matches ] = matchedHandler;\n      handler.run(editor, matches);\n    }\n  }\n\n  handleNewLine() {\n    let { editor } = this;\n\n    let matchedHandler = this._findHandler(ENTER);\n    if (matchedHandler) {\n      let [ handler, matches ] = matchedHandler;\n      handler.run(editor, matches);\n    }\n  }\n\n  _findHandler(string = \"\") {\n    let { editor: { range: { head, head: { section } } } } = this;\n    let preText = section.textUntil(head) + string;\n\n    for (let i=0; i < this._handlers.length; i++) {\n      let handler = this._handlers[i];\n      let {text, match} = handler;\n\n      if (text && endsWith(preText, text)) {\n        return [handler, [text]];\n      } else if (match && match.test(preText)) {\n        return [handler, match.exec(preText)];\n      }\n    }\n  }\n\n  _validateHandler(handler) {\n    deprecate('Registered input handlers require a \"name\" property so that they can be unregistered', !!handler.name);\n    return !!handler.run &&                        // has `run`\n           (!!handler.text || !!handler.match) &&  // and `text` or `match`\n           !(!!handler.text && !!handler.match);   // not both `text` and `match`\n  }\n\n  destroy() {\n    this._handlers = [];\n  }\n}\n\nlet instance;\n\nclass SelectionChangeObserver {\n  constructor() {\n    this.started   = false;\n    this.listeners  = [];\n    this.selection = {};\n  }\n\n  static getInstance() {\n    if (!instance) {\n      instance = new SelectionChangeObserver();\n    }\n    return instance;\n  }\n\n  static addListener(listener) {\n    SelectionChangeObserver.getInstance().addListener(listener);\n  }\n\n  addListener(listener) {\n    if (this.listeners.indexOf(listener) === -1) {\n      this.listeners.push(listener);\n      this.start();\n    }\n  }\n\n  static removeListener(listener) {\n    SelectionChangeObserver.getInstance().removeListener(listener);\n  }\n\n  removeListener(listener) {\n    let index = this.listeners.indexOf(listener);\n    if (index !== -1) {\n      this.listeners.splice(index, 1);\n      if (this.listeners.length === 0) {\n        this.stop();\n      }\n    }\n  }\n\n  start() {\n    if (this.started) { return; }\n    this.started = true;\n\n    this.poll();\n  }\n\n  stop() {\n    this.started = false;\n    this.selection = {};\n  }\n\n  notifyListeners(/* newSelection, prevSelection */) {\n    this.listeners.forEach(listener => {\n      listener.selectionDidChange(...arguments);\n    });\n  }\n\n  destroy() {\n    this.stop();\n    this.listeners = [];\n  }\n\n  getSelection() {\n    let selection = window.getSelection();\n    let { anchorNode, focusNode, anchorOffset, focusOffset } = selection;\n    return { anchorNode, focusNode, anchorOffset, focusOffset };\n  }\n\n  poll() {\n    if (this.started) {\n      this.update();\n      this.runNext(() => this.poll());\n    }\n  }\n\n  runNext(fn) {\n    window.requestAnimationFrame(fn);\n  }\n\n  update() {\n    let prevSelection = this.selection;\n    let curSelection = this.getSelection();\n    if (!this.selectionIsEqual(prevSelection, curSelection)) {\n      this.selection = curSelection;\n      this.notifyListeners(curSelection, prevSelection);\n    }\n  }\n\n  selectionIsEqual(s1, s2) {\n    return s1.anchorNode === s2.anchorNode &&\n      s1.anchorOffset === s2.anchorOffset &&\n      s1.focusNode === s2.focusNode &&\n      s1.focusOffset === s2.focusOffset;\n  }\n}\n\nclass SelectionManager {\n  constructor(editor, callback) {\n    this.editor   = editor;\n    this.callback = callback;\n    this.started  = false;\n  }\n\n  start() {\n    if (this.started) { return; }\n\n    SelectionChangeObserver.addListener(this);\n    this.started = true;\n  }\n\n  stop() {\n    this.started = false;\n    SelectionChangeObserver.removeListener(this);\n  }\n\n  destroy() {\n    this.stop();\n  }\n\n  selectionDidChange() {\n    if (this.started) {\n      this.callback(...arguments);\n    }\n  }\n}\n\nconst ELEMENT_EVENT_TYPES = [\n  'keydown', 'keyup', 'cut', 'copy', 'paste', 'keypress', 'drop'\n];\n\nclass EventManager {\n  constructor(editor) {\n    this.editor = editor;\n    this.logger = editor.loggerFor('event-manager');\n    this._textInputHandler = new TextInputHandler(editor);\n    this._listeners = [];\n    this.modifierKeys = {\n      shift: false\n    };\n\n    this._selectionManager = new SelectionManager(\n      this.editor, this.selectionDidChange.bind(this));\n    this.started = true;\n  }\n\n  init() {\n    let { editor: { element } } = this;\n    assert(`Cannot init EventManager without element`, !!element);\n\n    ELEMENT_EVENT_TYPES.forEach(type => {\n      this._addListener(element, type);\n    });\n\n    this._selectionManager.start();\n  }\n\n  start() {\n    this.started = true;\n  }\n\n  stop() {\n    this.started = false;\n  }\n\n  registerInputHandler(inputHandler) {\n    this._textInputHandler.register(inputHandler);\n  }\n\n  unregisterInputHandler(name) {\n    this._textInputHandler.unregister(name);\n  }\n\n  unregisterAllTextInputHandlers() {\n    this._textInputHandler.destroy();\n    this._textInputHandler = new TextInputHandler(this.editor);\n  }\n\n  _addListener(context, type) {\n    assert(`Missing listener for ${type}`, !!this[type]);\n\n    let listener = (event) => this._handleEvent(type, event);\n    context.addEventListener(type, listener);\n    this._listeners.push([context, type, listener]);\n  }\n\n  _removeListeners() {\n    this._listeners.forEach(([context, type, listener]) => {\n      context.removeEventListener(type, listener);\n    });\n    this._listeners = [];\n  }\n\n  // This is primarily useful for programmatically simulating events on the\n  // editor from the tests.\n  _trigger(context, type, event) {\n    forEach(\n      filter(this._listeners, ([_context, _type]) => {\n        return _context === context && _type === type;\n      }),\n      ([context,, listener]) => {\n        listener.call(context, event);\n      }\n    );\n  }\n\n  destroy() {\n    this._textInputHandler.destroy();\n    this._selectionManager.destroy();\n    this._removeListeners();\n  }\n\n  _handleEvent(type, event) {\n    let {target: element} = event;\n    if (!this.started) {\n      // abort handling this event\n      return true;\n    }\n\n    if (!this.isElementAddressable(element)) {\n      // abort handling this event\n      return true;\n    }\n\n    this[type](event);\n  }\n\n  isElementAddressable(element) {\n    return this.editor.cursor.isAddressable(element);\n  }\n\n  selectionDidChange(selection /*, prevSelection */) {\n    let shouldNotify = true;\n    let { anchorNode } = selection;\n    if (!this.isElementAddressable(anchorNode)) {\n      if (!this.editor.range.isBlank) {\n        // Selection changed from something addressable to something\n        // not-addressable -- e.g., blur event, user clicked outside editor,\n        // etc\n        shouldNotify = true;\n      } else {\n        // selection changes wholly outside the editor should not trigger\n        // change notifications\n        shouldNotify = false;\n      }\n    }\n\n    if (shouldNotify) {\n      this.editor._readRangeFromDOM();\n    }\n  }\n\n  keypress(event) {\n    let { editor, _textInputHandler } = this;\n    if (!editor.hasCursor()) { return; }\n\n    let key = Key.fromEvent(event);\n    if (!key.isPrintable()) {\n      return;\n    } else {\n      event.preventDefault();\n    }\n\n    _textInputHandler.handle(key.toString());\n  }\n\n  keydown(event) {\n    let { editor } = this;\n    if (!editor.hasCursor()) { return; }\n    if (!editor.isEditable) { return; }\n\n    let key = Key.fromEvent(event);\n    this._updateModifiersFromKey(key, {isDown:true});\n\n    if (editor.handleKeyCommand(event)) { return; }\n\n    if (editor.post.isBlank) {\n      editor._insertEmptyMarkupSectionAtCursor();\n    }\n\n    let range = editor.range;\n\n    switch(true) {\n      // FIXME This should be restricted to only card/atom boundaries\n      case key.isHorizontalArrowWithoutModifiersOtherThanShift(): {\n        let newRange;\n        if (key.isShift()) {\n          newRange = range.extend(key.direction * 1);\n        } else {\n          newRange = range.move(key.direction);\n        }\n\n        editor.selectRange(newRange);\n        event.preventDefault();\n        break;\n      }\n      case key.isDelete(): {\n        let { direction } = key;\n        let unit = 'char';\n        if (key.altKey && Browser.isMac()) {\n          unit = 'word';\n        } else if (key.ctrlKey && !Browser.isMac()) {\n          unit = 'word';\n        }\n        editor.performDelete({direction, unit});\n        event.preventDefault();\n        break;\n      }\n      case key.isEnter():\n        this._textInputHandler.handleNewLine();\n        editor.handleNewline(event);\n        break;\n      case key.isTab():\n        // Handle tab here because it does not fire a `keypress` event\n        event.preventDefault();\n        this._textInputHandler.handle(key.toString());\n        break;\n    }\n  }\n\n  keyup(event) {\n    let { editor } = this;\n    if (!editor.hasCursor()) { return; }\n    let key = Key.fromEvent(event);\n    this._updateModifiersFromKey(key, {isDown:false});\n  }\n\n  cut(event) {\n    event.preventDefault();\n\n    this.copy(event);\n    this.editor.performDelete();\n  }\n\n  copy(event) {\n    event.preventDefault();\n\n    let { editor, editor: { range, post } } = this;\n    post = post.trimTo(range);\n\n    let data = {\n      html: editor.serializePost(post, 'html'),\n      text: editor.serializePost(post, 'text'),\n      mobiledoc: editor.serializePost(post, 'mobiledoc')\n    };\n\n    editor.runCallbacks('willCopy', [data]);\n\n    setClipboardData(event, data, window);\n  }\n\n  paste(event) {\n    event.preventDefault();\n\n    let { editor } = this;\n    let range = editor.range;\n\n    if (!range.isCollapsed) {\n      editor.performDelete();\n    }\n\n    if (editor.post.isBlank) {\n      editor._insertEmptyMarkupSectionAtCursor();\n    }\n\n    let position = editor.range.head;\n    let targetFormat = this.modifierKeys.shift ? 'text' : 'html';\n    let pastedPost = parsePostFromPaste(event, editor, {targetFormat});\n\n    editor.run(postEditor => {\n      let nextPosition = postEditor.insertPost(position, pastedPost);\n      postEditor.setRange(nextPosition);\n    });\n  }\n\n  drop(event) {\n    event.preventDefault();\n\n    let { clientX: x, clientY: y } = event;\n    let { editor } = this;\n\n    let position = editor.positionAtPoint(x, y);\n    if (!position) {\n      this.logger.log('Could not find drop position');\n      return;\n    }\n\n    let post = parsePostFromDrop(event, editor, {logger: this.logger});\n    if (!post) {\n      this.logger.log('Could not determine post from drop event');\n      return;\n    }\n\n    editor.run(postEditor => {\n      let nextPosition = postEditor.insertPost(position, post);\n      postEditor.setRange(nextPosition);\n    });\n  }\n\n  _updateModifiersFromKey(key, {isDown}) {\n    if (key.isShiftKey()) {\n      this.modifierKeys.shift = isDown;\n    }\n  }\n\n}\n\n/**\n * Used by {@link Editor} to manage its current state (cursor, active markups\n * and active sections).\n * @private\n */\nclass EditState {\n  constructor(editor) {\n    this.editor = editor;\n\n    let defaultState = {\n      range: Range.blankRange(),\n      activeMarkups: [],\n      activeSections: [],\n      activeSectionTagNames: [],\n      activeSectionAttributes: {}\n    };\n\n    this.prevState = this.state = defaultState;\n  }\n\n  updateRange(newRange) {\n    this.prevState = this.state;\n    this.state = this._readState(newRange);\n  }\n\n  destroy() {\n    this.editor = null;\n    this.prevState = this.state = null;\n  }\n\n  /**\n   * @return {Boolean}\n   */\n  rangeDidChange() {\n    let { state: { range } , prevState: {range: prevRange} } = this;\n\n    return !prevRange.isEqual(range);\n  }\n\n  /**\n   * @return {Boolean} Whether the input mode (active markups or active section tag names)\n   * has changed.\n   */\n  inputModeDidChange() {\n    let { state, prevState } = this;\n    return (!isArrayEqual(state.activeMarkups, prevState.activeMarkups) ||\n            !isArrayEqual(state.activeSectionTagNames, prevState.activeSectionTagNames) ||\n            !isArrayEqual(objectToSortedKVArray(state.activeSectionAttributes), objectToSortedKVArray(prevState.activeSectionAttributes)));\n  }\n\n  /**\n   * @return {Range}\n   */\n  get range() {\n    return this.state.range;\n  }\n\n  /**\n   * @return {Section[]}\n   */\n  get activeSections() {\n    return this.state.activeSections;\n  }\n\n\n  /**\n   * @return {Object}\n   */\n  get activeSectionAttributes() {\n    return this.state.activeSectionAttributes;\n  }\n\n  /**\n   * @return {Markup[]}\n   */\n  get activeMarkups() {\n    return this.state.activeMarkups;\n  }\n\n  /**\n   * Update the editor's markup state. This is used when, e.g.,\n   * a user types meta+B when the editor has a cursor but no selected text;\n   * in this case the editor needs to track that it has an active \"b\" markup\n   * and apply it to the next text the user types.\n   */\n  toggleMarkupState(markup) {\n    if (contains(this.activeMarkups, markup)) {\n      this._removeActiveMarkup(markup);\n    } else {\n      this._addActiveMarkup(markup);\n    }\n  }\n\n  _readState(range) {\n    let state = {\n      range,\n      activeMarkups:  this._readActiveMarkups(range),\n      activeSections: this._readActiveSections(range)\n    };\n    // Section objects are 'live', so to check that they changed, we\n    // need to map their tagNames now (and compare to mapped tagNames later).\n    // In addition, to catch changes from ul -> ol, we keep track of the\n    // un-nested tag names (otherwise we'd only see li -> li change)\n    state.activeSectionTagNames = state.activeSections.map(s => {\n      return s.isNested ? s.parent.tagName : s.tagName;\n    });\n    state.activeSectionAttributes = this._readSectionAttributes(state.activeSections);\n    return state;\n  }\n\n  _readActiveSections(range) {\n    let { head, tail } = range;\n    let { editor: { post } } = this;\n    if (range.isBlank) {\n      return [];\n    } else {\n      return post.sections.readRange(head.section, tail.section);\n    }\n  }\n\n  _readActiveMarkups(range) {\n    let { editor: { post } } = this;\n    return post.markupsInRange(range);\n  }\n\n  _readSectionAttributes(sections) {\n    return sections.reduce((sectionAttributes, s) => {\n      let attributes = s.isNested ? s.parent.attributes : s.attributes;\n      Object.keys(attributes || {}).forEach(attrName => {\n        let camelizedAttrName = attrName.replace(/^data-md-/, '');\n        let attrValue = attributes[attrName];\n        sectionAttributes[camelizedAttrName] = sectionAttributes[camelizedAttrName] || [];\n        if (!contains(sectionAttributes[camelizedAttrName], attrValue)) {\n          sectionAttributes[camelizedAttrName].push(attrValue);\n        }\n      });\n      return sectionAttributes;\n    }, {});\n  }\n\n  _removeActiveMarkup(markup) {\n    let index = this.state.activeMarkups.indexOf(markup);\n    this.state.activeMarkups.splice(index, 1);\n  }\n\n  _addActiveMarkup(markup) {\n    this.state.activeMarkups.push(markup);\n  }\n}\n\nfunction addHTMLSpaces(text) {\n  let nbsp = '\\u00A0';\n  return text.replace(/  /g, ' ' + nbsp);\n}\n\nfunction createTextNode(dom, text) {\n  return dom.createTextNode(addHTMLSpaces(text));\n}\n\nfunction normalizeTagName$1(tagName) {\n  return tagName.toLowerCase();\n}\n\nvar RENDER_TYPE = 'dom';\n\nvar ImageCard$1 = {\n  name: 'image',\n  type: RENDER_TYPE,\n  render({payload, env: {dom}}) {\n    let img = dom.createElement('img');\n    img.src = payload.src;\n    return img;\n  }\n};\n\nconst MARKUP_SECTION_TYPE$1 = 1;\nconst IMAGE_SECTION_TYPE$1 = 2;\nconst LIST_SECTION_TYPE$1 = 3;\nconst CARD_SECTION_TYPE = 10;\n\nconst MARKUP_SECTION_TAG_NAMES = [\n  'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pull-quote', 'aside'\n].map(normalizeTagName$1);\n\nconst MARKUP_SECTION_ELEMENT_NAMES$1 = [\n  'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'aside'\n].map(normalizeTagName$1);\n\nconst LIST_SECTION_TAG_NAMES = [\n  'ul', 'ol'\n].map(normalizeTagName$1);\n\nconst MARKUP_TYPES = [\n  'b', 'i', 'strong', 'em', 'a', 'u', 'sub', 'sup', 's', 'code'\n].map(normalizeTagName$1);\n\nfunction contains$1(array, item) {\n  return array.indexOf(item) !== -1;\n}\n\nfunction isValidSectionTagName(tagName, sectionType) {\n  tagName = normalizeTagName$1(tagName);\n\n  switch (sectionType) {\n    case MARKUP_SECTION_TYPE$1:\n      return contains$1(MARKUP_SECTION_TAG_NAMES, tagName);\n    case LIST_SECTION_TYPE$1:\n      return contains$1(LIST_SECTION_TAG_NAMES, tagName);\n    default:\n      throw new Error(`Cannot validate tagName for unknown section type \"${sectionType}\"`);\n  }\n}\n\nfunction isMarkupSectionElementName(tagName) {\n  tagName = normalizeTagName$1(tagName);\n  return contains$1(MARKUP_SECTION_ELEMENT_NAMES$1, tagName);\n}\n\nfunction isValidMarkerType(type) {\n  type = normalizeTagName$1(type);\n  return contains$1(MARKUP_TYPES, type);\n}\n\nfunction includes(array, detectValue) {\n  for (let i=0;i < array.length;i++) {\n    let value = array[i];\n    if (value === detectValue) {\n      return true;\n    }\n  }\n  return false;\n}\n\nconst PROTOCOL_REGEXP = /^([a-z0-9.+-]+:)/i;\n\nconst badProtocols = [\n  'javascript:', // jshint ignore:line\n  'vbscript:' // jshint ignore:line\n];\n\nfunction getProtocol(url) {\n  let matches = url && url.match(PROTOCOL_REGEXP);\n  let protocol = (matches && matches[0]) || ':';\n  return protocol;\n}\n\nfunction sanitizeHref(url) {\n  let protocol = getProtocol(url).toLowerCase();\n  if (includes(badProtocols, protocol)) {\n    return `unsafe:${url}`;\n  }\n  return url;\n}\n\n/**\n * @param attributes array\n * @return obj with normalized attribute names (lowercased)\n */\nfunction reduceAttributes(attributes) {\n  let obj = {};\n  for (let i = 0; i < attributes.length; i += 2) {\n    let key = attributes[i];\n    let val = attributes[i+1];\n    obj[key.toLowerCase()] = val;\n  }\n  return obj;\n}\n\nconst VALID_ATTRIBUTES$2 = [\n  'data-md-text-align'\n];\n\nfunction _isValidAttribute(attr) {\n  return VALID_ATTRIBUTES$2.indexOf(attr) !== -1;\n}\n\nfunction handleMarkupSectionAttribute(element, attributeKey, attributeValue) {\n  if (!_isValidAttribute(attributeKey)) {\n    throw new Error(`Cannot use attribute: ${attributeKey}`);\n  }\n\n  element.setAttribute(attributeKey, attributeValue);\n}\n\nfunction defaultSectionElementRenderer(tagName, dom, attrsObj = {}) {\n  let element;\n  if (isMarkupSectionElementName(tagName)) {\n    element = dom.createElement(tagName);\n\n    Object.keys(attrsObj).forEach(k => {\n      handleMarkupSectionAttribute(element, k, attrsObj[k]);\n    });\n  } else {\n    element = dom.createElement('div');\n    element.setAttribute('class', tagName);\n  }\n\n  return element;\n}\n\nfunction sanitizeAttribute(tagName, attrName, attrValue) {\n  if (tagName === 'a' && attrName === 'href') {\n    return sanitizeHref(attrValue);\n  } else {\n    return attrValue;\n  }\n}\n\nfunction defaultMarkupElementRenderer(tagName, dom, attrsObj) {\n  let element = dom.createElement(tagName);\n  Object.keys(attrsObj).forEach(attrName => {\n    let attrValue = attrsObj[attrName];\n    attrValue = sanitizeAttribute(tagName, attrName, attrValue);\n    element.setAttribute(attrName, attrValue);\n  });\n  return element;\n}\n\nconst MOBILEDOC_VERSION$5 = '0.2.0';\n\nconst IMAGE_SECTION_TAG_NAME = 'img';\n\nfunction validateVersion(version) {\n  if (version !== MOBILEDOC_VERSION$5) {\n    throw new Error(`Unexpected Mobiledoc version \"${version}\"`);\n  }\n}\n\nclass Renderer$1 {\n  constructor(mobiledoc, options) {\n    let {\n      cards,\n      cardOptions,\n      unknownCardHandler,\n      markupElementRenderer,\n      sectionElementRenderer,\n      dom\n    } = options;\n    let {\n      version,\n      sections: sectionData\n    } = mobiledoc;\n    validateVersion(version);\n\n    const [markerTypes, sections] = sectionData;\n\n    this.dom                = dom;\n    this.root               = dom.createDocumentFragment();\n    this.markerTypes        = markerTypes;\n    this.sections           = sections;\n    this.cards              = cards;\n    this.cardOptions        = cardOptions;\n    this.unknownCardHandler = unknownCardHandler || this._defaultUnknownCardHandler;\n\n    this.sectionElementRenderer = {\n      '__default__': defaultSectionElementRenderer\n    };\n    Object.keys(sectionElementRenderer).forEach(key => {\n      this.sectionElementRenderer[key.toLowerCase()] = sectionElementRenderer[key];\n    });\n\n    this.markupElementRenderer = {\n      '__default__': defaultMarkupElementRenderer\n    };\n    Object.keys(markupElementRenderer).forEach(key => {\n      this.markupElementRenderer[key.toLowerCase()] = markupElementRenderer[key];\n    });\n\n    this._renderCallbacks    = [];\n    this._teardownCallbacks  = [];\n    this._renderedChildNodes = [];\n  }\n\n  get _defaultUnknownCardHandler() {\n    return ({env: {name}}) => {\n      throw new Error(`Card \"${name}\" not found but no unknownCardHandler was registered`);\n    };\n  }\n\n  render() {\n    this.sections.forEach(section => {\n      let rendered = this.renderSection(section);\n      if (rendered) {\n        this.root.appendChild(rendered);\n      }\n    });\n    for (let i = 0; i < this._renderCallbacks.length; i++) {\n      this._renderCallbacks[i]();\n    }\n    // maintain a reference to child nodes so they can be cleaned up later by teardown\n    this._renderedChildNodes = [];\n    let node = this.root.firstChild;\n    while (node) {\n      this._renderedChildNodes.push(node);\n      node = node.nextSibling;\n    }\n    return { result: this.root, teardown: () => this.teardown() };\n  }\n\n  teardown() {\n    for (let i=0; i < this._teardownCallbacks.length; i++) {\n      this._teardownCallbacks[i]();\n    }\n    for (let i=0; i < this._renderedChildNodes.length; i++) {\n      let node = this._renderedChildNodes[i];\n      if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n    }\n  }\n\n  renderSection(section) {\n    const [type] = section;\n    switch (type) {\n      case MARKUP_SECTION_TYPE$1:\n        return this.renderMarkupSection(section);\n      case IMAGE_SECTION_TYPE$1:\n        return this.renderImageSection(section);\n      case LIST_SECTION_TYPE$1:\n        return this.renderListSection(section);\n      case CARD_SECTION_TYPE:\n        return this.renderCardSection(section);\n      default:\n        throw new Error(`Cannot render mobiledoc section of type \"${type}\"`);\n    }\n  }\n\n  renderMarkersOnElement(element, markers) {\n    let elements = [element];\n    let currentElement = element;\n\n    let pushElement = (openedElement) => {\n      currentElement.appendChild(openedElement);\n      elements.push(openedElement);\n      currentElement = openedElement;\n    };\n\n    for (let i=0, l=markers.length; i<l; i++) {\n      let marker = markers[i];\n      let [openTypes, closeCount, text] = marker;\n\n      for (let j=0, m=openTypes.length; j<m; j++) {\n        let markerType = this.markerTypes[openTypes[j]];\n        let [tagName, attrs=[]] = markerType;\n        if (isValidMarkerType(tagName)) {\n          pushElement(this.renderMarkupElement(tagName, attrs));\n        } else {\n          closeCount--;\n        }\n      }\n\n      currentElement.appendChild(createTextNode(this.dom, text));\n\n      for (let j=0, m=closeCount; j<m; j++) {\n        elements.pop();\n        currentElement = elements[elements.length - 1];\n      }\n    }\n  }\n\n  /**\n   * @param attrs Array\n   */\n  renderMarkupElement(tagName, attrs) {\n    tagName = tagName.toLowerCase();\n    attrs   = reduceAttributes(attrs);\n\n    let renderer = this.markupElementRendererFor(tagName);\n    return renderer(tagName, this.dom, attrs);\n  }\n\n  markupElementRendererFor(tagName) {\n    return this.markupElementRenderer[tagName] ||\n      this.markupElementRenderer.__default__;\n  }\n\n  renderListItem(markers) {\n    const element = this.dom.createElement('li');\n    this.renderMarkersOnElement(element, markers);\n    return element;\n  }\n\n  renderListSection([type, tagName, listItems]) {\n    if (!isValidSectionTagName(tagName, LIST_SECTION_TYPE$1)) {\n      return;\n    }\n    const element = this.dom.createElement(tagName);\n    listItems.forEach(li => {\n      element.appendChild(this.renderListItem(li));\n    });\n    return element;\n  }\n\n  renderImageSection([type, src]) {\n    let element = this.dom.createElement(IMAGE_SECTION_TAG_NAME);\n    element.src = src;\n    return element;\n  }\n\n  findCard(name) {\n    for (let i=0; i < this.cards.length; i++) {\n      if (this.cards[i].name === name) {\n        return this.cards[i];\n      }\n    }\n    if (name === ImageCard$1.name) {\n      return ImageCard$1;\n    }\n    return this._createUnknownCard(name);\n  }\n\n  _createUnknownCard(name) {\n    return {\n      name,\n      type: RENDER_TYPE,\n      render: this.unknownCardHandler\n    };\n  }\n\n  _createCardArgument(card, payload={}) {\n    let env = {\n      name: card.name,\n      isInEditor: false,\n      dom: this.dom,\n      didRender: (callback) => this._registerRenderCallback(callback),\n      onTeardown: (callback) => this._registerTeardownCallback(callback)\n    };\n\n    let options = this.cardOptions;\n\n    return { env, options, payload };\n  }\n\n  _registerRenderCallback(callback) {\n    this._renderCallbacks.push(callback);\n  }\n\n  _registerTeardownCallback(callback) {\n    this._teardownCallbacks.push(callback);\n  }\n\n  renderCardSection([type, name, payload]) {\n    let card = this.findCard(name);\n\n    let cardArg = this._createCardArgument(card, payload);\n    let rendered = card.render(cardArg);\n\n    this._validateCardRender(rendered, card.name);\n\n    return rendered;\n  }\n\n  _validateCardRender(rendered, cardName) {\n    if (!rendered) {\n      return;\n    }\n\n    if (typeof rendered !== 'object') {\n      throw new Error(`Card \"${cardName}\" must render ${RENDER_TYPE}, but result was \"${rendered}\"`);\n    }\n  }\n\n  renderMarkupSection([type, tagName, markers]) {\n    tagName = tagName.toLowerCase();\n    if (!isValidSectionTagName(tagName, MARKUP_SECTION_TYPE$1)) {\n      return;\n    }\n\n    let renderer = this.sectionElementRendererFor(tagName);\n    let element = renderer(tagName, this.dom);\n\n    this.renderMarkersOnElement(element, markers);\n    return element;\n  }\n\n  sectionElementRendererFor(tagName) {\n    return this.sectionElementRenderer[tagName] ||\n      this.sectionElementRenderer.__default__;\n  }\n}\n\nconst MARKUP_MARKER_TYPE = 0;\nconst ATOM_MARKER_TYPE = 1;\n\nconst MOBILEDOC_VERSION_0_3_0 = '0.3.0';\nconst MOBILEDOC_VERSION_0_3_1 = '0.3.1';\nconst MOBILEDOC_VERSION_0_3_2 = '0.3.2';\n\nconst IMAGE_SECTION_TAG_NAME$1 = 'img';\n\nfunction validateVersion$1(version) {\n  switch (version) {\n    case MOBILEDOC_VERSION_0_3_0:\n    case MOBILEDOC_VERSION_0_3_1:\n    case MOBILEDOC_VERSION_0_3_2:\n      return;\n    default:\n      throw new Error(`Unexpected Mobiledoc version \"${version}\"`);\n  }\n}\n\nclass Renderer$2 {\n  constructor(mobiledoc, state) {\n\n    let {\n      cards,\n      cardOptions,\n      atoms,\n      unknownCardHandler,\n      unknownAtomHandler,\n      markupElementRenderer,\n      sectionElementRenderer,\n      dom\n    } = state;\n    let {\n      version,\n      sections,\n      atoms: atomTypes,\n      cards: cardTypes,\n      markups: markerTypes\n    } = mobiledoc;\n    validateVersion$1(version);\n\n    this.dom                = dom;\n    this.root               = this.dom.createDocumentFragment();\n    this.sections           = sections;\n    this.atomTypes          = atomTypes;\n    this.cardTypes          = cardTypes;\n    this.markerTypes        = markerTypes;\n    this.cards              = cards;\n    this.atoms              = atoms;\n    this.cardOptions        = cardOptions;\n    this.unknownCardHandler = unknownCardHandler || this._defaultUnknownCardHandler;\n    this.unknownAtomHandler = unknownAtomHandler || this._defaultUnknownAtomHandler;\n\n    this.sectionElementRenderer = {\n      '__default__': defaultSectionElementRenderer\n    };\n    Object.keys(sectionElementRenderer).forEach(key => {\n      this.sectionElementRenderer[key.toLowerCase()] = sectionElementRenderer[key];\n    });\n\n    this.markupElementRenderer = {\n      '__default__': defaultMarkupElementRenderer\n    };\n    Object.keys(markupElementRenderer).forEach(key => {\n      this.markupElementRenderer[key.toLowerCase()] = markupElementRenderer[key];\n    });\n\n    this._renderCallbacks = [];\n    this._teardownCallbacks  = [];\n  }\n\n  get _defaultUnknownCardHandler() {\n    return ({env: {name}}) => {\n      throw new Error(`Card \"${name}\" not found but no unknownCardHandler was registered`);\n    };\n  }\n\n  get _defaultUnknownAtomHandler() {\n    return ({env: {name}}) => {\n      throw new Error(`Atom \"${name}\" not found but no unknownAtomHandler was registered`);\n    };\n  }\n\n  render() {\n    this.sections.forEach(section => {\n      let rendered = this.renderSection(section);\n      if (rendered) {\n        this.root.appendChild(rendered);\n      }\n    });\n    for (let i=0; i < this._renderCallbacks.length; i++) {\n      this._renderCallbacks[i]();\n    }\n    // maintain a reference to child nodes so they can be cleaned up later by teardown\n    this._renderedChildNodes = Array.prototype.slice.call(this.root.childNodes);\n    return { result: this.root, teardown: () => this.teardown() };\n  }\n\n  teardown() {\n    for (let i=0; i < this._teardownCallbacks.length; i++) {\n      this._teardownCallbacks[i]();\n    }\n    for (let i=0; i < this._renderedChildNodes.length; i++) {\n      let node = this._renderedChildNodes[i];\n      if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n    }\n  }\n\n  renderSection(section) {\n    const [type] = section;\n    switch (type) {\n      case MARKUP_SECTION_TYPE$1:\n        return this.renderMarkupSection(section);\n      case IMAGE_SECTION_TYPE$1:\n        return this.renderImageSection(section);\n      case LIST_SECTION_TYPE$1:\n        return this.renderListSection(section);\n      case CARD_SECTION_TYPE:\n        return this.renderCardSection(section);\n      default:\n        throw new Error(`Cannot render mobiledoc section of type \"${type}\"`);\n    }\n  }\n\n  renderMarkersOnElement(element, markers) {\n    let elements = [element];\n    let currentElement = element;\n\n    let pushElement = (openedElement) => {\n      currentElement.appendChild(openedElement);\n      elements.push(openedElement);\n      currentElement = openedElement;\n    };\n\n    for (let i=0, l=markers.length; i<l; i++) {\n      let marker = markers[i];\n      let [type, openTypes, closeCount, value] = marker;\n\n      for (let j=0, m=openTypes.length; j<m; j++) {\n        let markerType = this.markerTypes[openTypes[j]];\n        let [tagName, attrs=[]] = markerType;\n\n        if (isValidMarkerType(tagName)) {\n          pushElement(this.renderMarkupElement(tagName, attrs));\n        } else {\n          closeCount--;\n        }\n      }\n\n      switch (type) {\n        case MARKUP_MARKER_TYPE:\n          currentElement.appendChild(createTextNode(this.dom, value));\n          break;\n        case ATOM_MARKER_TYPE:\n          currentElement.appendChild(this._renderAtom(value));\n          break;\n        default:\n          throw new Error(`Unknown markup type (${type})`);\n      }\n\n      for (let j=0, m=closeCount; j<m; j++) {\n        elements.pop();\n        currentElement = elements[elements.length - 1];\n      }\n    }\n  }\n\n  /**\n   * @param attrs Array\n   */\n  renderMarkupElement(tagName, attrs) {\n    tagName = tagName.toLowerCase();\n    attrs   = reduceAttributes(attrs);\n\n    let renderer = this.markupElementRendererFor(tagName);\n    return renderer(tagName, this.dom, attrs);\n  }\n\n  markupElementRendererFor(tagName) {\n    return this.markupElementRenderer[tagName] ||\n      this.markupElementRenderer.__default__;\n  }\n\n  renderListItem(markers) {\n    const element = this.dom.createElement('li');\n    this.renderMarkersOnElement(element, markers);\n    return element;\n  }\n\n  renderListSection([type, tagName, listItems]) {\n    if (!isValidSectionTagName(tagName, LIST_SECTION_TYPE$1)) {\n      return;\n    }\n    const element = this.dom.createElement(tagName);\n    listItems.forEach(li => {\n      element.appendChild(this.renderListItem(li));\n    });\n    return element;\n  }\n\n  renderImageSection([type, src]) {\n    let element = this.dom.createElement(IMAGE_SECTION_TAG_NAME$1);\n    element.src = src;\n    return element;\n  }\n\n  findCard(name) {\n    for (let i=0; i < this.cards.length; i++) {\n      if (this.cards[i].name === name) {\n        return this.cards[i];\n      }\n    }\n    if (name === ImageCard$1.name) {\n      return ImageCard$1;\n    }\n    return this._createUnknownCard(name);\n  }\n\n  _findCardByIndex(index) {\n    let cardType = this.cardTypes[index];\n    if (!cardType) {\n      throw new Error(`No card definition found at index ${index}`);\n    }\n\n    let [ name, payload ] = cardType;\n    let card = this.findCard(name);\n\n    return {\n      card,\n      payload\n    };\n  }\n\n  _createUnknownCard(name) {\n    return {\n      name,\n      type: RENDER_TYPE,\n      render: this.unknownCardHandler\n    };\n  }\n\n  _createCardArgument(card, payload={}) {\n    let env = {\n      name: card.name,\n      isInEditor: false,\n      dom: this.dom,\n      didRender: (callback) => this._registerRenderCallback(callback),\n      onTeardown: (callback) => this._registerTeardownCallback(callback)\n    };\n\n    let options = this.cardOptions;\n\n    return { env, options, payload };\n  }\n\n  _registerTeardownCallback(callback) {\n    this._teardownCallbacks.push(callback);\n  }\n\n  _registerRenderCallback(callback) {\n    this._renderCallbacks.push(callback);\n  }\n\n  renderCardSection([type, index]) {\n    let { card, payload } = this._findCardByIndex(index);\n\n    let cardArg = this._createCardArgument(card, payload);\n    let rendered = card.render(cardArg);\n\n    this._validateCardRender(rendered, card.name);\n\n    return rendered;\n  }\n\n  _validateCardRender(rendered, cardName) {\n    if (!rendered) {\n      return;\n    }\n\n    if (typeof rendered !== 'object') {\n      throw new Error(`Card \"${cardName}\" must render ${RENDER_TYPE}, but result was \"${rendered}\"`);\n    }\n  }\n\n  findAtom(name) {\n    for (let i=0; i < this.atoms.length; i++) {\n      if (this.atoms[i].name === name) {\n        return this.atoms[i];\n      }\n    }\n    return this._createUnknownAtom(name);\n  }\n\n  _createUnknownAtom(name) {\n    return {\n      name,\n      type: RENDER_TYPE,\n      render: this.unknownAtomHandler\n    };\n  }\n\n  _createAtomArgument(atom, value, payload) {\n    let env = {\n      name: atom.name,\n      isInEditor: false,\n      dom: this.dom,\n      onTeardown: (callback) => this._registerTeardownCallback(callback)\n    };\n\n    let options = this.cardOptions;\n\n    return { env, options, value, payload };\n  }\n\n  _validateAtomRender(rendered, atomName) {\n    if (!rendered) {\n      return;\n    }\n\n    if (typeof rendered !== 'object') {\n      throw new Error(`Atom \"${atomName}\" must render ${RENDER_TYPE}, but result was \"${rendered}\"`);\n    }\n  }\n\n  _findAtomByIndex(index) {\n    let atomType = this.atomTypes[index];\n    if (!atomType) {\n      throw new Error(`No atom definition found at index ${index}`);\n    }\n\n    let [ name, value, payload ] = atomType;\n    let atom = this.findAtom(name);\n\n    return {\n      atom,\n      value,\n      payload\n    };\n  }\n\n  _renderAtom(index) {\n    let { atom, value, payload } = this._findAtomByIndex(index);\n\n    let atomArg = this._createAtomArgument(atom, value, payload);\n    let rendered = atom.render(atomArg);\n\n    this._validateAtomRender(rendered, atom.name);\n\n    return rendered || createTextNode(this.dom, '');\n  }\n\n  renderMarkupSection([type, tagName, markers, attributes = []]) {\n    tagName = tagName.toLowerCase();\n    if (!isValidSectionTagName(tagName, MARKUP_SECTION_TYPE$1)) {\n      return;\n    }\n\n    let attrsObj = reduceAttributes(attributes);\n    let renderer = this.sectionElementRendererFor(tagName);\n    let element = renderer(tagName, this.dom, attrsObj);\n\n    this.renderMarkersOnElement(element, markers);\n    return element;\n  }\n\n  sectionElementRendererFor(tagName) {\n    return this.sectionElementRenderer[tagName] ||\n      this.sectionElementRenderer.__default__;\n  }\n}\n\n/**\n * runtime DOM renderer\n * renders a mobiledoc to DOM\n *\n * input: mobiledoc\n * output: DOM\n */\n\n function validateCards$1(cards) {\n   if (!Array.isArray(cards)) {\n     throw new Error('`cards` must be passed as an array');\n   }\n   for (let i=0; i < cards.length; i++) {\n     let card = cards[i];\n     if (card.type !== RENDER_TYPE) {\n       throw new Error(`Card \"${card.name}\" must be of type \"${RENDER_TYPE}\", was \"${card.type}\"`);\n     }\n     if (!card.render) {\n       throw new Error(`Card \"${card.name}\" must define \\`render\\``);\n     }\n   }\n }\n\n function validateAtoms$1(atoms) {\n   if (!Array.isArray(atoms)) {\n     throw new Error('`atoms` must be passed as an array');\n   }\n   for (let i=0; i < atoms.length; i++) {\n     let atom = atoms[i];\n     if (atom.type !== RENDER_TYPE) {\n       throw new Error(`Atom \"${atom.name}\" must be type \"${RENDER_TYPE}\", was \"${atom.type}\"`);\n     }\n     if (!atom.render) {\n       throw new Error(`Atom \"${atom.name}\" must define \\`render\\``);\n     }\n   }\n }\n\n class RendererFactory {\n   constructor({\n     cards=[],\n     atoms=[],\n     cardOptions={},\n     unknownCardHandler,\n     unknownAtomHandler,\n     markupElementRenderer={},\n     sectionElementRenderer={},\n     dom,\n     markupSanitizer=null\n   }={}) {\n     validateCards$1(cards);\n     validateAtoms$1(atoms);\n\n     if (!dom) {\n       if (typeof window === 'undefined') {\n         throw new Error('A `dom` option must be provided to the renderer when running without window.document');\n       }\n       dom = window.document;\n     }\n\n     this.options = {\n       cards,\n       atoms,\n       cardOptions,\n       unknownCardHandler,\n       unknownAtomHandler,\n       markupElementRenderer,\n       sectionElementRenderer,\n       dom,\n       markupSanitizer\n     };\n   }\n\n   render(mobiledoc) {\n     let { version } = mobiledoc;\n     switch (version) {\n       case MOBILEDOC_VERSION$5:\n       case undefined:\n       case null:\n         return new Renderer$1(mobiledoc, this.options).render();\n       case MOBILEDOC_VERSION_0_3_0:\n       case MOBILEDOC_VERSION_0_3_1:\n       case MOBILEDOC_VERSION_0_3_2:\n         return new Renderer$2(mobiledoc, this.options).render();\n       default:\n         throw new Error(`Unexpected Mobiledoc version \"${version}\"`);\n     }\n   }\n }\n\nvar ImageCard$2 = {\n  name: 'image-card',\n  type: 'text',\n  render() {}\n};\n\nvar RENDER_TYPE$1 = 'text';\n\nconst MARKUP_SECTION_TYPE$2 = 1;\nconst IMAGE_SECTION_TYPE$2 = 2;\nconst LIST_SECTION_TYPE$2 = 3;\nconst CARD_SECTION_TYPE$1 = 10;\n\n/**\n * runtime Text renderer\n * renders a mobiledoc to Text\n *\n * input: mobiledoc\n * output: Text (string)\n */\n\nconst LINE_BREAK = '\\n';\n\nconst MOBILEDOC_VERSION$6 = '0.2.0';\n\nfunction validateVersion$2(version) {\n  if (version !== MOBILEDOC_VERSION$6) {\n    throw new Error(`Unexpected Mobiledoc version \"${version}\"`);\n  }\n}\n\nclass Renderer$3 {\n  constructor(mobiledoc, state) {\n    let { cards, cardOptions, atoms, unknownCardHandler } = state;\n    let { version, sections: sectionData } = mobiledoc;\n    validateVersion$2(version);\n\n    let [, sections] = sectionData;\n\n    this.root               = [];\n    this.sections           = sections;\n    this.cards              = cards;\n    this.atoms              = atoms;\n    this.cardOptions        = cardOptions;\n    this.unknownCardHandler = unknownCardHandler || this._defaultUnknownCardHandler;\n\n    this._teardownCallbacks  = [];\n  }\n\n  render() {\n    this.sections.forEach(section => {\n      this.root.push(this.renderSection(section));\n    });\n\n    let result = this.root.join(LINE_BREAK);\n    return { result, teardown: () => this.teardown() };\n  }\n\n  teardown() {\n    for (let i=0; i < this._teardownCallbacks.length; i++) {\n      this._teardownCallbacks[i]();\n    }\n  }\n\n  get _defaultUnknownCardHandler() {\n    return () => {\n      // for the text renderer, a missing card is a no-op\n    };\n  }\n\n  renderSection(section) {\n    const [type] = section;\n    switch (type) {\n      case MARKUP_SECTION_TYPE$2:\n        return  this.renderMarkupSection(section);\n      case IMAGE_SECTION_TYPE$2:\n        return this.renderImageSection(section);\n      case LIST_SECTION_TYPE$2:\n        return this.renderListSection(section);\n      case CARD_SECTION_TYPE$1:\n        return this.renderCardSection(section);\n      default:\n        throw new Error('Unimplemented renderer for type ' + type);\n    }\n  }\n\n  renderImageSection() {\n    return '';\n  }\n\n  renderListSection([type, tagName, items]) {\n    return items.map(\n      li => this.renderListItem(li)\n    ).join(LINE_BREAK);\n  }\n\n  renderListItem(markers) {\n    return this.renderMarkers(markers);\n  }\n\n  findCard(name) {\n    for (let i=0; i < this.cards.length; i++) {\n      if (this.cards[i].name === name) {\n        return this.cards[i];\n      }\n    }\n    if (name === ImageCard$2.name) {\n      return ImageCard$2;\n    }\n    return this._createUnknownCard(name);\n  }\n\n  _createUnknownCard(name) {\n    return {\n      name,\n      type: RENDER_TYPE$1,\n      render: this.unknownCardHandler\n    };\n  }\n\n  renderCardSection([type, name, payload]) {\n    let card = this.findCard(name);\n\n    let cardArg = this._createCardArgument(card, payload);\n    let rendered = card.render(cardArg);\n\n    this._validateCardRender(rendered, card.name);\n\n    return rendered || '';\n  }\n\n  _validateCardRender(rendered, cardName) {\n    if (!rendered) {\n      return;\n    }\n\n    if (typeof rendered !== 'string') {\n      throw new Error(`Card \"${cardName}\" must render ${RENDER_TYPE$1}, but result was ${typeof rendered}\"`);\n    }\n  }\n\n  _registerTeardownCallback(callback) {\n    this._teardownCallbacks.push(callback);\n  }\n\n  _createCardArgument(card, payload={}) {\n    let env = {\n      name: card.name,\n      isInEditor: false,\n      onTeardown: (callback) => this._registerTeardownCallback(callback)\n    };\n\n    let options = this.cardOptions;\n\n    return { env, options, payload };\n  }\n\n  renderMarkupSection([type, tagName, markers]) {\n    return this.renderMarkers(markers);\n  }\n\n  renderMarkers(markers) {\n    let str = '';\n    markers.forEach(m => {\n      let [, , text] = m;\n      str += text;\n    });\n    return str;\n  }\n}\n\nconst MARKUP_MARKER_TYPE$1 = 0;\nconst ATOM_MARKER_TYPE$1 = 1;\n\n/**\n * runtime Text renderer\n * renders a mobiledoc to Text\n *\n * input: mobiledoc\n * output: Text (string)\n */\n\nconst LINE_BREAK$1 = '\\n';\n\nconst MOBILEDOC_VERSION_0_3 = '0.3.0';\nconst MOBILEDOC_VERSION_0_3_1$1 = '0.3.1';\nconst MOBILEDOC_VERSION_0_3_2$1 = '0.3.2';\n\nfunction validateVersion$3(version) {\n  if (\n    version !== MOBILEDOC_VERSION_0_3 &&\n    version !== MOBILEDOC_VERSION_0_3_1$1 &&\n    version !== MOBILEDOC_VERSION_0_3_2$1\n  ) {\n    throw new Error(`Unexpected Mobiledoc version \"${version}\"`);\n  }\n}\n\nclass Renderer$4 {\n  constructor(mobiledoc, state) {\n\n    let { cards, cardOptions, atoms, unknownCardHandler, unknownAtomHandler } = state;\n    let { version, sections, atoms: atomTypes, cards: cardTypes } = mobiledoc;\n    validateVersion$3(version);\n\n    this.root               = [];\n    this.sections           = sections;\n    this.atomTypes          = atomTypes;\n    this.cardTypes          = cardTypes;\n    this.cards              = cards;\n    this.atoms              = atoms;\n    this.cardOptions        = cardOptions;\n    this.unknownCardHandler = unknownCardHandler || this._defaultUnknownCardHandler;\n    this.unknownAtomHandler = unknownAtomHandler || this._defaultUnknownAtomHandler;\n\n    this._teardownCallbacks  = [];\n  }\n\n  render() {\n    this.sections.forEach(section => {\n      this.root.push(this.renderSection(section));\n    });\n\n    let result = this.root.join(LINE_BREAK$1);\n    return { result, teardown: () => this.teardown() };\n  }\n\n  teardown() {\n    for (let i=0; i < this._teardownCallbacks.length; i++) {\n      this._teardownCallbacks[i]();\n    }\n  }\n\n  get _defaultUnknownCardHandler() {\n    return () => {\n      // for the text renderer, a missing card is a no-op\n    };\n  }\n\n  get _defaultUnknownAtomHandler() {\n    return ({ value }) => {\n      return value || '';\n    };\n  }\n\n  renderSection(section) {\n    const [type] = section;\n    switch (type) {\n      case MARKUP_SECTION_TYPE$2:\n        return  this.renderMarkupSection(section);\n      case IMAGE_SECTION_TYPE$2:\n        return this.renderImageSection(section);\n      case LIST_SECTION_TYPE$2:\n        return this.renderListSection(section);\n      case CARD_SECTION_TYPE$1:\n        return this.renderCardSection(section);\n      default:\n        throw new Error('Unimplemented renderer for type ' + type);\n    }\n  }\n\n  renderImageSection() {\n    return '';\n  }\n\n  renderListSection([type, tagName, items]) {\n    return items.map(\n      li => this.renderListItem(li)\n    ).join(LINE_BREAK$1);\n  }\n\n  renderListItem(markers) {\n    return this.renderMarkers(markers);\n  }\n\n  findCard(name) {\n    for (let i=0; i < this.cards.length; i++) {\n      if (this.cards[i].name === name) {\n        return this.cards[i];\n      }\n    }\n    if (name === ImageCard$2.name) {\n      return ImageCard$2;\n    }\n    return this._createUnknownCard(name);\n  }\n\n  _findCardByIndex(index) {\n    let cardType = this.cardTypes[index];\n    if (!cardType) {\n      throw new Error(`No card definition found at index ${index}`);\n    }\n\n    let [ name, payload ] = cardType;\n    let card = this.findCard(name);\n\n    return {\n      card,\n      payload\n    };\n  }\n\n  _createUnknownCard(name) {\n    return {\n      name,\n      type: RENDER_TYPE$1,\n      render: this.unknownCardHandler\n    };\n  }\n\n  renderCardSection([type, index]) {\n    let { card, payload } = this._findCardByIndex(index);\n\n    let cardArg = this._createCardArgument(card, payload);\n    let rendered = card.render(cardArg);\n\n    this._validateCardRender(rendered, card.name);\n\n    return rendered || '';\n  }\n\n  _validateCardRender(rendered, cardName) {\n    if (!rendered) {\n      return;\n    }\n\n    if (typeof rendered !== 'string') {\n      throw new Error(`Card \"${cardName}\" must render ${RENDER_TYPE$1}, but result was ${typeof rendered}\"`);\n    }\n  }\n\n  _registerTeardownCallback(callback) {\n    this._teardownCallbacks.push(callback);\n  }\n\n  _createCardArgument(card, payload={}) {\n    let env = {\n      name: card.name,\n      isInEditor: false,\n      onTeardown: (callback) => this._registerTeardownCallback(callback)\n    };\n\n    let options = this.cardOptions;\n\n    return { env, options, payload };\n  }\n\n  renderMarkupSection([type, tagName, markers]) {\n    return this.renderMarkers(markers);\n  }\n\n  findAtom(name) {\n    for (let i=0; i < this.atoms.length; i++) {\n      if (this.atoms[i].name === name) {\n        return this.atoms[i];\n      }\n    }\n    return this._createUnknownAtom(name);\n  }\n\n  _createUnknownAtom(name) {\n    return {\n      name,\n      type: RENDER_TYPE$1,\n      render: this.unknownAtomHandler\n    };\n  }\n\n  _createAtomArgument(atom, value, payload) {\n    let env = {\n      name: atom.name,\n      onTeardown: (callback) => this._registerTeardownCallback(callback)\n    };\n\n    let options = this.cardOptions;\n\n    return { env, options, value, payload };\n  }\n\n  _validateAtomRender(rendered, atomName) {\n    if (!rendered) {\n      return;\n    }\n\n    if (typeof rendered !== 'string') {\n      throw new Error(`Atom \"${atomName}\" must render ${RENDER_TYPE$1}, but result was ${typeof rendered}\"`);\n    }\n  }\n\n  _findAtomByIndex(index) {\n    let atomType = this.atomTypes[index];\n    if (!atomType) {\n      throw new Error(`No atom definition found at index ${index}`);\n    }\n\n    let [ name, value, payload ] = atomType;\n    let atom = this.findAtom(name);\n\n    return {\n      atom,\n      value,\n      payload\n    };\n  }\n\n  _renderAtom(index) {\n    let { atom, value, payload } = this._findAtomByIndex(index);\n\n    let atomArg = this._createAtomArgument(atom, value, payload);\n    let rendered = atom.render(atomArg);\n\n    this._validateAtomRender(rendered, atom.name);\n\n    return rendered || '';\n  }\n\n  renderMarkers(markers) {\n    let str = '';\n    markers.forEach(m => {\n      let [type, , , value] = m;\n      switch (type) {\n        case MARKUP_MARKER_TYPE$1:\n          str += value;\n          break;\n        case ATOM_MARKER_TYPE$1:\n          str += this._renderAtom(value);\n          break;\n        default:\n          throw new Error(`Unknown markup type (${type})`);\n      }\n    });\n    return str;\n  }\n}\n\n/**\n * runtime Text renderer\n * renders a mobiledoc to Text\n *\n * input: mobiledoc\n * output: Text (string)\n */\n\nfunction validateCards$2(cards) {\n  if (!Array.isArray(cards)) {\n    throw new Error('`cards` must be passed as an array');\n  }\n  for (let i=0; i < cards.length; i++) {\n    let card = cards[i];\n    if (card.type !== RENDER_TYPE$1) {\n      throw new Error(`Card \"${card.name}\" must be type \"${RENDER_TYPE$1}\", was \"${card.type}\"`);\n    }\n    if (!card.render) {\n      throw new Error(`Card \"${card.name}\" must define \\`render\\``);\n    }\n  }\n}\n\nfunction validateAtoms$2(atoms) {\n  if (!Array.isArray(atoms)) {\n    throw new Error('`atoms` must be passed as an array');\n  }\n  for (let i=0; i < atoms.length; i++) {\n    let atom = atoms[i];\n    if (atom.type !== RENDER_TYPE$1) {\n      throw new Error(`Atom \"${atom.name}\" must be type \"${RENDER_TYPE$1}\", was \"${atom.type}\"`);\n    }\n    if (!atom.render) {\n      throw new Error(`Atom \"${atom.name}\" must define \\`render\\``);\n    }\n  }\n}\n\nclass RendererFactory$1 {\n  constructor({cards, atoms, cardOptions, unknownCardHandler, unknownAtomHandler}={}) {\n    cards = cards || [];\n    validateCards$2(cards);\n    atoms = atoms || [];\n    validateAtoms$2(atoms);\n    cardOptions = cardOptions || {};\n\n    this.state = {cards, atoms, cardOptions, unknownCardHandler, unknownAtomHandler};\n  }\n\n  render(mobiledoc) {\n    let { version } = mobiledoc;\n    switch (version) {\n      case MOBILEDOC_VERSION$6:\n        return new Renderer$3(mobiledoc, this.state).render();\n      case undefined:\n      case null:\n      case MOBILEDOC_VERSION_0_3:\n      case MOBILEDOC_VERSION_0_3_1$1:\n      case MOBILEDOC_VERSION_0_3_2$1:\n        return new Renderer$4(mobiledoc, this.state).render();\n      default:\n        throw new Error(`Unexpected Mobiledoc version \"${version}\"`);\n    }\n  }\n}\n\nclass Logger {\n  constructor(type, manager) {\n    this.type = type;\n    this.manager = manager;\n  }\n\n  isEnabled() {\n    return this.manager.isEnabled(this.type);\n  }\n\n  log(...args) {\n    args.unshift(`[${this.type}]`);\n    if (this.isEnabled()) {\n      window.console.log(...args);\n    }\n  }\n}\n\nclass LogManager {\n  constructor() {\n    this.enabledTypes = [];\n    this.allEnabled = false;\n  }\n\n  for(type) {\n    return new Logger(type, this);\n  }\n\n  enableAll() {\n    this.allEnabled = true;\n  }\n\n  enableTypes(types) {\n    this.enabledTypes = this.enabledTypes.concat(types);\n  }\n\n  disable() {\n    this.enabledTypes = [];\n    this.allEnabled = false;\n  }\n\n  isEnabled(type) {\n    return this.allEnabled || this.enabledTypes.indexOf(type) !== -1;\n  }\n}\n\nconst defaults = {\n  placeholder: 'Write here...',\n  spellcheck: true,\n  autofocus: true,\n  showLinkTooltips: true,\n  undoDepth: 5,\n  undoBlockTimeout: 5000, // ms for an undo event\n  cards: [],\n  atoms: [],\n  cardOptions: {},\n  unknownCardHandler: ({env}) => {\n    throw new MobiledocError(`Unknown card encountered: ${env.name}`);\n  },\n  unknownAtomHandler: ({env}) => {\n    throw new MobiledocError(`Unknown atom encountered: ${env.name}`);\n  },\n  mobiledoc: null,\n  html: null,\n  tooltipPlugin: DEFAULT_TOOLTIP_PLUGIN\n};\n\nconst CALLBACK_QUEUES$1 = {\n  DID_UPDATE: 'didUpdate',\n  WILL_RENDER: 'willRender',\n  DID_RENDER: 'didRender',\n  WILL_DELETE: 'willDelete',\n  DID_DELETE: 'didDelete',\n  WILL_HANDLE_NEWLINE: 'willHandleNewline',\n  CURSOR_DID_CHANGE: 'cursorDidChange',\n  DID_REPARSE: 'didReparse',\n  POST_DID_CHANGE: 'postDidChange',\n  INPUT_MODE_DID_CHANGE: 'inputModeDidChange',\n  WILL_COPY: 'willCopy'\n};\n\n/**\n * The Editor is a core component of mobiledoc-kit. After instantiating\n * an editor, use {@link Editor#render} to display the editor on the web page.\n *\n * An editor uses a {@link Post} internally to represent the displayed document.\n * The post can be serialized as mobiledoc using {@link Editor#serialize}. Mobiledoc\n * is the transportable \"over-the-wire\" format (JSON) that is suited for persisting\n * and sharing between editors and renderers (for display, e.g.), whereas the Post\n * model is better suited for programmatic editing.\n *\n * The editor will call registered callbacks for certain state changes. These are:\n *   * {@link Editor#cursorDidChange} -- The cursor position or selection changed.\n *   * {@link Editor#postDidChange} -- The contents of the post changed due to user input or\n *     programmatic editing. This hook can be used with {@link Editor#serialize}\n *     to auto-save a post as it is being edited.\n *   * {@link Editor#inputModeDidChange} -- The active section(s) or markup(s) at the current cursor\n *     position or selection have changed. This hook can be used with\n *     {@link Editor#activeMarkups} and {@link Editor#activeSections} to implement\n *     a custom toolbar.\n *   * {@link Editor#onTextInput} -- Register callbacks when the user enters text\n *     that matches a given string or regex.\n *   * {@link Editor#beforeToggleMarkup} -- Register callbacks that will be run before\n *     applying changes from {@link Editor#toggleMarkup}\n */\nclass Editor {\n  /**\n   * @param {Object} [options]\n   * @param {Object} [options.mobiledoc] The mobiledoc to load into the editor.\n   *        Supersedes `options.html`.\n   * @param {String|DOM} [options.html] The html (as a string or DOM fragment)\n   *        to parse and load into the editor.\n   *        Will be ignored if `options.mobiledoc` is also passed.\n   * @param {Array} [options.parserPlugins=[]]\n   * @param {Array} [options.cards=[]] The cards that the editor may render.\n   * @param {Array} [options.atoms=[]] The atoms that the editor may render.\n   * @param {Function} [options.unknownCardHandler] Invoked by the editor's renderer\n   *        whenever it encounters an unknown card.\n   * @param {Function} [options.unknownAtomHandler] Invoked by the editor's renderer\n   *        whenever it encounters an unknown atom.\n   * @param {String} [options.placeholder] Default text to show before user starts typing.\n   * @param {Boolean} [options.spellcheck=true] Whether to enable spellcheck\n   * @param {Boolean} [options.autofocus=true] Whether to focus the editor when it is first rendered.\n   * @param {Boolean} [options.showLinkTooltips=true] Whether to show the url tooltip for links\n   * @param {number} [options.undoDepth=5] How many undo levels will be available.\n   *        Set to 0 to disable undo/redo functionality.\n   * @return {Editor}\n   * @public\n   */\n  constructor(options={}) {\n    assert('editor create accepts an options object. For legacy usage passing an element for the first argument, consider the `html` option for loading DOM or HTML posts. For other cases call `editor.render(domNode)` after editor creation',\n          (options && !options.nodeType));\n    this._views = [];\n    this.isEditable = true;\n    this._parserPlugins = options.parserPlugins || [];\n\n    // FIXME: This should merge onto this.options\n    mergeWithOptions(this, defaults, options);\n    this.cards.push(ImageCard);\n\n    DEFAULT_KEY_COMMANDS.forEach(kc => this.registerKeyCommand(kc));\n\n    this._logManager = new LogManager();\n    this._parser   = new DOMParser(this.builder);\n    let {cards, atoms, unknownCardHandler, unknownAtomHandler, cardOptions} = this;\n    this._renderer = new Renderer(this, cards, atoms, unknownCardHandler, unknownAtomHandler, cardOptions);\n\n    this.post = this.loadPost();\n    this._renderTree = new RenderTree(this.post);\n\n    this._editHistory = new EditHistory(this, this.undoDepth, this.undoBlockTimeout);\n    this._eventManager = new EventManager(this);\n    this._mutationHandler = new MutationHandler(this);\n    this._editState = new EditState(this);\n    this._callbacks = new LifecycleCallbacks(values(CALLBACK_QUEUES$1));\n    this._beforeHooks = { toggleMarkup: [] };\n\n    DEFAULT_TEXT_INPUT_HANDLERS.forEach(handler => this.onTextInput(handler));\n\n    this.hasRendered = false;\n  }\n\n  /**\n   * Turns on verbose logging for the editor.\n   * @param {Array} [logTypes=[]] If present, only the given log types will be logged.\n   * @public\n   */\n  enableLogging(logTypes=[]) {\n    if (logTypes.length === 0) {\n      this._logManager.enableAll();\n    } else {\n      this._logManager.enableTypes(logTypes);\n    }\n  }\n\n  /**\n   * Disable all logging\n   * @public\n   */\n  disableLogging() {\n    this._logManager.disable();\n  }\n\n  /**\n   * @private\n   */\n  loggerFor(type) {\n    return this._logManager.for(type);\n  }\n\n  /**\n   * The editor's instance of a post node builder.\n   * @type {PostNodeBuilder}\n   */\n  get builder() {\n    if (!this._builder) { this._builder = new PostNodeBuilder(); }\n    return this._builder;\n  }\n\n  loadPost() {\n    let {mobiledoc, html} = this;\n    if (mobiledoc) {\n      return mobiledocParsers.parse(this.builder, mobiledoc);\n    } else if (html) {\n      if (typeof html === 'string') {\n        let options = {plugins: this._parserPlugins};\n        return new HTMLParser(this.builder, options).parse(this.html);\n      } else {\n        let dom = html;\n        return this._parser.parse(dom);\n      }\n    } else {\n      return this.builder.createPost([this.builder.createMarkupSection()]);\n    }\n  }\n\n  rerender() {\n    let postRenderNode = this.post.renderNode;\n\n    // if we haven't rendered this post's renderNode before, mark it dirty\n    if (!postRenderNode.element) {\n      assert('Must call `render` before `rerender` can be called',\n             this.hasRendered);\n      postRenderNode.element = this.element;\n      postRenderNode.markDirty();\n    }\n\n    this.runCallbacks(CALLBACK_QUEUES$1.WILL_RENDER);\n    this._mutationHandler.suspendObservation(() => {\n      this._renderer.render(this._renderTree);\n    });\n    this.runCallbacks(CALLBACK_QUEUES$1.DID_RENDER);\n  }\n\n  /**\n   * @param {Element} element The DOM element to render into.\n   *        Its contents will be replaced by the editor's rendered post.\n   * @public\n   */\n  render(element) {\n    assert('Cannot render an editor twice. Use `rerender` to update the ' +\n           'rendering of an existing editor instance.',\n           !this.hasRendered);\n\n    element.spellcheck = this.spellcheck;\n\n    clearChildNodes(element);\n\n    this.element = element;\n\n    if (this.showLinkTooltips) {\n      this._addTooltip();\n    }\n\n    // A call to `run` will trigger the didUpdatePostCallbacks hooks with a\n    // postEditor.\n    this.run(() => {});\n\n    // Only set `hasRendered` to true after calling `run` to ensure that\n    // no cursorDidChange or other callbacks get fired before the editor is\n    // done rendering\n    this.hasRendered = true;\n    this.rerender();\n\n    this._mutationHandler.init();\n    this._eventManager.init();\n\n    if (this.isEditable === false) {\n      this.disableEditing();\n    } else {\n      this.enableEditing();\n    }\n\n    if (this.autofocus) {\n      this.selectRange(this.post.headPosition());\n    }\n  }\n\n  _addTooltip() {\n    this.addView(new Tooltip({\n      rootElement: this.element,\n      showForTag: 'a',\n      editor: this\n    }));\n  }\n\n  get keyCommands() {\n    if (!this._keyCommands) { this._keyCommands = []; }\n    return this._keyCommands;\n  }\n\n  /**\n   * @param {Object} keyCommand The key command to register. It must specify a\n   * modifier key (meta, ctrl, etc), a string representing the ascii key, and\n   * a `run` method that will be passed the editor instance when the key command\n   * is invoked\n   * @public\n   */\n  registerKeyCommand(rawKeyCommand) {\n    const keyCommand = buildKeyCommand(rawKeyCommand);\n    assert('Key Command is not valid', validateKeyCommand(keyCommand));\n    this.keyCommands.unshift(keyCommand);\n  }\n\n  /**\n   * @param {String} name If the keyCommand event has a name attribute it can be removed.\n   * @public\n   */\n  unregisterKeyCommands(name) {\n    for(let i = this.keyCommands.length-1; i > -1; i--) {\n      let keyCommand = this.keyCommands[i];\n\n      if(keyCommand.name === name) {\n        this.keyCommands.splice(i,1);\n      }\n    }\n  }\n\n  /**\n   * Convenience for {@link PostEditor#deleteAtPosition}. Deletes and puts the\n   * cursor in the new position.\n   * @public\n   */\n  deleteAtPosition(position, direction, {unit}) {\n    this.run(postEditor => {\n      let nextPosition = postEditor.deleteAtPosition(position, direction, {unit});\n      postEditor.setRange(nextPosition);\n    });\n  }\n\n  /**\n   * Convenience for {@link PostEditor#deleteRange}. Deletes and puts the\n   * cursor in the new position.\n   * @param {Range} range\n   * @public\n   */\n  deleteRange(range) {\n    this.run(postEditor => {\n      let nextPosition = postEditor.deleteRange(range);\n      postEditor.setRange(nextPosition);\n    });\n  }\n\n  /**\n   * @private\n   */\n  performDelete({direction, unit}={direction: DIRECTION.BACKWARD, unit: 'char'}) {\n    let { range } = this;\n\n    this.runCallbacks(CALLBACK_QUEUES$1.WILL_DELETE, [range, direction, unit]);\n    if (range.isCollapsed) {\n      this.deleteAtPosition(range.head, direction, {unit});\n    } else {\n      this.deleteRange(range);\n    }\n    this.runCallbacks(CALLBACK_QUEUES$1.DID_DELETE, [range, direction, unit]);\n  }\n\n  handleNewline(event) {\n    if (!this.hasCursor()) { return; }\n\n    event.preventDefault();\n\n    let { range } = this;\n    this.run(postEditor => {\n      let cursorSection;\n      if (!range.isCollapsed) {\n        let nextPosition  = postEditor.deleteRange(range);\n        cursorSection = nextPosition.section;\n        if (cursorSection && cursorSection.isBlank) {\n          postEditor.setRange(cursorSection.headPosition());\n          return;\n        }\n      }\n\n      // Above logic might delete redundant range, so callback must run after it.\n      let defaultPrevented = false;\n      const event = { preventDefault() { defaultPrevented = true; } };\n      this.runCallbacks(CALLBACK_QUEUES$1.WILL_HANDLE_NEWLINE, [event]);\n      if (defaultPrevented) { return; }\n\n      cursorSection = postEditor.splitSection(range.head)[1];\n      postEditor.setRange(cursorSection.headPosition());\n    });\n  }\n\n  /**\n   * Notify the editor that the post did change, and run associated\n   * callbacks.\n   * @private\n   */\n  _postDidChange() {\n    this.runCallbacks(CALLBACK_QUEUES$1.POST_DID_CHANGE);\n  }\n\n  /**\n   * Selects the given range or position. If given a collapsed range or a position, this positions the cursor\n   * at the range's position. Otherwise a selection is created in the editor\n   * surface encompassing the range.\n   * @param {Range|Position} range\n   */\n  selectRange(range) {\n    range = toRange(range);\n\n    this.cursor.selectRange(range);\n    this.range = range;\n  }\n\n  get cursor() {\n    return new Cursor(this);\n  }\n\n  /**\n   * Return the current range for the editor (may be cached).\n   * @return {Range}\n   */\n  get range() {\n    return this._editState.range;\n  }\n\n  set range(newRange) {\n    this._editState.updateRange(newRange);\n\n    if (this._editState.rangeDidChange()) {\n      this._rangeDidChange();\n    }\n\n    if (this._editState.inputModeDidChange()) {\n      this._inputModeDidChange();\n    }\n  }\n\n  _readRangeFromDOM() {\n    this.range = this.cursor.offsets;\n  }\n\n  setPlaceholder(placeholder) {\n    setData(this.element, 'placeholder', placeholder);\n  }\n\n  _reparsePost() {\n    let post = this._parser.parse(this.element);\n    this.run(postEditor => {\n      postEditor.removeAllSections();\n      postEditor.migrateSectionsFromPost(post);\n      postEditor.setRange(Range.blankRange());\n    });\n\n    this.runCallbacks(CALLBACK_QUEUES$1.DID_REPARSE);\n    this._postDidChange();\n  }\n\n  _reparseSections(sections=[]) {\n    let currentRange;\n    sections.forEach(section => {\n      this._parser.reparseSection(section, this._renderTree);\n    });\n    this._removeDetachedSections();\n\n    if (this._renderTree.isDirty) {\n      currentRange = this.range;\n    }\n\n    // force the current snapshot's range to remain the same rather than\n    // rereading it from DOM after the new character is applied and the browser\n    // updates the cursor position\n    let range = this._editHistory._pendingSnapshot.range;\n    this.run(() => {\n      this._editHistory._pendingSnapshot.range = range;\n    });\n    this.rerender();\n    if (currentRange) {\n      this.selectRange(currentRange);\n    }\n\n    this.runCallbacks(CALLBACK_QUEUES$1.DID_REPARSE);\n    this._postDidChange();\n  }\n\n  // FIXME this should be able to be removed now -- if any sections are detached,\n  // it's due to a bug in the code.\n  _removeDetachedSections() {\n    forEach(\n      filter(this.post.sections, s => !s.renderNode.isAttached()),\n      s => s.renderNode.scheduleForRemoval()\n    );\n  }\n\n  /**\n   * The sections from the cursor's selection start to the selection end\n   * @type {Section[]}\n   */\n  get activeSections() {\n    return this._editState.activeSections;\n  }\n\n  get activeSection() {\n    const { activeSections } = this;\n    return activeSections[activeSections.length - 1];\n  }\n\n  get activeSectionAttributes() {\n    return this._editState.activeSectionAttributes;\n  }\n\n  detectMarkupInRange(range, markupTagName) {\n    let markups = this.post.markupsInRange(range);\n    return detect(markups, markup => {\n      return markup.hasTag(markupTagName);\n    });\n  }\n\n  /**\n   * @type {Markup[]}\n   * @public\n   */\n  get activeMarkups() {\n    return this._editState.activeMarkups;\n  }\n\n  /**\n   * @param {Markup|String} markup A markup instance, or a string (e.g. \"b\")\n   * @return {boolean}\n   */\n  hasActiveMarkup(markup) {\n    let matchesFn;\n    if (typeof markup === 'string') {\n      let tagName = normalizeTagName(markup);\n      matchesFn = (m) => m.tagName === tagName;\n    } else {\n      matchesFn = (m) => m === markup;\n    }\n\n    return !!detect(this.activeMarkups, matchesFn);\n  }\n\n  /**\n   * @param {String} version The mobiledoc version to serialize to.\n   * @return {Mobiledoc} Serialized mobiledoc\n   * @public\n   */\n  serialize(version=MOBILEDOC_VERSION$4) {\n    return this.serializePost(this.post, 'mobiledoc', {version});\n  }\n\n  /**\n   * Serialize the editor's post to the requested format.\n   * Note that only mobiledoc format is lossless. If cards or atoms are present\n   * in the post, the html and text formats will omit them in output because\n   * the editor does not have access to the html and text versions of the\n   * cards/atoms.\n   * @param {string} format The format to serialize ('mobiledoc', 'text', 'html')\n   * @return {Object|String} The editor's post, serialized to {format}\n   * @public\n   */\n  serializeTo(format) {\n    let post = this.post;\n    return this.serializePost(post, format);\n  }\n\n  /**\n   * @param {Post}\n   * @param {String} format Same as {serializeTo}\n   * @param {Object} [options]\n   * @param {String} [options.version=MOBILEDOC_VERSION] version to serialize to\n   * @return {Object|String}\n   * @private\n   */\n  serializePost(post, format, options={}) {\n    const validFormats = ['mobiledoc', 'html', 'text'];\n    assert(`Unrecognized serialization format ${format}`,\n           contains(validFormats, format));\n\n    if (format === 'mobiledoc') {\n      let version = options.version || MOBILEDOC_VERSION$4;\n      return mobiledocRenderers.render(post, version);\n    } else {\n      let rendered;\n      let mobiledoc = this.serializePost(post, 'mobiledoc');\n      let unknownCardHandler = () => {};\n      let unknownAtomHandler = () => {};\n      let rendererOptions = { unknownCardHandler, unknownAtomHandler };\n\n      switch (format) {\n        case 'html': {\n          let result;\n          if (Environment.hasDOM()) {\n            rendered = new RendererFactory(rendererOptions).render(mobiledoc);\n            result = `<div>${serializeHTML(rendered.result)}</div>`;\n          } else {\n            // Fallback to text serialization\n            result = this.serializePost(post, 'text', options);\n          }\n          return result;\n        }\n        case 'text':\n          rendered = new RendererFactory$1(rendererOptions).render(mobiledoc);\n          return rendered.result;\n      }\n    }\n  }\n\n  addView(view) {\n    this._views.push(view);\n  }\n\n  removeAllViews() {\n    this._views.forEach((v) => v.destroy());\n    this._views = [];\n  }\n\n  /**\n   * Whether the editor has a cursor (or a selected range).\n   * It is possible for the editor to be focused but not have a selection.\n   * In this case, key events will fire but the editor will not be able to\n   * determine a cursor position, so they will be ignored.\n   * @return {boolean}\n   * @public\n   */\n  hasCursor() {\n    return this.cursor.hasCursor();\n  }\n\n  /**\n   * Tears down the editor's attached event listeners and views.\n   * @public\n   */\n  destroy() {\n    this.isDestroyed = true;\n    if (this._hasSelection()) {\n      this.cursor.clearSelection();\n    }\n    if (this._hasFocus()) {\n      this.element.blur(); // FIXME This doesn't blur the element on IE11\n    }\n    this._mutationHandler.destroy();\n    this._eventManager.destroy();\n    this.removeAllViews();\n    this._renderer.destroy();\n    this._editState.destroy();\n  }\n\n  /**\n   * Keep the user from directly editing the post using the keyboard and mouse.\n   * Modification via the programmatic API is still permitted.\n   * @see Editor#enableEditing\n   * @public\n   */\n  disableEditing() {\n    this.isEditable = false;\n    if (this.hasRendered) {\n      this._eventManager.stop();\n      this.element.setAttribute('contentEditable', false);\n      this.setPlaceholder('');\n      this.selectRange(Range.blankRange());\n    }\n  }\n\n  /**\n   * Allow the user to directly interact with editing a post via keyboard and mouse input.\n   * Editor instances are editable by default. Use this method to re-enable\n   * editing after disabling it.\n   * @see Editor#disableEditing\n   * @public\n   */\n  enableEditing() {\n    this.isEditable = true;\n    if (this.hasRendered) {\n      this._eventManager.start();\n      this.element.setAttribute('contentEditable', true);\n      this.setPlaceholder(this.placeholder);\n    }\n  }\n\n  /**\n   * Change a cardSection into edit mode\n   * If called before the card has been rendered, it will be marked so that\n   * it is rendered in edit mode when it gets rendered.\n   * @param {CardSection} cardSection\n   * @public\n   */\n  editCard(cardSection) {\n    this._setCardMode(cardSection, CARD_MODES.EDIT);\n  }\n\n  /**\n   * Change a cardSection into display mode\n   * If called before the card has been rendered, it will be marked so that\n   * it is rendered in display mode when it gets rendered.\n   * @param {CardSection} cardSection\n   * @return undefined\n   * @public\n   */\n  displayCard(cardSection) {\n    this._setCardMode(cardSection, CARD_MODES.DISPLAY);\n  }\n\n  /**\n   * Run a new post editing session. Yields a block with a new {@link PostEditor}\n   * instance. This instance can be used to interact with the post abstract.\n   * Rendering will be deferred until after the callback is completed.\n   *\n   * Usage:\n   * ```\n   *   let markerRange = this.range;\n   *   editor.run((postEditor) => {\n   *     postEditor.deleteRange(markerRange);\n   *     // editing surface not updated yet\n   *     postEditor.schedule(() => {\n   *       console.log('logs during rerender flush');\n   *     });\n   *     // logging not yet flushed\n   *   });\n   *   // editing surface now updated.\n   *   // logging now flushed\n   * ```\n   *\n   * @param {Function} callback Called with an instance of\n   *        {@link PostEditor} as its argument.\n   * @return {Mixed} The return value of `callback`.\n   * @public\n   */\n  run(callback) {\n    const postEditor = new PostEditor(this);\n    postEditor.begin();\n    this._editHistory.snapshot();\n    const result = callback(postEditor);\n    this.runCallbacks(CALLBACK_QUEUES$1.DID_UPDATE, [postEditor]);\n    postEditor.complete();\n    this._readRangeFromDOM();\n\n    if (postEditor._shouldCancelSnapshot) {\n      this._editHistory._pendingSnapshot = null;\n    }\n    this._editHistory.storeSnapshot(postEditor.editActionTaken);\n\n    return result;\n  }\n\n  /**\n   * @param {Function} callback Called with `postEditor` as its argument.\n   * @public\n   */\n  didUpdatePost(callback) {\n    this.addCallback(CALLBACK_QUEUES$1.DID_UPDATE, callback);\n  }\n\n  /**\n   * @param {Function} callback Called when the post has changed, either via\n   *        user input or programmatically. Use with {@link Editor#serialize} to\n   *        retrieve the post in portable mobiledoc format.\n   */\n  postDidChange(callback) {\n    this.addCallback(CALLBACK_QUEUES$1.POST_DID_CHANGE, callback);\n  }\n\n  /**\n   * Register a handler that will be invoked by the editor after the user enters\n   * matching text.\n   * @param {Object} inputHandler\n   * @param {String} inputHandler.name Required. Used by identifying handlers.\n   * @param {String} [inputHandler.text] Required if `match` is not provided\n   * @param {RegExp} [inputHandler.match] Required if `text` is not provided\n   * @param {Function} inputHandler.run This callback is invoked with the {@link Editor}\n   *                   instance and an array of matches. If `text` was provided,\n   *                   the matches array will equal [`text`], and if a `match`\n   *                   regex was provided the matches array will be the result of\n   *                   `match.exec` on the matching text. The callback is called\n   *                   after the matching text has been inserted.\n   * @public\n   */\n  onTextInput(inputHandler) {\n    this._eventManager.registerInputHandler(inputHandler);\n  }\n\n  /**\n   * Unregister all text input handlers\n   *\n   * @public\n   */\n  unregisterAllTextInputHandlers() {\n    this._eventManager.unregisterAllTextInputHandlers();\n  }\n\n  /**\n   * Unregister text input handler by name\n   * @param {String} name The name of handler to be removed\n   *\n   * @public\n   */\n  unregisterTextInputHandler(name) {\n    this._eventManager.unregisterInputHandler(name);\n  }\n\n  /**\n   * @param {Function} callback Called when the editor's state (active markups or\n   * active sections) has changed, either via user input or programmatically\n   */\n  inputModeDidChange(callback) {\n    this.addCallback(CALLBACK_QUEUES$1.INPUT_MODE_DID_CHANGE, callback);\n  }\n\n  /**\n   * @param {Function} callback This callback will be called before the editor\n   *        is rendered.\n   * @public\n   */\n  willRender(callback) {\n    this.addCallback(CALLBACK_QUEUES$1.WILL_RENDER, callback);\n  }\n\n  /**\n   * @param {Function} callback This callback will be called after the editor\n   *        is rendered.\n   * @public\n   */\n  didRender(callback) {\n    this.addCallback(CALLBACK_QUEUES$1.DID_RENDER, callback);\n  }\n\n  willCopy(callback) {\n    this.addCallback(CALLBACK_QUEUES$1.WILL_COPY, callback);\n  }\n\n  /**\n   * @param {Function} callback This callback will be called before deleting.\n   * @public\n   */\n  willDelete(callback) {\n    this.addCallback(CALLBACK_QUEUES$1.WILL_DELETE, callback);\n  }\n\n  /**\n   * @param {Function} callback This callback will be called after deleting.\n   * @public\n   */\n  didDelete(callback) {\n    this.addCallback(CALLBACK_QUEUES$1.DID_DELETE, callback);\n  }\n\n  /**\n   * @param {Function} callback This callback will be called before handling new line.\n   * @public\n   */\n  willHandleNewline(callback) {\n    this.addCallback(CALLBACK_QUEUES$1.WILL_HANDLE_NEWLINE, callback);\n  }\n\n  /**\n   * @param {Function} callback This callback will be called every time the cursor\n   *        position (or selection) changes.\n   * @public\n   */\n  cursorDidChange(callback) {\n    this.addCallback(CALLBACK_QUEUES$1.CURSOR_DID_CHANGE, callback);\n  }\n\n  _rangeDidChange() {\n    if (this.hasRendered) {\n      this.runCallbacks(CALLBACK_QUEUES$1.CURSOR_DID_CHANGE);\n    }\n  }\n\n  _inputModeDidChange() {\n    this.runCallbacks(CALLBACK_QUEUES$1.INPUT_MODE_DID_CHANGE);\n  }\n\n  _insertEmptyMarkupSectionAtCursor() {\n    this.run(postEditor => {\n      const section = postEditor.builder.createMarkupSection('p');\n      postEditor.insertSectionBefore(this.post.sections, section);\n      postEditor.setRange(section.toRange());\n    });\n  }\n\n  /**\n   * @callback editorBeforeCallback\n   * @param { Object } details\n   * @param { Markup } details.markup\n   * @param { Range } details.range\n   * @param { boolean } details.willAdd Whether the markup will be applied\n   */\n\n  /**\n   * Register a callback that will be run before {@link Editor#toggleMarkup} is applied.\n   * If any callback returns literal `false`, the toggling of markup will be canceled.\n   * Note this only applies to calling `editor#toggleMarkup`. Using `editor.run` and\n   * modifying markup with the `postEditor` will skip any `beforeToggleMarkup` callbacks.\n   * @param {editorBeforeCallback}\n   */\n  beforeToggleMarkup(callback) {\n    this._beforeHooks.toggleMarkup.push(callback);\n  }\n\n  /**\n   * Toggles the given markup at the editor's current {@link Range}.\n   * If the range is collapsed this changes the editor's state so that the\n   * next characters typed will be affected. If there is text selected\n   * (aka a non-collapsed range), the selections' markup will be toggled.\n   * If the editor is not focused and has no active range, nothing happens.\n   * Hooks added using #beforeToggleMarkup will be run before toggling,\n   * and if any of them returns literal false, toggling the markup will be canceled\n   * and no change will be applied.\n   * @param {String} markup E.g. \"b\", \"em\", \"a\"\n   * @param {Object} [attributes={}] E.g. {href: \"http://bustle.com\"}\n   * @public\n   * @see PostEditor#toggleMarkup\n   */\n  toggleMarkup(markup, attributes={}) {\n    markup = this.builder.createMarkup(markup, attributes);\n    let { range } = this;\n    let willAdd = !this.detectMarkupInRange(range, markup.tagName);\n    let shouldCancel = this._runBeforeHooks('toggleMarkup', {markup, range, willAdd});\n    if (shouldCancel) { return; }\n\n    if (range.isCollapsed) {\n      this._editState.toggleMarkupState(markup);\n      this._inputModeDidChange();\n\n      // when clicking a button to toggle markup, the button can end up being focused,\n      // so ensure the editor is focused\n      this._ensureFocus();\n    } else {\n      this.run(postEditor => postEditor.toggleMarkup(markup, range));\n    }\n  }\n\n  // If the editor has a selection but is not focused, focus it\n  _ensureFocus() {\n    if (this._hasSelection() && !this._hasFocus()) {\n      this.focus();\n    }\n  }\n\n  focus() {\n    this.element.focus();\n  }\n\n  /**\n   * Whether there is a selection inside the editor's element.\n   * It's possible to have a selection but not have focus.\n   * @see #_hasFocus\n   * @return {Boolean}\n   */\n  _hasSelection() {\n    let { cursor } = this;\n    return this.hasRendered && (cursor._hasCollapsedSelection() || cursor._hasSelection());\n  }\n\n  /**\n   * Whether the editor's element is focused\n   * It's possible to be focused but have no selection\n   * @see #_hasSelection\n   * @return {Boolean}\n   */\n  _hasFocus() {\n    return document.activeElement === this.element;\n  }\n\n  /**\n   * Toggles the tagName for the current active section(s). This will skip\n   * non-markerable sections. E.g. if the editor's range includes a \"P\" MarkupSection\n   * and a CardSection, only the MarkupSection will be toggled.\n   * @param {String} tagName The new tagname to change to.\n   * @public\n   * @see PostEditor#toggleSection\n   */\n  toggleSection(tagName) {\n    this.run(postEditor => postEditor.toggleSection(tagName, this.range));\n  }\n\n  /**\n   * Sets an attribute for the current active section(s).\n   *\n   * @param {String} key The attribute. The only valid attribute is 'text-align'.\n   * @param {String} value The value of the attribute.\n   * @public\n   * @see PostEditor#setAttribute\n   */\n  setAttribute(key, value) {\n    this.run(postEditor => postEditor.setAttribute(key, value, this.range));\n  }\n\n  /**\n   * Removes an attribute from the current active section(s).\n   *\n   * @param {String} key The attribute. The only valid attribute is 'text-align'.\n   * @public\n   * @see PostEditor#removeAttribute\n   */\n  removeAttribute(key) {\n    this.run(postEditor => postEditor.removeAttribute(key, this.range));\n  }\n\n  /**\n   * Finds and runs the first matching key command for the event\n   *\n   * If multiple commands are bound to a key combination, the\n   * first matching one is run.\n   *\n   * If a command returns `false` then the next matching command\n   * is run instead.\n   *\n   * @param {Event} event The keyboard event triggered by the user\n   * @return {Boolean} true when a command was successfully run\n   * @private\n   */\n  handleKeyCommand(event) {\n    const keyCommands = findKeyCommands(this.keyCommands, event);\n    for (let i=0; i<keyCommands.length; i++) {\n      let keyCommand = keyCommands[i];\n      if (keyCommand.run(this) !== false) {\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Inserts the text at the current cursor position. If the editor has\n   * no current cursor position, nothing will be inserted. If the editor's\n   * range is not collapsed, it will be deleted before insertion.\n   *\n   * @param {String} text\n   * @public\n   */\n  insertText(text) {\n    if (!this.hasCursor()) { return; }\n    if (this.post.isBlank) {\n      this._insertEmptyMarkupSectionAtCursor();\n    }\n    let { activeMarkups, range, range: { head: position } } = this;\n\n    this.run(postEditor => {\n      if (!range.isCollapsed) {\n        position = postEditor.deleteRange(range);\n      }\n\n      postEditor.insertTextWithMarkup(position, text, activeMarkups);\n    });\n  }\n\n  /**\n   * Inserts an atom at the current cursor position. If the editor has\n   * no current cursor position, nothing will be inserted. If the editor's\n   * range is not collapsed, it will be deleted before insertion.\n   * @param {String} atomName\n   * @param {String} [atomText='']\n   * @param {Object} [atomPayload={}]\n   * @return {Atom} The inserted atom.\n   * @public\n   */\n  insertAtom(atomName, atomText='', atomPayload={}) {\n    if (!this.hasCursor()) { return; }\n    if (this.post.isBlank) {\n      this._insertEmptyMarkupSectionAtCursor();\n    }\n\n    let atom;\n    let { range } = this;\n    this.run(postEditor => {\n      let position = range.head;\n\n      atom = postEditor.builder.createAtom(atomName, atomText, atomPayload);\n      if (!range.isCollapsed) {\n        position = postEditor.deleteRange(range);\n      }\n\n      postEditor.insertMarkers(position, [atom]);\n    });\n    return atom;\n  }\n\n  /**\n   * Inserts a card at the section after the current cursor position. If the editor has\n   * no current cursor position, nothing will be inserted. If the editor's\n   * range is not collapsed, it will be deleted before insertion. If the cursor is in\n   * a blank section, it will be replaced with a card section.\n   * The editor's cursor will be placed at the end of the inserted card.\n   * @param {String} cardName\n   * @param {Object} [cardPayload={}]\n   * @param {Boolean} [inEditMode=false] Whether the card should be inserted in edit mode.\n   * @return {Card} The inserted Card section.\n   * @public\n   */\n  insertCard(cardName, cardPayload={}, inEditMode=false) {\n    if (!this.hasCursor()) { return; }\n    if (this.post.isBlank) {\n      this._insertEmptyMarkupSectionAtCursor();\n    }\n\n    let card;\n    let { range } = this;\n    this.run(postEditor => {\n      let position = range.tail;\n      card = postEditor.builder.createCardSection(cardName, cardPayload);\n      if (inEditMode) {\n        this.editCard(card);\n      }\n\n      if (!range.isCollapsed) {\n        position = postEditor.deleteRange(range);\n      }\n\n      let section = position.section;\n      if (section.isNested) { section = section.parent; }\n\n      if (section.isBlank) {\n        postEditor.replaceSection(section, card);\n      } else {\n        let collection = this.post.sections;\n        postEditor.insertSectionBefore(collection, card, section.next);\n      }\n\n      // It is important to explicitly set the range to the end of the card.\n      // Otherwise it is possible to create an inconsistent state in the\n      // browser. For instance, if the user clicked a button that\n      // called `editor.insertCard`, the editor surface may retain\n      // the selection but lose focus, and the next keystroke by the user\n      // will cause an unexpected DOM mutation (which can wipe out the\n      // card).\n      // See: https://github.com/bustle/mobiledoc-kit/issues/286\n      postEditor.setRange(card.tailPosition());\n    });\n    return card;\n  }\n\n  /**\n   * @param {integer} x x-position in viewport\n   * @param {integer} y y-position in viewport\n   * @return {Position|null}\n   */\n  positionAtPoint(x, y) {\n    return Position$1.atPoint(x, y, this);\n  }\n\n  /**\n   * @private\n   */\n  _setCardMode(cardSection, mode) {\n    const renderNode = cardSection.renderNode;\n    if (renderNode && renderNode.isRendered) {\n      const cardNode = renderNode.cardNode;\n      cardNode[mode]();\n    } else {\n      cardSection.setInitialMode(mode);\n    }\n  }\n\n  triggerEvent(context, eventName, event) {\n    this._eventManager._trigger(context, eventName, event);\n  }\n\n  addCallback(...args) {\n    this._callbacks.addCallback(...args);\n  }\n\n  addCallbackOnce(...args) {\n    this._callbacks.addCallbackOnce(...args);\n  }\n\n  runCallbacks(...args) {\n    if (this.isDestroyed) {\n      // TODO warn that callback attempted after editor was destroyed\n      return;\n    }\n    this._callbacks.runCallbacks(...args);\n  }\n\n  /**\n   * Runs each callback for the given hookName.\n   * Only the hookName 'toggleMarkup' is currently supported\n   * @return {Boolean} shouldCancel Whether the action in `hookName` should be canceled\n   * @private\n   */\n  _runBeforeHooks(hookName, ...args) {\n    let hooks = this._beforeHooks[hookName] || [];\n    for (let i = 0; i < hooks.length; i++) {\n      if (hooks[i](...args) === false) {\n        return true;\n      }\n    }\n  }\n}\n\nvar version = '##VERSION##';\n\nexport { Editor, MobiledocError as Error, ImageCard, MOBILEDOC_VERSION$4 as MOBILEDOC_VERSION, Position$1 as Position, Range, ui as UI, version as VERSION };\n//# sourceMappingURL=mobiledoc.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/mobiledoc-kit/dist/mobiledoc.js\n// module id = 45\n// module chunks = 0","module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/component-normalizer.js\n// module id = 46\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": \"mobiledoc-editor_container\"\n    }\n  }, [_vm._t(\"header\"), _vm._v(\" \"), _vm._t(\"default\"), _vm._v(\" \"), _c('div', {\n    ref: \"editorPost\",\n    attrs: {\n      \"id\": \"mobiledoc-editor_editor\"\n    }\n  }), _vm._v(\" \"), _vm._t(\"footer\")], 2)\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-44c34a7c!./~/vue-loader/lib/selector.js?type=template&index=0!./src/MobiledocEditor.vue\n// module id = 47\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_48__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"vue\"\n// module id = 48\n// module chunks = 0","import MobiledocEditor from 'MobiledocEditor'\nimport MobiledocButton from 'MobiledocButton'\nimport MobiledocToolbar from 'addons/MobiledocToolbar'\nimport compToCard from 'addons/compToCard'\nimport { EMPTY_MOBILEDOC } from './helpers/mobiledocFormats'\n\nexport {\n  MobiledocEditor,\n  MobiledocButton,\n  MobiledocToolbar,\n  compToCard,\n  EMPTY_MOBILEDOC\n}\n\nexport default {\n  Editor: MobiledocEditor,\n  Button: MobiledocButton\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}